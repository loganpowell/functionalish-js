'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@thi.ng/api');
var diff = require('@thi.ng/diff');
var equiv$1 = require('@thi.ng/equiv');
var checks = require('@thi.ng/checks');
var hiccup = require('@thi.ng/hiccup');
var errors = require('@thi.ng/errors');

exports.LOGGER = api.NULL_LOGGER;
const setLogger = (logger) => (exports.LOGGER = logger);

const isArray = Array.isArray;
const max = Math.max;
const OBJP = Object.getPrototypeOf({});
const FN = "function";
const STR = "string";
const INDEX = (() => {
    const res = new Array(2048);
    for (let i = 2, n = res.length; i < n; i++) {
        res[i] = i - 2;
    }
    return res;
})();
const buildIndex = (n) => {
    if (n <= INDEX.length) {
        return INDEX.slice(0, n);
    }
    const res = new Array(n);
    while (--n >= 2) {
        res[n] = n - 2;
    }
    return res;
};
const diffTree = (opts, impl, parent, prev, curr, child = 0) => {
    const attribs = curr[1];
    if (attribs.__skip) {
        return;
    }
    if (attribs.__diff === false) {
        releaseTree(prev);
        impl.replaceChild(opts, parent, child, curr);
        return;
    }
    const pattribs = prev[1];
    if (pattribs && pattribs.__skip) {
        impl.replaceChild(opts, parent, child, curr, false);
        return;
    }
    let _impl = attribs.__impl;
    if (_impl && _impl !== impl) {
        return _impl.diffTree(opts, _impl, parent, prev, curr, child);
    }
    const delta = diff.diffArray(prev, curr, 1 , equiv);
    if (delta.distance === 0) {
        return;
    }
    const edits = delta.linear;
    const el = impl.getChild(parent, child);
    let ii;
    let status;
    let val;
    if (edits[0] !== 0 || prev[1].key !== attribs.key) {
        releaseTree(prev);
        impl.replaceChild(opts, parent, child, curr);
        return;
    }
    if ((val = prev.__release) && val !== curr.__release) {
        releaseTree(prev);
    }
    if (edits[3] !== 0) {
        diffAttributes(impl, el, prev[1], curr[1]);
        if (delta.distance === 2) {
            return;
        }
    }
    const numEdits = edits.length;
    const prevLength = prev.length - 1;
    const equivKeys = extractEquivElements(edits);
    const offsets = buildIndex(prevLength + 1);
    for (ii = 6; ii < numEdits; ii += 3) {
        status = edits[ii];
        if (!status)
            continue;
        if (status === -1) {
            diffDeleted(opts, impl, el, prev, curr, edits, ii, equivKeys, offsets, prevLength);
        }
        else {
            diffAdded(opts, impl, el, edits, ii, equivKeys, offsets, prevLength);
        }
    }
    if ((val = curr.__init) && val != prev.__init) {
        val.apply(curr, [el, ...curr.__args]);
    }
};
const diffDeleted = (opts, impl, el, prev, curr, edits, ii, equivKeys, offsets, prevLength) => {
    const val = edits[ii + 2];
    if (isArray(val)) {
        let k = val[1].key;
        if (k !== undefined && equivKeys[k][2] !== undefined) {
            const eq = equivKeys[k];
            k = eq[0];
            diffTree(opts, impl, el, prev[k], curr[eq[2]], offsets[k]);
        }
        else {
            const idx = edits[ii + 1];
            releaseTree(val);
            impl.removeChild(el, offsets[idx]);
            incOffsets(offsets, prevLength, idx);
        }
    }
    else if (typeof val === STR) {
        impl.setContent(el, "");
    }
};
const diffAdded = (opts, impl, el, edits, ii, equivKeys, offsets, prevLength) => {
    const val = edits[ii + 2];
    if (typeof val === STR) {
        impl.setContent(el, val);
    }
    else if (isArray(val)) {
        const k = val[1].key;
        if (k === undefined || equivKeys[k][0] === undefined) {
            const idx = edits[ii + 1];
            impl.createTree(opts, el, val, offsets[idx]);
            decOffsets(offsets, prevLength, idx);
        }
    }
};
const incOffsets = (offsets, j, idx) => {
    for (; j > idx; j--) {
        offsets[j] = max(offsets[j] - 1, 0);
    }
};
const decOffsets = (offsets, j, idx) => {
    for (; j >= idx; j--) {
        offsets[j]++;
    }
};
const diffAttributes = (impl, el, prev, curr) => {
    const delta = diff.diffObject(prev, curr, 3 , equiv$1.equiv);
    impl.removeAttribs(el, delta.dels, prev);
    let val = api.SEMAPHORE;
    let i, e, edits;
    for (edits = delta.edits, i = edits.length; (i -= 2) >= 0;) {
        e = edits[i];
        e.indexOf("on") === 0 && impl.removeAttribs(el, [e], prev);
        e !== "value"
            ? impl.setAttrib(el, e, edits[i + 1], curr)
            : (val = edits[i + 1]);
    }
    for (edits = delta.adds, i = edits.length; --i >= 0;) {
        e = edits[i];
        e !== "value" ? impl.setAttrib(el, e, curr[e], curr) : (val = curr[e]);
    }
    val !== api.SEMAPHORE && impl.setAttrib(el, "value", val, curr);
};
const releaseTree = (tag) => {
    if (isArray(tag)) {
        let x;
        if ((x = tag[1]) && x.__release === false) {
            return;
        }
        if (tag.__release) {
            tag.__release.apply(tag.__this, tag.__args);
            delete tag.__release;
        }
        for (x = tag.length; --x >= 2;) {
            releaseTree(tag[x]);
        }
    }
};
const extractEquivElements = (edits) => {
    let k;
    let val;
    let ek;
    const equiv = {};
    for (let i = edits.length; (i -= 3) >= 0;) {
        val = edits[i + 2];
        if (isArray(val) && (k = val[1].key) !== undefined) {
            ek = equiv[k];
            !ek && (equiv[k] = ek = [, ,]);
            ek[edits[i] + 1] = edits[i + 1];
        }
    }
    return equiv;
};
const equiv = (a, b) => {
    let proto;
    if (a === b) {
        return true;
    }
    if (a != null) {
        if (typeof a.equiv === FN) {
            return a.equiv(b);
        }
    }
    else {
        return a == b;
    }
    if (b != null) {
        if (typeof b.equiv === FN) {
            return b.equiv(a);
        }
    }
    else {
        return a == b;
    }
    if (typeof a === STR || typeof b === STR) {
        return false;
    }
    if (((proto = Object.getPrototypeOf(a)), proto == null || proto === OBJP) &&
        ((proto = Object.getPrototypeOf(b)), proto == null || proto === OBJP)) {
        return (!(a.__diff === false || b.__diff === false) &&
            equiv$1.equivObject(a, b, equiv));
    }
    if (typeof a !== FN &&
        a.length !== undefined &&
        typeof b !== FN &&
        b.length !== undefined) {
        return equiv$1.equivArrayLike(a, b, equiv);
    }
    if (a instanceof Set && b instanceof Set) {
        return equiv$1.equivSet(a, b, equiv);
    }
    if (a instanceof Map && b instanceof Map) {
        return equiv$1.equivMap(a, b, equiv);
    }
    if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime();
    }
    if (a instanceof RegExp && b instanceof RegExp) {
        return a.toString() === b.toString();
    }
    return a !== a && b !== b;
};

const isArray$1 = checks.isArray;
const isNotStringAndIterable = checks.isNotStringAndIterable;
const maybeInitElement = (el, tree) => tree.__init && tree.__init.apply(tree.__this, [el, ...tree.__args]);
const createTree = (opts, impl, parent, tree, insert, init = true) => {
    if (isArray$1(tree)) {
        const tag = tree[0];
        if (typeof tag === "function") {
            return createTree(opts, impl, parent, tag.apply(null, [opts.ctx, ...tree.slice(1)]), insert);
        }
        const attribs = tree[1];
        if (attribs.__impl) {
            return attribs.__impl.createTree(opts, parent, tree, insert, init);
        }
        const el = impl.createElement(parent, tag, attribs, insert);
        if (tree.length > 2) {
            const n = tree.length;
            for (let i = 2; i < n; i++) {
                createTree(opts, impl, el, tree[i], undefined, init);
            }
        }
        init && maybeInitElement(el, tree);
        return el;
    }
    if (isNotStringAndIterable(tree)) {
        const res = [];
        for (let t of tree) {
            res.push(createTree(opts, impl, parent, t, insert, init));
        }
        return res;
    }
    if (tree == null) {
        return parent;
    }
    return impl.createTextElement(parent, tree);
};
const hydrateTree = (opts, impl, parent, tree, index = 0) => {
    if (isArray$1(tree)) {
        const el = impl.getChild(parent, index);
        if (typeof tree[0] === "function") {
            hydrateTree(opts, impl, parent, tree[0].apply(null, [opts.ctx, ...tree.slice(1)]), index);
        }
        const attribs = tree[1];
        if (attribs.__impl) {
            return attribs.__impl.hydrateTree(opts, parent, tree, index);
        }
        maybeInitElement(el, tree);
        for (let a in attribs) {
            a.indexOf("on") === 0 && impl.setAttrib(el, a, attribs[a]);
        }
        for (let n = tree.length, i = 2; i < n; i++) {
            hydrateTree(opts, impl, el, tree[i], i - 2);
        }
    }
    else if (isNotStringAndIterable(tree)) {
        for (let t of tree) {
            hydrateTree(opts, impl, parent, t, index);
            index++;
        }
    }
};
const createElement = (parent, tag, attribs, insert) => {
    const el = hiccup.SVG_TAGS[tag]
        ? document.createElementNS(hiccup.SVG_NS, tag)
        : document.createElement(tag);
    attribs && setAttribs(el, attribs);
    return addChild(parent, el, insert);
};
const createTextElement = (parent, content, insert) => addChild(parent, document.createTextNode(content), insert);
const addChild = (parent, child, insert) => parent
    ? insert === undefined
        ? parent.appendChild(child)
        : parent.insertBefore(child, parent.children[insert])
    : child;
const getChild = (parent, child) => parent.children[child];
const replaceChild = (opts, impl, parent, child, tree, init = true) => (impl.removeChild(parent, child),
    impl.createTree(opts, parent, tree, child, init));
const cloneWithNewAttribs = (el, attribs) => {
    const res = el.cloneNode(true);
    setAttribs(res, attribs);
    el.parentNode.replaceChild(res, el);
    return res;
};
const setContent = (el, body) => (el.textContent = body);
const setAttribs = (el, attribs) => {
    for (let k in attribs) {
        setAttrib(el, k, attribs[k], attribs);
    }
    return el;
};
const setAttrib = (el, id, val, attribs) => {
    if (id.startsWith("__"))
        return;
    const isListener = id.indexOf("on") === 0;
    if (!isListener && typeof val === "function") {
        val = val(attribs);
    }
    if (val !== undefined && val !== false) {
        switch (id) {
            case "style":
                setStyle(el, val);
                break;
            case "value":
                updateValueAttrib(el, val);
                break;
            case "accesskey":
                el.accessKey = val;
                break;
            case "contenteditable":
                el.contentEditable = val;
                break;
            case "tabindex":
                el.tabIndex = val;
                break;
            case "align":
            case "autocapitalize":
            case "checked":
            case "dir":
            case "draggable":
            case "hidden":
            case "id":
            case "lang":
            case "namespaceURI":
            case "scrollTop":
            case "scrollLeft":
            case "title":
                el[id] = val;
                break;
            default:
                isListener
                    ? setListener(el, id.substr(2), val)
                    : el.setAttribute(id, val === true ? "" : val);
        }
    }
    else {
        el[id] != null ? (el[id] = null) : el.removeAttribute(id);
    }
    return el;
};
const updateValueAttrib = (el, v) => {
    let ev;
    switch (el.type) {
        case "text":
        case "textarea":
        case "password":
        case "search":
        case "number":
        case "email":
        case "url":
        case "tel":
        case "date":
        case "datetime-local":
        case "time":
        case "week":
        case "month":
            if ((ev = el.value) !== undefined && typeof v === "string") {
                const off = v.length - (ev.length - (el.selectionStart || 0));
                el.value = v;
                el.selectionStart = el.selectionEnd = off;
                break;
            }
        default:
            el.value = v;
    }
};
const removeAttribs = (el, attribs, prev) => {
    for (let i = attribs.length; --i >= 0;) {
        const a = attribs[i];
        if (a.indexOf("on") === 0) {
            removeListener(el, a.substr(2), prev[a]);
        }
        else {
            el.hasAttribute(a) ? el.removeAttribute(a) : (el[a] = null);
        }
    }
};
const setStyle = (el, styles) => (el.setAttribute("style", hiccup.css(styles)), el);
const setListener = (el, id, listener) => isArray$1(listener)
    ? el.addEventListener(id, ...listener)
    : el.addEventListener(id, listener);
const removeListener = (el, id, listener) => isArray$1(listener)
    ? el.removeEventListener(id, ...listener)
    : el.removeEventListener(id, listener);
const clearDOM = (el) => (el.innerHTML = "");
const removeChild = (parent, childIdx) => {
    const n = parent.children[childIdx];
    n !== undefined && parent.removeChild(n);
};

const isArray$2 = checks.isArray;
const isNotStringAndIterable$1 = checks.isNotStringAndIterable;
const isPlainObject = checks.isPlainObject;
const normalizeElement = (spec, keys) => {
    let tag = spec[0];
    let hasAttribs = isPlainObject(spec[1]);
    let match;
    let mtag;
    let id;
    let clazz;
    let attribs;
    if (typeof tag !== "string" || !(match = hiccup.RE_TAG.exec(tag))) {
        errors.illegalArgs(`${tag} is not a valid tag name`);
    }
    mtag = match[1];
    if (tag === mtag && hasAttribs && (!keys || spec[1].key)) {
        return spec;
    }
    attribs = hasAttribs ? Object.assign({}, spec[1]) : {};
    id = match[2];
    clazz = match[3];
    if (id) {
        attribs.id = id;
    }
    if (clazz) {
        clazz = clazz.replace(/\./g, " ");
        if (attribs.class) {
            attribs.class += " " + clazz;
        }
        else {
            attribs.class = clazz;
        }
    }
    return attribs.__skip && spec.length < 3
        ? [mtag, attribs]
        : [mtag, attribs, ...spec.slice(hasAttribs ? 2 : 1)];
};
const normalizeTree = (opts, tree) => _normalizeTree(tree, opts, opts.ctx, [0], opts.keys !== false, opts.span !== false);
const _normalizeTree = (tree, opts, ctx, path, keys, span) => {
    if (tree == null) {
        return;
    }
    if (isArray$2(tree)) {
        if (tree.length === 0) {
            return;
        }
        let norm, nattribs = tree[1], impl;
        if (nattribs &&
            (impl = nattribs.__impl) &&
            (impl = impl.normalizeTree)) {
            return impl(opts, tree);
        }
        const tag = tree[0];
        if (typeof tag === "function") {
            return _normalizeTree(tag.apply(null, [ctx, ...tree.slice(1)]), opts, ctx, path, keys, span);
        }
        if (typeof tag.render === "function") {
            const args = [ctx, ...tree.slice(1)];
            norm = _normalizeTree(tag.render.apply(tag, args), opts, ctx, path, keys, span);
            if (isArray$2(norm)) {
                norm.__this = tag;
                norm.__init = tag.init;
                norm.__release = tag.release;
                norm.__args = args;
            }
            return norm;
        }
        norm = normalizeElement(tree, keys);
        nattribs = norm[1];
        if (nattribs.__normalize === false) {
            return norm;
        }
        if (keys && nattribs.key === undefined) {
            nattribs.key = path.join("-");
        }
        if (norm.length > 2) {
            const tag = norm[0];
            const res = [tag, nattribs];
            span = span && !hiccup.NO_SPANS[tag];
            for (let i = 2, j = 2, k = 0, n = norm.length; i < n; i++) {
                let el = norm[i];
                if (el != null) {
                    const isarray = isArray$2(el);
                    if ((isarray && isArray$2(el[0])) ||
                        (!isarray && isNotStringAndIterable$1(el))) {
                        for (let c of el) {
                            c = _normalizeTree(c, opts, ctx, path.concat(k), keys, span);
                            if (c !== undefined) {
                                res[j++] = c;
                            }
                            k++;
                        }
                    }
                    else {
                        el = _normalizeTree(el, opts, ctx, path.concat(k), keys, span);
                        if (el !== undefined) {
                            res[j++] = el;
                        }
                        k++;
                    }
                }
            }
            return res;
        }
        return norm;
    }
    if (typeof tree === "function") {
        return _normalizeTree(tree(ctx), opts, ctx, path, keys, span);
    }
    if (typeof tree.toHiccup === "function") {
        return _normalizeTree(tree.toHiccup(opts.ctx), opts, ctx, path, keys, span);
    }
    if (typeof tree.deref === "function") {
        return _normalizeTree(tree.deref(), opts, ctx, path, keys, span);
    }
    return span
        ? ["span", keys ? { key: path.join("-") } : {}, tree.toString()]
        : tree.toString();
};

const DEFAULT_IMPL = {
    createTree(opts, parent, tree, child, init) {
        return createTree(opts, this, parent, tree, child, init);
    },
    hydrateTree(opts, parent, tree, child) {
        return hydrateTree(opts, this, parent, tree, child);
    },
    diffTree(opts, parent, prev, curr, child) {
        diffTree(opts, this, parent, prev, curr, child);
    },
    normalizeTree,
    getElementById(id) {
        return document.getElementById(id);
    },
    getChild,
    createElement,
    createTextElement,
    replaceChild(opts, parent, child, tree, init) {
        replaceChild(opts, this, parent, child, tree, init);
    },
    removeChild,
    setContent,
    removeAttribs,
    setAttrib
};

const resolveRoot = (root, impl) => checks.isString(root) ? impl.getElementById(root) : root;

const renderOnce = (tree, opts = {}, impl = DEFAULT_IMPL) => {
    opts = Object.assign({ root: "app" }, opts);
    opts.ctx = hiccup.derefContext(opts.ctx, opts.autoDerefKeys);
    const root = resolveRoot(opts.root, impl);
    tree = impl.normalizeTree(opts, tree);
    if (!tree)
        return;
    opts.hydrate
        ? impl.hydrateTree(opts, root, tree)
        : impl.createTree(opts, root, tree);
};

const start = (tree, opts = {}, impl = DEFAULT_IMPL) => {
    const _opts = Object.assign({ root: "app" }, opts);
    let prev = [];
    let isActive = true;
    const root = resolveRoot(_opts.root, impl);
    const update = () => {
        if (isActive) {
            _opts.ctx = hiccup.derefContext(opts.ctx, _opts.autoDerefKeys);
            const curr = impl.normalizeTree(_opts, tree);
            if (curr != null) {
                if (_opts.hydrate) {
                    impl.hydrateTree(_opts, root, curr);
                    _opts.hydrate = false;
                }
                else {
                    impl.diffTree(_opts, root, prev, curr);
                }
                prev = curr;
            }
            isActive && requestAnimationFrame(update);
        }
    };
    requestAnimationFrame(update);
    return () => (isActive = false);
};

exports.DEFAULT_IMPL = DEFAULT_IMPL;
exports.addChild = addChild;
exports.clearDOM = clearDOM;
exports.cloneWithNewAttribs = cloneWithNewAttribs;
exports.createElement = createElement;
exports.createTextElement = createTextElement;
exports.createTree = createTree;
exports.diffAttributes = diffAttributes;
exports.diffTree = diffTree;
exports.equiv = equiv;
exports.getChild = getChild;
exports.hydrateTree = hydrateTree;
exports.normalizeElement = normalizeElement;
exports.normalizeTree = normalizeTree;
exports.releaseTree = releaseTree;
exports.removeAttribs = removeAttribs;
exports.removeChild = removeChild;
exports.removeListener = removeListener;
exports.renderOnce = renderOnce;
exports.replaceChild = replaceChild;
exports.resolveRoot = resolveRoot;
exports.setAttrib = setAttrib;
exports.setAttribs = setAttribs;
exports.setContent = setContent;
exports.setListener = setListener;
exports.setLogger = setLogger;
exports.setStyle = setStyle;
exports.start = start;
exports.updateValueAttrib = updateValueAttrib;
