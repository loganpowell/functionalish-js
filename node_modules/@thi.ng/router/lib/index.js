'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@thi.ng/api');
var checks = require('@thi.ng/checks');
var equiv = require('@thi.ng/equiv');
var errors = require('@thi.ng/errors');

const EVENT_ROUTE_CHANGED = "route-changed";
const EVENT_ROUTE_FAILED = "route-failed";

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
exports.BasicRouter = class BasicRouter {
    constructor(config) {
        config.authenticator =
            config.authenticator ||
                ((route, _, params) => ({
                    id: route.id,
                    title: route.title,
                    params
                }));
        config.prefix = config.prefix === undefined ? "/" : config.prefix;
        config.separator = config.separator || "/";
        this.config = config;
        api.assert(this.routeForID(this.config.defaultRouteID) !== undefined, `missing config for default route: '${this.config.defaultRouteID}'`);
        if (config.initialRouteID) {
            const route = this.routeForID(config.initialRouteID);
            api.assert(route !== undefined, `missing config for initial route: ${this.config.initialRouteID}`);
            api.assert(!isParametricRoute(route), "initial route MUST not be parametric");
        }
    }
    addListener(id, fn, scope) { }
    removeListener(id, fn, scope) { }
    notify(event) { }
    start() {
        if (this.config.initialRouteID) {
            const route = this.routeForID(this.config.initialRouteID);
            this.current = { id: route.id, title: route.title, params: {} };
            this.notify({ id: EVENT_ROUTE_CHANGED, value: this.current });
        }
    }
    route(src) {
        if (src.charAt(0) === "#") {
            src = src.substr(1);
        }
        src = src.substr(this.config.prefix.length);
        const routes = this.config.routes, curr = src.split(this.config.separator);
        let match;
        for (let i = 0, n = routes.length; i < n; i++) {
            const route = routes[i], m = this.matchRoute(curr, route);
            if (m) {
                match = m;
                break;
            }
        }
        if (!match) {
            if (!this.handleRouteFailure()) {
                return;
            }
            const route = this.routeForID(this.config.defaultRouteID);
            match = { id: route.id, title: route.title, params: {} };
        }
        if (!equiv.equiv(match, this.current)) {
            this.current = match;
            this.notify({ id: EVENT_ROUTE_CHANGED, value: match });
        }
        return match;
    }
    format(...args) {
        let [id, params, hash] = args;
        let match;
        switch (args.length) {
            case 3:
                match = { id, params };
                break;
            case 2:
                if (checks.isString(id)) {
                    match = { id, params };
                }
                else {
                    hash = params;
                    match = id;
                }
                break;
            case 1:
                match = checks.isString(id) ? { id } : id;
                break;
            default:
                errors.illegalArity(args.length);
        }
        const route = this.routeForID(match.id);
        if (route) {
            const params = match.params || {};
            return ((hash ? "#" : "") +
                this.config.prefix +
                route.match
                    .map((x) => x.charAt(0) === "?"
                    ? (x = params[x.substr(1)]) != null
                        ? x
                        : "NULL"
                    : x)
                    .join(this.config.separator));
        }
        else {
            errors.illegalArgs(`invalid route ID: ${match.id}`);
        }
    }
    routeForID(id) {
        return this.config.routes.find((route) => route.id === id);
    }
    matchRoute(curr, route) {
        const match = route.match, n = match.length;
        if (curr.length === n) {
            const params = {};
            for (let i = 0; i < n; i++) {
                const m = match[i];
                if (m.charAt(0) === "?") {
                    params[m.substr(1)] = curr[i];
                }
                else if (curr[i] !== m) {
                    return;
                }
            }
            if (route.validate &&
                !this.validateRouteParams(params, route.validate)) {
                return;
            }
            return route.auth
                ? this.config.authenticator(route, curr, params)
                : { id: route.id, title: route.title, params };
        }
    }
    validateRouteParams(params, validators) {
        for (let id in validators) {
            if (params[id] !== undefined) {
                const val = validators[id];
                if (val.coerce) {
                    params[id] = val.coerce(params[id]);
                }
                if (val.check && !val.check(params[id])) {
                    return false;
                }
            }
        }
        return true;
    }
    handleRouteFailure() {
        return true;
    }
};
exports.BasicRouter = __decorate([
    api.INotifyMixin
], exports.BasicRouter);
const isParametricRoute = (route) => route.match.some((p) => p.charAt(0) === "?");

class HTMLRouter extends exports.BasicRouter {
    constructor(config) {
        super(config);
        this.useFragment = config.useFragment !== false;
        this.ignoreHashChange = false;
    }
    start() {
        window.addEventListener("popstate", this.handlePopChange());
        if (this.useFragment) {
            window.addEventListener("hashchange", this.handleHashChange());
        }
        if (this.config.initialRouteID) {
            const route = this.routeForID(this.config.initialRouteID);
            this.route(this.format({
                id: route.id,
                title: route.title
            }));
        }
        else {
            this.route(this.useFragment ? location.hash : location.pathname);
        }
    }
    release() {
        window.removeEventListener("popstate", this.popHandler);
        if (this.useFragment) {
            window.removeEventListener("hashchange", this.hashHandler);
        }
    }
    route(src, pushState = true) {
        const old = this.current;
        const route = super.route(src);
        if (route && !equiv.equiv(route, old)) {
            this.currentPath = this.format(route);
            if (pushState) {
                history.pushState(this.currentPath, route.title || window.document.title || "", this.currentPath);
            }
        }
        return route;
    }
    routeTo(route) {
        if (this.useFragment) {
            location.hash = route;
        }
        this.route(route);
    }
    format(...args) {
        let match;
        switch (args.length) {
            case 2:
                match = { id: args[0], params: args[1] };
                break;
            case 1:
                match = checks.isString(args[0]) ? { id: args[0] } : args[0];
                break;
            default:
                errors.illegalArity(args.length);
        }
        return super.format(match, this.useFragment);
    }
    handlePopChange() {
        return (this.popHandler =
            this.popHandler ||
                ((e) => {
                    this.route(e.state ||
                        (this.useFragment ? location.hash : location.pathname), false);
                }).bind(this));
    }
    handleHashChange() {
        return (this.hashHandler =
            this.hashHandler ||
                ((e) => {
                    if (!this.ignoreHashChange) {
                        const hash = e.newURL.substr(e.newURL.indexOf("#"));
                        if (hash !== this.currentPath) {
                            this.route(hash, false);
                        }
                    }
                }).bind(this));
    }
    handleRouteFailure() {
        this.ignoreHashChange = true;
        location.hash = this.format({
            id: this.routeForID(this.config.defaultRouteID).id
        });
        this.ignoreHashChange = false;
        return true;
    }
}

exports.EVENT_ROUTE_CHANGED = EVENT_ROUTE_CHANGED;
exports.EVENT_ROUTE_FAILED = EVENT_ROUTE_FAILED;
exports.HTMLRouter = HTMLRouter;
