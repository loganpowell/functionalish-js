'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var memoize = require('@thi.ng/memoize');
var errors = require('@thi.ng/errors');

const upper = (x) => x.toUpperCase();
const lower = (x) => x.toLowerCase();
const capitalize = (x) => x[0].toUpperCase() + x.substr(1);
const kebab = (x, delim = "-") => lower(x.replace(
/([a-z0-9\u00e0-\u00fd])([A-Z\u00c0-\u00dd])/g, (_, a, b) => a + delim + b));
const snake = (x) => kebab(x, "_");
const camel = (x, delim = "-") => lower(x).replace(new RegExp(`\\${delim}+(\\w)`, "g"), (_, c) => upper(c));

const repeat = memoize.memoizeJ((ch, n) => ch.repeat(n));

const truncate = memoize.memoizeJ((n, suffix = "") => (x) => x.length > n ? x.substr(0, n - suffix.length) + suffix : x);

const center = memoize.memoizeJ((n, pad = " ") => {
    const buf = repeat(String(pad), n);
    return (x) => {
        if (x == null)
            return buf;
        x = x.toString();
        const r = (n - x.length) / 2;
        return x.length < n
            ? buf.substr(0, r) +
                x +
                buf.substr(0, r + ((n & 1) === (x.length & 1) ? 0 : 1))
            : truncate(n)(x);
    };
});

const padLeft = memoize.memoizeJ((n, ch = " ") => {
    const buf = repeat(String(ch), n);
    return (x) => x != null
        ? ((x = x.toString()), x.length < n ? buf.substr(x.length) + x : x)
        : buf;
});
const Z2 = padLeft(2, "0");
const Z3 = padLeft(3, "0");
const Z4 = padLeft(4, "0");

const float = memoize.memoizeJ((prec) => (x) => nanOrInf(x) || x.toFixed(prec));
const floatFixedWidth = memoize.memoizeJ((width, prec = 3) => {
    const l = width - prec - 1;
    const pl = Math.pow(10, l);
    const pln = -Math.pow(10, l - 1);
    const pr = Math.pow(10, -(prec - 1));
    const pad = padLeft(width);
    return (x) => {
        const ax = Math.abs(x);
        return pad(nanOrInf(x) ||
            (x === 0
                ? "0"
                : ax < pr || ax >= pl
                    ? exp(x, width)
                    : x.toFixed(prec - (x < pln ? 1 : 0))));
    };
});
const exp = (x, w) => x.toExponential(Math.max(w -
    4 -
    (Math.log(Math.abs(x)) / Math.LN10 >= 10 ? 2 : 1) -
    (x < 0 ? 1 : 0), 0));
const nanOrInf = (x) => isNaN(x)
    ? "NaN"
    : x === Infinity
        ? "+∞"
        : x === -Infinity
            ? "-∞"
            : undefined;

const format = (fmt, ...args) => {
    const acc = [];
    for (let i = 0, j = 0, n = fmt.length; i < n; i++) {
        const f = fmt[i];
        const t = typeof f;
        acc.push(t === "function" ? f(args[j++]) : t === "object" ? f[args[j++]] : f);
    }
    return acc.join("");
};
const defFormat = (fmt) => (...args) => format(fmt, ...args);
const ignore = (_) => "";
const str = (x) => String(x);

function* charRange(from, to) {
    let i = typeof from === "string" ? from.charCodeAt(0) : from;
    const end = typeof to === "string" ? to.charCodeAt(0) : to;
    if (i <= end) {
        for (; i <= end; i++) {
            yield String.fromCharCode(i);
        }
    }
    else {
        for (; i >= end; i--) {
            yield String.fromCharCode(i);
        }
    }
}

const defGroup = (...xs) => {
    const acc = {};
    for (let range of xs) {
        for (let c of range) {
            acc[c] = true;
        }
    }
    return Object.freeze(acc);
};
const WS = Object.freeze({
    "\n": true,
    "\r": true,
    "\t": true,
    " ": true
});
const DIGITS = defGroup(charRange("0", "9"));
const HEX = defGroup(charRange("0", "9"), charRange("A", "F"), charRange("a", "f"));
const LOWER = defGroup(charRange("a", "z"));
const UPPER = defGroup(charRange("A", "Z"));
const ALPHA = Object.assign(Object.assign({}, UPPER), LOWER);
const PUNCTUATION = defGroup(charRange("!", "/"), charRange(":", "@"), charRange("[", "`"), charRange("{", "~"));

const hstr = (x) => x != null ? ((x = x.toString()), `${x.length}H${x}`) : "";

const TPL = /\{(\d+)\}/g;
const interpolate = (src, ...args) => args.length > 0
    ? src.replace(TPL, (m) => String(args[parseInt(m[1], 10)]))
    : src;

const padRight = memoize.memoizeJ((n, ch = " ") => {
    const buf = repeat(String(ch), n);
    return (x) => x != null
        ? ((x = x.toString()), x.length < n ? x + buf.substr(x.length) : x)
        : buf;
});

const maybeParseInt = (x, defaultVal = 0, radix = 10) => {
    const n = parseInt(x, radix);
    return isNaN(n) ? defaultVal : n;
};
const maybeParseFloat = (x, defaultVal = 0) => {
    const n = parseFloat(x);
    return isNaN(n) ? defaultVal : n;
};

const percent = (prec = 0) => (x) => (x * 100).toFixed(prec) + "%";

const radix = memoize.memoizeJ((radix, n, prefix = "") => {
    const buf = repeat("0", n);
    return (x) => {
        x = (x >>> 0).toString(radix);
        return prefix + (x.length < n ? buf.substr(x.length) + x : x);
    };
});
const B8 = radix(2, 8);
const B16 = radix(2, 16);
const B32 = radix(2, 32);
const U8 = radix(16, 2);
const U16 = radix(16, 4);
const U24 = radix(16, 6);
const U32 = radix(16, 8);
const U64 = (hi, lo) => U32(hi) + U32(lo);

const src = "àáäâãåèéëêìíïîòóöôùúüûñçßÿœæŕśńṕẃǵǹḿǘẍźḧ·/_,:;";
const dest = "aaaaaaeeeeiiiioooouuuuncsyoarsnpwgnmuxzh------";
const re = new RegExp(src.split("").join("|"), "g");
const slugify = (str) => {
    return str
        .toLowerCase()
        .replace(/\s+/g, "-")
        .replace(re, (c) => dest[src.indexOf(c)])
        .replace(/&+/g, "-and-")
        .replace(/[^\w\-]+/g, "")
        .replace(/\-{2,}/g, "-")
        .replace(/^-+/, "")
        .replace(/-+$/, "");
};

const splice = (src, insert, from, to = from) => {
    if (from < 0) {
        from += src.length;
    }
    if (to < 0) {
        to += src.length;
    }
    if (from > to) {
        errors.illegalArgs("'from' index must be <= 'to'");
    }
    to = Math.max(to, 0);
    return from <= 0
        ? insert + src.substr(to)
        : from >= src.length
            ? src + insert
            : src.substr(0, from) + insert + src.substr(to);
};

const truncateLeft = memoize.memoizeJ((n, prefix = "") => (x) => x.length > n ? prefix + x.substr(x.length - n + prefix.length) : x);

const units = memoize.memoizeJ((exp, base, prec = 2) => {
    const groups = exp
        .map((x) => [
        x[0],
        x[2] != null ? x[2] : prec,
        x[1]
    ])
        .sort((a, b) => a[0] - b[0]);
    return (x) => {
        if (x === 0) {
            return `0${base}`;
        }
        const absX = Math.abs(x);
        for (let i = groups.length; --i >= 0;) {
            const g = groups[i];
            if (absX >= g[0] || i === 0) {
                return (x / g[0]).toFixed(g[1]) + g[2];
            }
        }
        return "";
    };
});
const KB = 1024;
const MB = 1024 * 1024;
const bits = units([[1, " bits", 0], [KB, " Kb"], [MB, " Mb"], [KB * MB, " Gb"]], " bits", 2);
const bytes = units([
    [1, " bytes", 0],
    [KB, " KB"],
    [MB, " MB"],
    [KB * MB, " GB"],
    [MB * MB, " TB"],
    [KB * MB * MB, " PB"]
], " bytes", 2);
const seconds = units([
    [1e-12, " ps"],
    [1e-9, " ns"],
    [1e-6, " µs"],
    [1e-3, " ms"],
    [1, " secs"],
    [60, " mins"],
    [60 * 60, " hours"],
    [24 * 60 * 60, " days"]
], " secs", 3);
const meters = units([
    [1e-12, " pm"],
    [1e-9, " nm"],
    [1e-6, " µm"],
    [1e-3, " mm"],
    [1e-2, " cm"],
    [1, " m"],
    [1e3, " km"]
], " m", 2);
const grams = units([
    [1e-12, " pg"],
    [1e-9, " ng"],
    [1e-6, " µg"],
    [1e-3, " mg"],
    [1, " g"],
    [1e3, " kg"],
    [1e6, " t"],
    [1e9, " kt"],
    [1e12, " Mt"]
], " g", 2);

const uuid = (id, i = 0) => [
    U8(id[i++]),
    U8(id[i++]),
    U8(id[i++]),
    U8(id[i++]),
    "-",
    U8(id[i++]),
    U8(id[i++]),
    "-",
    U8(id[i++]),
    U8(id[i++]),
    "-",
    U8(id[i++]),
    U8(id[i++]),
    "-",
    U8(id[i++]),
    U8(id[i++]),
    U8(id[i++]),
    U8(id[i++]),
    U8(id[i++]),
    U8(id[i++])
].join("");

const wrap = memoize.memoizeJ((pad) => (x) => pad + x + pad);

exports.ALPHA = ALPHA;
exports.B16 = B16;
exports.B32 = B32;
exports.B8 = B8;
exports.DIGITS = DIGITS;
exports.HEX = HEX;
exports.LOWER = LOWER;
exports.PUNCTUATION = PUNCTUATION;
exports.U16 = U16;
exports.U24 = U24;
exports.U32 = U32;
exports.U64 = U64;
exports.U8 = U8;
exports.UPPER = UPPER;
exports.WS = WS;
exports.Z2 = Z2;
exports.Z3 = Z3;
exports.Z4 = Z4;
exports.bits = bits;
exports.bytes = bytes;
exports.camel = camel;
exports.capitalize = capitalize;
exports.center = center;
exports.charRange = charRange;
exports.defFormat = defFormat;
exports.float = float;
exports.floatFixedWidth = floatFixedWidth;
exports.format = format;
exports.grams = grams;
exports.hstr = hstr;
exports.ignore = ignore;
exports.interpolate = interpolate;
exports.kebab = kebab;
exports.lower = lower;
exports.maybeParseFloat = maybeParseFloat;
exports.maybeParseInt = maybeParseInt;
exports.meters = meters;
exports.padLeft = padLeft;
exports.padRight = padRight;
exports.percent = percent;
exports.radix = radix;
exports.repeat = repeat;
exports.seconds = seconds;
exports.slugify = slugify;
exports.snake = snake;
exports.splice = splice;
exports.str = str;
exports.truncate = truncate;
exports.truncateLeft = truncateLeft;
exports.units = units;
exports.upper = upper;
exports.uuid = uuid;
exports.wrap = wrap;
