import { isArray } from "@thi.ng/checks";
import { identity } from "@thi.ng/compose";
import { illegalState } from "@thi.ng/errors";
import { $iter, iterator } from "../iterator";
import { isReduced } from "../reduced";
export function partitionSync(...args) {
    return ($iter(partitionSync, args, iterator) ||
        (([init, complete, reduce]) => {
            let curr = {};
            let first = true;
            const currKeys = new Set();
            const { key, mergeOnly, reset, all, backPressure } = Object.assign({ key: identity, mergeOnly: false, reset: true, all: true, backPressure: 0 }, args[1]);
            const ks = isArray(args[0])
                ? new Set(args[0])
                : args[0];
            if (mergeOnly || backPressure < 1) {
                return [
                    init,
                    (acc) => {
                        if ((reset && all && currKeys.size > 0) ||
                            (!reset && first)) {
                            acc = reduce(acc, curr);
                            curr = {};
                            currKeys.clear();
                            first = false;
                        }
                        return complete(acc);
                    },
                    (acc, x) => {
                        const k = key(x);
                        if (ks.has(k)) {
                            curr[k] = x;
                            currKeys.add(k);
                            if (mergeOnly || requiredInputs(ks, currKeys)) {
                                acc = reduce(acc, curr);
                                first = false;
                                if (reset) {
                                    curr = {};
                                    currKeys.clear();
                                }
                                else {
                                    curr = Object.assign({}, curr);
                                }
                            }
                        }
                        return acc;
                    }
                ];
            }
            else {
                // with backpressure / caching...
                const cache = new Map();
                return [
                    init,
                    (acc) => {
                        if (all && currKeys.size > 0) {
                            acc = reduce(acc, collect(cache, currKeys));
                            currKeys.clear();
                        }
                        return complete(acc);
                    },
                    (acc, x) => {
                        const k = key(x);
                        if (ks.has(k)) {
                            let slot = cache.get(k);
                            !slot && cache.set(k, (slot = []));
                            slot.length >= backPressure &&
                                illegalState(`max back pressure (${backPressure}) exceeded for input: ${String(k)}`);
                            slot.push(x);
                            currKeys.add(k);
                            while (requiredInputs(ks, currKeys)) {
                                acc = reduce(acc, collect(cache, currKeys));
                                first = false;
                                if (isReduced(acc))
                                    break;
                            }
                        }
                        return acc;
                    }
                ];
            }
        }));
}
const requiredInputs = (required, curr) => {
    if (curr.size < required.size)
        return false;
    for (let id of required) {
        if (!curr.has(id))
            return false;
    }
    return true;
};
const collect = (cache, currKeys) => {
    const curr = {};
    for (let id of currKeys) {
        const slot = cache.get(id);
        curr[id] = slot.shift();
        !slot.length && currKeys.delete(id);
    }
    return curr;
};
