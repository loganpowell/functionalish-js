/**
 * Clamps value `x` to given closed interval.
 *
 * @param x - value to clamp
 * @param min - lower bound
 * @param max - upper bound
 */
export declare const clamp: (x: number, min: number, max: number) => number;
/**
 * Clamps value `x` to closed [0 .. 1] interval.
 *
 * @param x
 */
export declare const clamp01: (x: number) => number;
/**
 * Clamps value `x` to closed [-1 .. 1] interval.
 *
 * @param x
 */
export declare const clamp11: (x: number) => number;
/**
 * Clamps value `x` to closed [0 .. 0.5] interval.
 *
 * @param x
 */
export declare const clamp05: (x: number) => number;
/**
 * Folds `x` back inside closed [min..max] interval. Also see
 * {@link wrapOnce}.
 *
 * @param x -
 * @param min -
 * @param max -
 */
export declare const wrap: (x: number, min: number, max: number) => number;
/**
 * Like {@link wrap}, but optimized for cases where `x` is guaranteed to
 * be in `[min - d, max + d]` interval, where `d = max - min`. Result
 * will be in closed `[min..max]` interval.
 *
 * @param x -
 * @param min -
 * @param max -
 */
export declare const wrapOnce: (x: number, min: number, max: number) => number;
/**
 * Similar to {@link wrapOnce} for [0..1] interval.
 *
 * @param x -
 */
export declare const wrap01: (x: number) => number;
/**
 * Similar to {@link wrapOnce} for [-1..1] interval.
 *
 * @param x -
 */
export declare const wrap11: (x: number) => number;
export declare const min2id: (a: number, b: number) => 1 | 0;
export declare const min3id: (a: number, b: number, c: number) => 1 | 2 | 0;
export declare const min4id: (a: number, b: number, c: number, d: number) => 1 | 2 | 3 | 0;
export declare const max2id: (a: number, b: number) => 1 | 0;
export declare const max3id: (a: number, b: number, c: number) => 1 | 2 | 0;
export declare const max4id: (a: number, b: number, c: number, d: number) => 1 | 2 | 3 | 0;
/**
 * Returns the non-zero minimum value of the given `a`, `b` args.
 *
 * @param a
 * @param b
 */
export declare const minNonZero2: (a: number, b: number) => number;
/**
 * Returns the non-zero minimum value of the given `a`, `b`, `c` args.
 *
 * @param a
 * @param b
 * @param c
 */
export declare const minNonZero3: (a: number, b: number, c: number) => number;
/**
 * See `smax()`.
 *
 * @param a -
 * @param b -
 * @param k - smooth exponent (MUST be > 0)
 */
export declare const smin: (a: number, b: number, k: number) => number;
/**
 * Smooth maximum. Note: Result values will be slightly larger than max
 * value near max(a,b) + eps due to exponential decay. Higher `k` values
 * reduce the error, but also reduce the smoothing. Recommended k=16.
 *
 * {@link https://en.wikipedia.org/wiki/Smooth_maximum}
 *
 * @param a -
 * @param b -
 * @param k - smooth exponent (MUST be > 0)
 */
export declare const smax: (a: number, b: number, k: number) => number;
/**
 * Same as `smin(smax(x, min, k), max, k)`.
 *
 * @param x -
 * @param min -
 * @param max -
 * @param k -
 */
export declare const sclamp: (x: number, min: number, max: number, k: number) => number;
export declare const absMin: (a: number, b: number) => number;
export declare const absMax: (a: number, b: number) => number;
/**
 * If `abs(x) > abs(e)`, recursively mirrors `x` back into `[-e .. +e]`
 * interval at respective positive/negative boundary.
 *
 * @remarks
 * References:
 * - https://www.desmos.com/calculator/lkyf2ag3ta
 * - https://www.musicdsp.org/en/latest/Effects/203-fold-back-distortion.html
 *
 * @param e - threshold (> 0)
 * @param x - input value
 */
export declare const foldback: (e: number, x: number) => number;
/**
 * Returns true iff `x` is in closed interval `[min .. max]`
 *
 * @param x -
 * @param min -
 * @param max -
 */
export declare const inRange: (x: number, min: number, max: number) => boolean;
/**
 * Returns true iff `x` is in open interval `(min .. max)`
 *
 * @param x -
 * @param min -
 * @param max -
 */
export declare const inOpenRange: (x: number, min: number, max: number) => boolean;
//# sourceMappingURL=interval.d.ts.map