export declare const mix: (a: number, b: number, t: number) => number;
/**
 * @example
 * ```ts
 * c    d
 * +----+
 * |    |
 * +----+
 * a    b
 * ```
 *
 * @param a - BL value
 * @param b - BR value
 * @param c - TL value
 * @param d - TR value
 * @param u - 1st interpolation factor
 * @param v - 2nd interpolation factor
 */
export declare const mixBilinear: (a: number, b: number, c: number, d: number, u: number, v: number) => number;
export declare const mixQuadratic: (a: number, b: number, c: number, t: number) => number;
export declare const mixCubic: (a: number, b: number, c: number, d: number, t: number) => number;
/**
 * Returns hermite interpolation of `a, b, c, d` at normalized position
 * `t`, where `a` and `d` are used as predecessor/successor of `b` / `c`
 * and only inform the tangent of the interpolation curve. The
 * interpolated result is that of `b` and `c`.
 *
 * Assumes all inputs are uniformly spaced. If that's not the case, use
 * {@link mixCubicHermite} with one of the tangent generators supporting
 * non-uniform spacing of points.
 *
 * See: {@link https://www.desmos.com/calculator/j4gf8g9vkr}
 *
 * Source:
 * {@link https://www.musicdsp.org/en/latest/Other/93-hermite-interpollation.html}
 *
 * - {@link mixCubicHermite}
 * - {@link tangentCardinal}
 * - {@link tangentDiff3}
 *
 * @param a -
 * @param b -
 * @param c -
 * @param d -
 * @param t -
 */
export declare const mixHermite: (a: number, b: number, c: number, d: number, t: number) => number;
/**
 * Computes cubic-hermite interpolation between `a` / `b` at normalized
 * time `t` and using respective tangents `ta` / `tb`.
 *
 * {@link https://en.wikipedia.org/wiki/Cubic_Hermite_spline}
 *
 * - {@link mixHermite}
 * - {@link tangentCardinal}
 * - {@link tangentDiff3}
 *
 * @param a -
 * @param ta -
 * @param b -
 * @param tb -
 * @param t -
 */
export declare const mixCubicHermite: (a: number, ta: number, b: number, tb: number, t: number) => number;
/**
 * Helper function for {@link mixCubicHermite}. Computes cardinal tangents
 * based on point neighbors of a point B (not given), i.e. `a`
 * (predecessor) and `c` (successor) and their times (defaults to
 * uniformly spaced). The optional `tension` parameter can be used to
 * scale the tangent where 0.0 produces a Cardinal spline tangent and
 * 1.0 a Catmull-Rom (opposite to the Wikipedia ref).
 *
 * {@link https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Cardinal_spline}
 *
 * @param prev -
 * @param next -
 * @param scale -
 * @param ta -
 * @param tc -
 */
export declare const tangentCardinal: (prev: number, next: number, scale?: number, ta?: number, tc?: number) => number;
/**
 * Helper function for {@link mixCubicHermite}. Computes tangent for `curr`,
 * based on 3-point finite difference, where `prev` & `next` are
 * `curr`'s neighbors and the `tX` the three points' respective time
 * values. The latter are equally spaced by default (each 1.0 apart).
 *
 * Using this function with equal spacing of 1.0 and together with
 * {@link mixCubicHermite} will produce same results as the somewhat
 * optimized variant {@link mixHermite}.
 *
 * {@link https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Finite_difference}
 *
 * @param prev -
 * @param curr -
 * @param next -
 * @param ta -
 * @param tb -
 * @param tc -
 */
export declare const tangentDiff3: (prev: number, curr: number, next: number, ta?: number, tb?: number, tc?: number) => number;
/**
 * HOF interpolator. Takes a timing function `f` and interval `[from,
 * to]`. Returns function which takes normalized time as single arg and
 * returns interpolated value.
 *
 * @param f -
 * @param from -
 * @param to -
 */
export declare const tween: (f: (t: number) => number, from: number, to: number) => (t: number) => number;
/**
 * Circular interpolation: `sqrt(1 - (1 - t)^2)`
 *
 * @param t - interpolation factor (0.0 .. 1.0)
 */
export declare const circular: (t: number) => number;
export declare const cosine: (t: number) => number;
export declare const decimated: (n: number, t: number) => number;
export declare const bounce: (k: number, amp: number, t: number) => number;
/**
 * HOF exponential easing.
 *
 * - `ease = 1` -> linear
 * - `ease > 1` -> ease in
 * - `ease < 1` -> ease out
 *
 * @param ease - easing behavior [0.0 .. âˆž]
 * @param t -
 */
export declare const ease: (ease: number, t: number) => number;
/**
 * HOF impulse generator. Peaks at `t=1/k`
 *
 * @param k - impulse width (higher values => shorter impulse)
 */
export declare const impulse: (k: number, t: number) => number;
export declare const gain: (k: number, t: number) => number;
export declare const parabola: (k: number, t: number) => number;
export declare const cubicPulse: (w: number, c: number, t: number) => number;
export declare const sinc: (k: number, t: number) => number;
/**
 * Sigmoid function for inputs in [0..1] interval.
 *
 * @param k -
 * @param t -
 */
export declare const sigmoid: (k: number, t: number) => number;
/**
 * Sigmoid function for inputs in [-1..+1] interval.
 *
 * @param k -
 * @param t -
 */
export declare const sigmoid11: (k: number, t: number) => number;
/**
 * Computes exponential factor to interpolate from `a` to `b` over
 * `num` steps. I.e. multiplying `a` with the returned factor will yield
 * `b` after `num` steps. All args must be > 0.
 *
 * @param a
 * @param b
 * @param num
 */
export declare const expFactor: (a: number, b: number, num: number) => number;
//# sourceMappingURL=mix.d.ts.map