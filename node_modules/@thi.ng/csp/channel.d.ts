import { DCons } from "@thi.ng/dcons";
import { Reducer, Transducer } from "@thi.ng/transducers";
import { State } from "./constants";
import type { Fn, Fn0, Fn2, FnAny, Predicate } from "@thi.ng/api";
import type { ChannelItem, ErrorHandler, IBuffer, IReadWriteableChannel } from "./api";
export declare class Channel<T> implements IReadWriteableChannel<T> {
    static constantly<T>(x: T, delay?: number): Channel<T>;
    static repeatedly<T>(fn: Fn0<T>, delay?: number): Channel<T>;
    static cycle<T>(src: Iterable<T>, delay?: number): Channel<unknown>;
    static range(): Channel<number>;
    static range(to: number): Channel<number>;
    static range(from: number, to: number): Channel<number>;
    static range(from: number, to: number, step: number): Channel<number>;
    static range(from: number, to: number, step: number, delay: number): Channel<number>;
    /**
     * Constructs new channel which closes automatically after given period.
     *
     * @param delay - time in ms
     */
    static timeout(delay: number): Channel<any>;
    /**
     * Shorthand for: `Channel.timeout(delay).take()`
     *
     * @param delay - time in ms
     */
    static sleep(delay: number): Promise<any>;
    /**
     * Creates new channel with single value from given promise, then closes
     * automatically iff promise has been resolved.
     *
     * @param p - promise
     */
    static fromPromise<T>(p: Promise<T>): Channel<T>;
    static from<T>(src: Iterable<any>): Channel<T>;
    static from<T>(src: Iterable<any>, close: boolean): Channel<T>;
    static from<T>(src: Iterable<any>, tx: Transducer<any, T>): Channel<T>;
    static from<T>(src: Iterable<any>, tx: Transducer<any, T>, close: boolean): Channel<T>;
    /**
     * Takes an array of channels and blocks until any of them becomes
     * readable (or has been closed). The returned promised resolves into
     * an array of `[value, channel]`. Channel order is repeatedly
     * shuffled for each read attempt.
     *
     * @param chans - source channels
     */
    static select(chans: Channel<any>[]): Promise<any>;
    /**
     * Takes an array of channels to merge into new channel. Any closed
     * channels will be automatically removed from the input selection.
     * Once all inputs are closed, the target channel will close too (by
     * default).
     *
     * @remarks
     * If `named` is true, the merged channel will have tuples of:
     * `[src-id, val]` If false (default), only received values will be
     * forwarded.
     *
     * @param chans - source channels
     * @param out - result channel
     * @param close - true, if result closes
     * @param named - true, to emit labeled tuples
     */
    static merge(chans: Channel<any>[], out?: Channel<any>, close?: boolean, named?: boolean): Channel<any>;
    /**
     * Takes an array of channels to merge into new channel of tuples.
     * Whereas `Channel.merge()` realizes a sequential merging with no
     * guarantees about ordering of the output.
     *
     * @remarks
     * The output channel of this function will collect values from all
     * channels and a new tuple is emitted only once a new value has
     * been read from ALL channels. Therefore the overall throughput is
     * dictated by the slowest of the inputs.
     *
     * Once any of the inputs closes, the process is terminated and the
     * output channel is closed too (by default).
     *
     * @example
     * ```ts
     * Channel.mergeTuples([
     *   Channel.from([1, 2, 3]),
     *   Channel.from([10, 20, 30]),
     *   Channel.from([100, 200, 300])
     * ]).consume();
     *
     * // chan-0 : [ 1, 10, 100 ]
     * // chan-0 : [ 2, 20, 200 ]
     * // chan-0 : [ 3, 30, 300 ]
     * // chan-0 done
     *
     * Channel.mergeTuples([
     *   Channel.from([1, 2, 3]),
     *   Channel.from([10, 20, 30]),
     *   Channel.from([100, 200, 300])
     * ], null, false).consume();
     * ```
     *
     * @param chans - source channels
     * @param out - result channel
     * @param closeOnFirst - true, if result closes when first input is done
     * @param closeOutput - true, if result closes when all inputs are done
     */
    static mergeTuples(chans: Channel<any>[], out?: Channel<any>, closeOnFirst?: boolean, closeOutput?: boolean): Channel<any>;
    static MAX_WRITES: number;
    static NEXT_ID: number;
    static SCHEDULE: Fn2<FnAny<void>, number, void>;
    private static RFN;
    id: string;
    onerror: ErrorHandler;
    protected state: State;
    protected buf: IBuffer<T>;
    protected tx: Reducer<DCons<T>, T>;
    protected writes: DCons<ChannelItem<T>>;
    protected reads: DCons<(x: T) => void>;
    protected txbuf: DCons<T>;
    protected isBusy: boolean;
    constructor();
    constructor(id: string);
    constructor(buf: number | IBuffer<T>);
    constructor(tx: Transducer<any, T>);
    constructor(tx: Transducer<any, T>, err: ErrorHandler);
    constructor(id: string, buf: number | IBuffer<T>);
    constructor(id: string, tx: Transducer<any, T>);
    constructor(id: string, tx: Transducer<any, T>, err: ErrorHandler);
    constructor(id: string, buf: number | IBuffer<T>, tx: Transducer<any, T>);
    constructor(id: string, buf: number | IBuffer<T>, tx: Transducer<any, T>, err: ErrorHandler);
    channel(): this;
    write(value: any): Promise<boolean>;
    read(): Promise<T>;
    tryRead(timeout?: number): Promise<unknown>;
    close(flush?: boolean): Promise<void> | undefined;
    isClosed(): boolean;
    isReadable(): boolean;
    consume(fn?: Fn<T, any>): Promise<void>;
    produce(fn: Fn0<T>, close?: boolean): Promise<void>;
    consumeWhileReadable(fn?: Fn<T, any>): Promise<void>;
    reduce<A>(rfn: Reducer<A, T>, acc?: A): Promise<A>;
    transduce<A, B>(tx: Transducer<T, B>, rfn: Reducer<A, B>, acc?: A): Promise<A>;
    into(src: Iterable<T>, close?: boolean): Promise<void>;
    pipe<R>(dest: Channel<R> | Transducer<T, R>, close?: boolean): Channel<R>;
    split<A, B>(pred: Predicate<T>, truthy?: Channel<A>, falsey?: Channel<B>, close?: boolean): (Channel<A> | Channel<B>)[];
    concat(chans: Iterable<Channel<T>>, close?: boolean): Promise<void>;
    release(): void;
    protected process(): Promise<void>;
    protected flush(): void;
}
//# sourceMappingURL=channel.d.ts.map