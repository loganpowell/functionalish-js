var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { illegalArity } from "@thi.ng/errors";
import { Channel } from "./channel";
import { Mult } from "./mult";
export class PubSub {
    constructor(...args) {
        switch (args.length) {
            case 2:
                this.src = args[0];
                this.fn = args[1];
                break;
            case 1:
                this.src = new Channel("pubsub" + PubSub.NEXT_ID++);
                this.fn = args[0];
                break;
            default:
                illegalArity(args.length);
        }
        this.topics = {};
        this.process();
    }
    get id() {
        return this.src && this.src.id;
    }
    set id(id) {
        this.src && (this.src.id = id);
    }
    channel() {
        return this.src;
    }
    write(val) {
        if (this.src) {
            return this.src.write(val);
        }
        return Promise.resolve(false);
    }
    close(flush = false) {
        return this.src ? this.src.close(flush) : undefined;
    }
    /**
     * Creates a new topic subscription channel and returns it.
     * Each topic is managed by its own {@link Mult} and can have arbitrary
     * number of subscribers. If the optional transducer is given, it will
     * only be applied to the new subscription channel.
     *
     * The special "*" topic can be used to subscribe to all messages and
     * acts as multiplexed pass-through of the source channel.
     *
     * @param id - topic id
     * @param tx - transducer for new subscription
     */
    sub(id, tx) {
        let topic = this.topics[id];
        if (!topic) {
            this.topics[id] = topic = new Mult(this.src.id + "-" + id);
        }
        return topic.tap(tx);
    }
    unsub(id, ch) {
        let topic = this.topics[id];
        if (topic) {
            return topic.untap(ch);
        }
        return false;
    }
    unsubAll(id, close = true) {
        let topic = this.topics[id];
        if (topic) {
            return topic.untapAll(close);
        }
        return false;
    }
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            let x;
            while (((x = null), (x = yield this.src.read())) !== undefined) {
                const id = yield this.fn(x);
                let topic = this.topics[id];
                topic && (yield topic.write(x));
                topic = this.topics["*"];
                topic && (yield topic.write(x));
            }
            for (let id of Object.keys(this.topics)) {
                this.topics[id].close();
            }
            delete this.src;
            delete this.topics;
            delete this.fn;
        });
    }
}
PubSub.NEXT_ID = 0;
