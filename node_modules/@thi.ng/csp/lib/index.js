'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dcons = require('@thi.ng/dcons');
var arrays = require('@thi.ng/arrays');
var checks = require('@thi.ng/checks');
var errors = require('@thi.ng/errors');
var transducers = require('@thi.ng/transducers');

(function (State) {
    State[State["OPEN"] = 0] = "OPEN";
    State[State["CLOSED"] = 1] = "CLOSED";
    State[State["DONE"] = 2] = "DONE";
})(exports.State || (exports.State = {}));

class FixedBuffer {
    constructor(limit = 1) {
        this.buf = new dcons.DCons();
        this.limit = limit;
    }
    get length() {
        return this.buf.length;
    }
    isEmpty() {
        return this.buf.length === 0;
    }
    isFull() {
        return this.buf.length >= this.limit;
    }
    release() {
        return this.buf.release();
    }
    push(x) {
        if (!this.isFull()) {
            this.buf.push(x);
            return true;
        }
        return false;
    }
    drop() {
        if (!this.isEmpty()) {
            return this.buf.drop();
        }
    }
}
class DroppingBuffer extends FixedBuffer {
    constructor(limit = 1) {
        super(limit);
    }
    isFull() {
        return false;
    }
    push(x) {
        if (this.buf.length < this.limit) {
            this.buf.push(x);
        }
        return true;
    }
}
class SlidingBuffer extends FixedBuffer {
    constructor(limit = 1) {
        super(limit);
    }
    isFull() {
        return false;
    }
    push(x) {
        if (this.buf.length >= this.limit) {
            this.buf.drop();
        }
        this.buf.push(x);
        return true;
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Channel {
    constructor(...args) {
        let id, buf, tx, err;
        let [a, b] = args;
        switch (args.length) {
            case 0:
                break;
            case 1:
                if (typeof a === "string") {
                    id = a;
                }
                else if (maybeBuffer(a)) {
                    buf = a;
                }
                else {
                    tx = a;
                }
                break;
            case 2:
                if (typeof a === "string") {
                    id = a;
                    if (maybeBuffer(b)) {
                        buf = b;
                    }
                    else {
                        tx = b;
                    }
                }
                else {
                    [tx, err] = args;
                }
                break;
            case 3:
                if (checks.isFunction(args[1]) && checks.isFunction(args[2])) {
                    [id, tx, err] = args;
                }
                else {
                    [id, buf, tx] = args;
                }
                break;
            case 4:
                [id, buf, tx, err] = args;
                break;
            default:
                errors.illegalArity(args.length);
        }
        this.id = id || `chan-${Channel.NEXT_ID++}`;
        buf = buf || 1;
        this.buf = typeof buf === "number" ? new FixedBuffer(buf) : buf;
        this.writes = new dcons.DCons();
        this.reads = new dcons.DCons();
        this.txbuf = new dcons.DCons();
        this.tx = tx ? tx(Channel.RFN) : null;
        this.onerror = tx && (err || defaultErrorHandler);
        this.state = 0 ;
        this.isBusy = false;
    }
    static constantly(x, delay) {
        const chan = new Channel(delay ? transducers.delayed(delay) : null);
        chan.produce(() => x);
        return chan;
    }
    static repeatedly(fn, delay) {
        const chan = new Channel(delay ? transducers.delayed(delay) : null);
        chan.produce(fn);
        return chan;
    }
    static cycle(src, delay) {
        return Channel.from(transducers.cycle(src), delay ? transducers.delayed(delay) : null);
    }
    static range(...args) {
        const [from, to, step, delay] = args;
        return Channel.from(transducers.range(from, to, step), delay !== undefined ? transducers.delayed(delay) : null);
    }
    static timeout(delay) {
        const chan = new Channel(`timeout-${Channel.NEXT_ID++}`);
        setTimeout(() => chan.close(), delay);
        return chan;
    }
    static sleep(delay) {
        return Channel.timeout(delay).read();
    }
    static fromPromise(p) {
        const chan = new Channel();
        p.then((x) => (() => __awaiter(this, void 0, void 0, function* () {
            yield chan.write(x);
            yield chan.close();
            return x;
        }))());
        return chan;
    }
    static from(...args) {
        let close, tx;
        switch (args.length) {
            case 1:
                break;
            case 2:
                if (typeof args[1] === "boolean") {
                    close = args[1];
                }
                else {
                    tx = args[1];
                }
                break;
            case 3:
                tx = args[1];
                close = args[2];
                break;
            default:
                errors.illegalArity(args.length);
        }
        const chan = new Channel(tx);
        chan.into(args[0], close);
        return chan;
    }
    static select(chans) {
        return new Promise((resolve) => {
            const _select = () => {
                for (let c of arrays.shuffle(chans)) {
                    if (c.isReadable() || c.isClosed()) {
                        c.read().then((x) => resolve([x, c]));
                        return;
                    }
                }
                Channel.SCHEDULE.call(null, _select, 0);
            };
            Channel.SCHEDULE.call(null, _select, 0);
        });
    }
    static merge(chans, out, close = true, named = false) {
        out = out || new Channel();
        (() => __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let [x, ch] = yield Channel.select(chans);
                if (x === undefined) {
                    chans.splice(chans.indexOf(ch), 1);
                    if (!chans.length) {
                        close && (yield out.close());
                        break;
                    }
                }
                else {
                    yield out.write(named ? [ch.id, x] : x);
                }
            }
        }))();
        return out;
    }
    static mergeTuples(chans, out, closeOnFirst = true, closeOutput = true) {
        out = out || new Channel();
        (() => __awaiter(this, void 0, void 0, function* () {
            let buf = [];
            let orig = [...chans];
            let sel = new Set(chans);
            let n = chans.length;
            while (true) {
                let [x, ch] = yield Channel.select([...sel]);
                let idx = orig.indexOf(ch);
                if (x === undefined) {
                    if (closeOnFirst || chans.length === 1) {
                        break;
                    }
                    chans.splice(idx, 1);
                }
                buf[idx] = x;
                sel.delete(ch);
                if (--n === 0) {
                    yield out.write(buf);
                    buf = [];
                    n = chans.length;
                    sel = new Set(chans);
                }
            }
            closeOutput && (yield out.close());
        }))();
        return out;
    }
    channel() {
        return this;
    }
    write(value) {
        return new Promise((resolve) => {
            if (this.state !== 0 ) {
                resolve(false);
            }
            if (this.writes.length < Channel.MAX_WRITES) {
                this.writes.push({
                    value: this.tx
                        ? () => __awaiter(this, void 0, void 0, function* () {
                            try {
                                if (transducers.isReduced(this.tx[2](this.txbuf, value))) {
                                    this.state = 1 ;
                                }
                            }
                            catch (e) {
                                this.onerror(e, this, value);
                            }
                        })
                        : () => value,
                    resolve
                });
                this.process();
            }
            else {
                throw new Error(`channel stalled (${Channel.MAX_WRITES} unprocessed writes)`);
            }
        });
    }
    read() {
        return new Promise((resolve) => {
            if (this.state === 2 ) {
                resolve();
            }
            this.reads.push(resolve);
            this.process();
        });
    }
    tryRead(timeout = 1000) {
        return new Promise((resolve) => {
            (() => __awaiter(this, void 0, void 0, function* () {
                return resolve((yield Channel.select([this, Channel.timeout(timeout)]))[0]);
            }))();
        });
    }
    close(flush = false) {
        if (this.state === 0 ) {
            this.state = 1 ;
            flush && this.flush();
            return this.process();
        }
    }
    isClosed() {
        return this.state !== 0 ;
    }
    isReadable() {
        return ((this.state !== 2  && this.buf && this.buf.length > 0) ||
            (this.writes && this.writes.length > 0) ||
            (this.txbuf && this.txbuf.length > 0));
    }
    consume(fn = (x) => console.log(this.id, ":", x)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            let x;
            while (((x = null), (x = yield this.read())) !== undefined) {
                yield fn(x);
            }
        }))();
    }
    produce(fn, close = true) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            while (!this.isClosed()) {
                const val = yield fn();
                if (val === undefined) {
                    close && (yield this.close());
                    break;
                }
                yield this.write(val);
            }
        }))();
    }
    consumeWhileReadable(fn = (x) => console.log(this.id, ":", x)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            let x;
            while (this.isReadable()) {
                x = yield this.read();
                if (x === undefined) {
                    break;
                }
                yield fn(x);
                x = null;
            }
        }))();
    }
    reduce(rfn, acc) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const [init, complete, reduce] = rfn;
            acc = acc != null ? acc : init();
            let x;
            while (((x = null), (x = yield this.read())) !== undefined) {
                acc = reduce(acc, x);
                if (transducers.isReduced(acc)) {
                    acc = acc.deref();
                    break;
                }
            }
            return transducers.unreduced(complete(acc));
        }))();
    }
    transduce(tx, rfn, acc) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const _rfn = tx(rfn);
            return transducers.unreduced(_rfn[1](yield this.reduce(_rfn, acc)));
        }))();
    }
    into(src, close = true) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            for (let x of src) {
                if (this.isClosed()) {
                    break;
                }
                yield this.write(x);
            }
            close && (yield this.close());
        }))();
    }
    pipe(dest, close = true) {
        if (!(dest instanceof Channel)) {
            dest = new Channel(dest);
        }
        this.consume((x) => dest.write(x))
            .then(() => {
            close && dest.close();
        });
        return dest;
    }
    split(pred, truthy, falsey, close = true) {
        if (!(truthy instanceof Channel)) {
            truthy = new Channel();
        }
        if (!(falsey instanceof Channel)) {
            falsey = new Channel();
        }
        this.consume((x) => (pred(x) ? truthy : falsey).write(x)).then(() => {
            close && (truthy.close(), falsey.close());
        });
        return [truthy, falsey];
    }
    concat(chans, close = true) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            for (let c of chans) {
                yield c.consume((x) => this.write(x));
            }
            close && (yield this.close());
        }))();
    }
    release() {
        if (this.state === 1 ) {
            this.state = 2 ;
            this.flush();
            this.buf.release();
            delete this.reads;
            delete this.writes;
            delete this.buf;
            delete this.txbuf;
            delete this.tx;
            delete this.isBusy;
            delete this.onerror;
        }
    }
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isBusy) {
                this.isBusy = true;
                const reads = this.reads;
                const writes = this.writes;
                const buf = this.buf;
                const txbuf = this.txbuf;
                let doProcess = true;
                while (doProcess) {
                    while (reads.length && (txbuf.length || buf.length)) {
                        if (txbuf.length) {
                            const val = txbuf.drop();
                            if (val !== undefined) {
                                reads.drop()(val);
                            }
                        }
                        else {
                            const val = yield buf.drop().value();
                            if (val !== undefined) {
                                reads.drop()(val);
                            }
                        }
                    }
                    while (writes.length && !buf.isFull()) {
                        const put = writes.drop();
                        buf.push(put);
                        put.resolve(true);
                    }
                    if (this.state === 1 ) {
                        if (this.tx && !writes.length) {
                            try {
                                this.tx[1](this.txbuf);
                            }
                            catch (e) {
                                this.onerror(e, this);
                            }
                        }
                        if (!this.isReadable()) {
                            this.release();
                            return;
                        }
                    }
                    doProcess =
                        (reads.length && (txbuf.length || buf.length)) ||
                            (writes.length && !buf.isFull());
                }
                this.isBusy = false;
            }
        });
    }
    flush() {
        let op;
        while ((op = this.reads.drop())) {
            op();
        }
        while ((op = this.writes.drop())) {
            op.resolve(false);
        }
        this.buf.release();
    }
}
Channel.MAX_WRITES = 1024;
Channel.NEXT_ID = 0;
Channel.SCHEDULE = typeof setImmediate === "function" ? setImmediate : setTimeout;
Channel.RFN = [
    (() => null),
    (acc) => acc,
    (acc, x) => acc.push(x)
];
const defaultErrorHandler = (e, chan, val) => console.log(chan.id, "error occurred", e.message, val !== undefined ? val : "");
const maybeBuffer = (x) => x instanceof FixedBuffer || typeof x === "number";

var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Mult {
    constructor(...args) {
        this.tapID = 0;
        let id, src;
        switch (args.length) {
            case 2:
                id = args[0];
                src = args[1];
                break;
            case 1:
                if (typeof args[0] === "string") {
                    id = args[0];
                }
                else {
                    src = args[0];
                }
                break;
            case 0:
                id = "mult" + Mult.nextID++;
                break;
            default:
                errors.illegalArity(args.length);
        }
        if (src instanceof Channel) {
            this.src = src;
        }
        else {
            this.src = new Channel(id, src);
        }
        this.taps = new dcons.DCons();
        this.process();
    }
    get id() {
        return this.src && this.src.id;
    }
    set id(id) {
        this.src && (this.src.id = id);
    }
    channel() {
        return this.src;
    }
    write(val) {
        if (this.src) {
            return this.src.write(val);
        }
        return Promise.resolve(false);
    }
    close(flush = false) {
        return this.src ? this.src.close(flush) : undefined;
    }
    tap(ch) {
        if (this.taps) {
            if (!(ch instanceof Channel)) {
                ch = new Channel(this.src.id + "-tap" + this.tapID++, ch);
            }
            else if (this.taps.find(ch)) {
                return ch;
            }
            this.taps.push(ch);
            return ch;
        }
    }
    untap(ch) {
        if (this.taps) {
            const t = this.taps.find(ch);
            if (t) {
                this.taps.remove(t);
                return true;
            }
        }
        return false;
    }
    untapAll(close = true) {
        if (this.taps) {
            let tap = this.taps.head;
            while (tap) {
                close && tap.value.close();
                this.taps.remove(tap);
                tap = tap.next;
            }
            return true;
        }
        return false;
    }
    process() {
        return __awaiter$1(this, void 0, void 0, function* () {
            let x;
            while (((x = null), (x = yield this.src.read())) !== undefined) {
                let t = this.taps.head;
                while (t) {
                    if (!(yield t.value.write(x))) {
                        this.taps.remove(t);
                    }
                    t = t.next;
                }
            }
            for (let t of this.taps) {
                yield t.close();
            }
            delete this.src;
            delete this.taps;
            delete this.tapID;
        });
    }
}
Mult.nextID = 0;

var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class PubSub {
    constructor(...args) {
        switch (args.length) {
            case 2:
                this.src = args[0];
                this.fn = args[1];
                break;
            case 1:
                this.src = new Channel("pubsub" + PubSub.NEXT_ID++);
                this.fn = args[0];
                break;
            default:
                errors.illegalArity(args.length);
        }
        this.topics = {};
        this.process();
    }
    get id() {
        return this.src && this.src.id;
    }
    set id(id) {
        this.src && (this.src.id = id);
    }
    channel() {
        return this.src;
    }
    write(val) {
        if (this.src) {
            return this.src.write(val);
        }
        return Promise.resolve(false);
    }
    close(flush = false) {
        return this.src ? this.src.close(flush) : undefined;
    }
    sub(id, tx) {
        let topic = this.topics[id];
        if (!topic) {
            this.topics[id] = topic = new Mult(this.src.id + "-" + id);
        }
        return topic.tap(tx);
    }
    unsub(id, ch) {
        let topic = this.topics[id];
        if (topic) {
            return topic.untap(ch);
        }
        return false;
    }
    unsubAll(id, close = true) {
        let topic = this.topics[id];
        if (topic) {
            return topic.untapAll(close);
        }
        return false;
    }
    process() {
        return __awaiter$2(this, void 0, void 0, function* () {
            let x;
            while (((x = null), (x = yield this.src.read())) !== undefined) {
                const id = yield this.fn(x);
                let topic = this.topics[id];
                topic && (yield topic.write(x));
                topic = this.topics["*"];
                topic && (yield topic.write(x));
            }
            for (let id of Object.keys(this.topics)) {
                this.topics[id].close();
            }
            delete this.src;
            delete this.topics;
            delete this.fn;
        });
    }
}
PubSub.NEXT_ID = 0;

exports.Channel = Channel;
exports.DroppingBuffer = DroppingBuffer;
exports.FixedBuffer = FixedBuffer;
exports.Mult = Mult;
exports.PubSub = PubSub;
exports.SlidingBuffer = SlidingBuffer;
