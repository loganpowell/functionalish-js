var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { shuffle } from "@thi.ng/arrays";
import { isFunction } from "@thi.ng/checks";
import { DCons } from "@thi.ng/dcons";
import { illegalArity } from "@thi.ng/errors";
import { cycle, delayed, isReduced, range, unreduced } from "@thi.ng/transducers";
import { FixedBuffer } from "./buffer";
export class Channel {
    constructor(...args) {
        let id, buf, tx, err;
        let [a, b] = args;
        switch (args.length) {
            case 0:
                break;
            case 1:
                if (typeof a === "string") {
                    id = a;
                }
                else if (maybeBuffer(a)) {
                    buf = a;
                }
                else {
                    tx = a;
                }
                break;
            case 2:
                if (typeof a === "string") {
                    id = a;
                    if (maybeBuffer(b)) {
                        buf = b;
                    }
                    else {
                        tx = b;
                    }
                }
                else {
                    [tx, err] = args;
                }
                break;
            case 3:
                if (isFunction(args[1]) && isFunction(args[2])) {
                    [id, tx, err] = args;
                }
                else {
                    [id, buf, tx] = args;
                }
                break;
            case 4:
                [id, buf, tx, err] = args;
                break;
            default:
                illegalArity(args.length);
        }
        this.id = id || `chan-${Channel.NEXT_ID++}`;
        buf = buf || 1;
        this.buf = typeof buf === "number" ? new FixedBuffer(buf) : buf;
        this.writes = new DCons();
        this.reads = new DCons();
        this.txbuf = new DCons();
        this.tx = tx ? tx(Channel.RFN) : null;
        this.onerror = tx && (err || defaultErrorHandler);
        this.state = 0 /* OPEN */;
        this.isBusy = false;
    }
    static constantly(x, delay) {
        const chan = new Channel(delay ? delayed(delay) : null);
        chan.produce(() => x);
        return chan;
    }
    static repeatedly(fn, delay) {
        const chan = new Channel(delay ? delayed(delay) : null);
        chan.produce(fn);
        return chan;
    }
    static cycle(src, delay) {
        return Channel.from(cycle(src), delay ? delayed(delay) : null);
    }
    static range(...args) {
        const [from, to, step, delay] = args;
        return Channel.from(range(from, to, step), delay !== undefined ? delayed(delay) : null);
    }
    /**
     * Constructs new channel which closes automatically after given period.
     *
     * @param delay - time in ms
     */
    static timeout(delay) {
        const chan = new Channel(`timeout-${Channel.NEXT_ID++}`);
        setTimeout(() => chan.close(), delay);
        return chan;
    }
    /**
     * Shorthand for: `Channel.timeout(delay).take()`
     *
     * @param delay - time in ms
     */
    static sleep(delay) {
        return Channel.timeout(delay).read();
    }
    /**
     * Creates new channel with single value from given promise, then closes
     * automatically iff promise has been resolved.
     *
     * @param p - promise
     */
    static fromPromise(p) {
        const chan = new Channel();
        p.then((x) => (() => __awaiter(this, void 0, void 0, function* () {
            yield chan.write(x);
            yield chan.close();
            return x;
        }))());
        return chan;
    }
    static from(...args) {
        let close, tx;
        switch (args.length) {
            case 1:
                break;
            case 2:
                if (typeof args[1] === "boolean") {
                    close = args[1];
                }
                else {
                    tx = args[1];
                }
                break;
            case 3:
                tx = args[1];
                close = args[2];
                break;
            default:
                illegalArity(args.length);
        }
        const chan = new Channel(tx);
        chan.into(args[0], close);
        return chan;
    }
    /**
     * Takes an array of channels and blocks until any of them becomes
     * readable (or has been closed). The returned promised resolves into
     * an array of `[value, channel]`. Channel order is repeatedly
     * shuffled for each read attempt.
     *
     * @param chans - source channels
     */
    static select(chans) {
        return new Promise((resolve) => {
            const _select = () => {
                for (let c of shuffle(chans)) {
                    if (c.isReadable() || c.isClosed()) {
                        c.read().then((x) => resolve([x, c]));
                        return;
                    }
                }
                Channel.SCHEDULE.call(null, _select, 0);
            };
            Channel.SCHEDULE.call(null, _select, 0);
        });
    }
    /**
     * Takes an array of channels to merge into new channel. Any closed
     * channels will be automatically removed from the input selection.
     * Once all inputs are closed, the target channel will close too (by
     * default).
     *
     * @remarks
     * If `named` is true, the merged channel will have tuples of:
     * `[src-id, val]` If false (default), only received values will be
     * forwarded.
     *
     * @param chans - source channels
     * @param out - result channel
     * @param close - true, if result closes
     * @param named - true, to emit labeled tuples
     */
    static merge(chans, out, close = true, named = false) {
        out = out || new Channel();
        (() => __awaiter(this, void 0, void 0, function* () {
            while (true) {
                let [x, ch] = yield Channel.select(chans);
                if (x === undefined) {
                    chans.splice(chans.indexOf(ch), 1);
                    if (!chans.length) {
                        close && (yield out.close());
                        break;
                    }
                }
                else {
                    yield out.write(named ? [ch.id, x] : x);
                }
            }
        }))();
        return out;
    }
    /**
     * Takes an array of channels to merge into new channel of tuples.
     * Whereas `Channel.merge()` realizes a sequential merging with no
     * guarantees about ordering of the output.
     *
     * @remarks
     * The output channel of this function will collect values from all
     * channels and a new tuple is emitted only once a new value has
     * been read from ALL channels. Therefore the overall throughput is
     * dictated by the slowest of the inputs.
     *
     * Once any of the inputs closes, the process is terminated and the
     * output channel is closed too (by default).
     *
     * @example
     * ```ts
     * Channel.mergeTuples([
     *   Channel.from([1, 2, 3]),
     *   Channel.from([10, 20, 30]),
     *   Channel.from([100, 200, 300])
     * ]).consume();
     *
     * // chan-0 : [ 1, 10, 100 ]
     * // chan-0 : [ 2, 20, 200 ]
     * // chan-0 : [ 3, 30, 300 ]
     * // chan-0 done
     *
     * Channel.mergeTuples([
     *   Channel.from([1, 2, 3]),
     *   Channel.from([10, 20, 30]),
     *   Channel.from([100, 200, 300])
     * ], null, false).consume();
     * ```
     *
     * @param chans - source channels
     * @param out - result channel
     * @param closeOnFirst - true, if result closes when first input is done
     * @param closeOutput - true, if result closes when all inputs are done
     */
    static mergeTuples(chans, out, closeOnFirst = true, closeOutput = true) {
        out = out || new Channel();
        (() => __awaiter(this, void 0, void 0, function* () {
            let buf = [];
            let orig = [...chans];
            let sel = new Set(chans);
            let n = chans.length;
            while (true) {
                let [x, ch] = yield Channel.select([...sel]);
                let idx = orig.indexOf(ch);
                if (x === undefined) {
                    if (closeOnFirst || chans.length === 1) {
                        break;
                    }
                    chans.splice(idx, 1);
                }
                buf[idx] = x;
                sel.delete(ch);
                if (--n === 0) {
                    yield out.write(buf);
                    buf = [];
                    n = chans.length;
                    sel = new Set(chans);
                }
            }
            closeOutput && (yield out.close());
        }))();
        return out;
    }
    channel() {
        return this;
    }
    write(value) {
        return new Promise((resolve) => {
            if (this.state !== 0 /* OPEN */) {
                resolve(false);
            }
            if (this.writes.length < Channel.MAX_WRITES) {
                this.writes.push({
                    value: this.tx
                        ? () => __awaiter(this, void 0, void 0, function* () {
                            try {
                                if (isReduced(this.tx[2](this.txbuf, value))) {
                                    this.state = 1 /* CLOSED */;
                                }
                            }
                            catch (e) {
                                this.onerror(e, this, value);
                            }
                        })
                        : () => value,
                    resolve
                });
                this.process();
            }
            else {
                throw new Error(`channel stalled (${Channel.MAX_WRITES} unprocessed writes)`);
            }
        });
    }
    read() {
        return new Promise((resolve) => {
            if (this.state === 2 /* DONE */) {
                resolve();
            }
            this.reads.push(resolve);
            this.process();
        });
    }
    tryRead(timeout = 1000) {
        return new Promise((resolve) => {
            (() => __awaiter(this, void 0, void 0, function* () {
                return resolve((yield Channel.select([this, Channel.timeout(timeout)]))[0]);
            }))();
        });
    }
    close(flush = false) {
        if (this.state === 0 /* OPEN */) {
            this.state = 1 /* CLOSED */;
            flush && this.flush();
            return this.process();
        }
    }
    isClosed() {
        return this.state !== 0 /* OPEN */;
    }
    isReadable() {
        return ((this.state !== 2 /* DONE */ && this.buf && this.buf.length > 0) ||
            (this.writes && this.writes.length > 0) ||
            (this.txbuf && this.txbuf.length > 0));
    }
    consume(fn = (x) => console.log(this.id, ":", x)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            let x;
            while (((x = null), (x = yield this.read())) !== undefined) {
                yield fn(x);
            }
        }))();
    }
    produce(fn, close = true) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            while (!this.isClosed()) {
                const val = yield fn();
                if (val === undefined) {
                    close && (yield this.close());
                    break;
                }
                yield this.write(val);
            }
        }))();
    }
    consumeWhileReadable(fn = (x) => console.log(this.id, ":", x)) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            let x;
            while (this.isReadable()) {
                x = yield this.read();
                if (x === undefined) {
                    break;
                }
                yield fn(x);
                x = null;
            }
        }))();
    }
    reduce(rfn, acc) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const [init, complete, reduce] = rfn;
            acc = acc != null ? acc : init();
            let x;
            while (((x = null), (x = yield this.read())) !== undefined) {
                acc = reduce(acc, x);
                if (isReduced(acc)) {
                    acc = acc.deref();
                    break;
                }
            }
            return unreduced(complete(acc));
        }))();
    }
    transduce(tx, rfn, acc) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            const _rfn = tx(rfn);
            return unreduced(_rfn[1](yield this.reduce(_rfn, acc)));
        }))();
    }
    into(src, close = true) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            for (let x of src) {
                if (this.isClosed()) {
                    break;
                }
                yield this.write(x);
            }
            close && (yield this.close());
        }))();
    }
    pipe(dest, close = true) {
        if (!(dest instanceof Channel)) {
            dest = new Channel(dest);
        }
        this.consume((x) => dest.write(x)) // return undefined here?
            .then(() => {
            close && dest.close();
        });
        return dest;
    }
    split(pred, truthy, falsey, close = true) {
        if (!(truthy instanceof Channel)) {
            truthy = new Channel();
        }
        if (!(falsey instanceof Channel)) {
            falsey = new Channel();
        }
        this.consume((x) => (pred(x) ? truthy : falsey).write(x)).then(() => {
            close && (truthy.close(), falsey.close());
        });
        return [truthy, falsey];
    }
    concat(chans, close = true) {
        return (() => __awaiter(this, void 0, void 0, function* () {
            for (let c of chans) {
                yield c.consume((x) => this.write(x));
            }
            close && (yield this.close());
        }))();
    }
    release() {
        if (this.state === 1 /* CLOSED */) {
            this.state = 2 /* DONE */;
            this.flush();
            this.buf.release();
            delete this.reads;
            delete this.writes;
            delete this.buf;
            delete this.txbuf;
            delete this.tx;
            delete this.isBusy;
            delete this.onerror;
        }
    }
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isBusy) {
                this.isBusy = true;
                const reads = this.reads;
                const writes = this.writes;
                const buf = this.buf;
                const txbuf = this.txbuf;
                let doProcess = true;
                while (doProcess) {
                    while (reads.length && (txbuf.length || buf.length)) {
                        if (txbuf.length) {
                            const val = txbuf.drop();
                            if (val !== undefined) {
                                reads.drop()(val);
                            }
                        }
                        else {
                            const val = yield buf.drop().value();
                            if (val !== undefined) {
                                reads.drop()(val);
                            }
                        }
                    }
                    while (writes.length && !buf.isFull()) {
                        const put = writes.drop();
                        buf.push(put);
                        put.resolve(true);
                    }
                    if (this.state === 1 /* CLOSED */) {
                        if (this.tx && !writes.length) {
                            try {
                                // finalize/complete transducer
                                this.tx[1](this.txbuf);
                            }
                            catch (e) {
                                this.onerror(e, this);
                            }
                        }
                        if (!this.isReadable()) {
                            this.release();
                            return;
                        }
                    }
                    doProcess =
                        (reads.length && (txbuf.length || buf.length)) ||
                            (writes.length && !buf.isFull());
                }
                this.isBusy = false;
            }
        });
    }
    flush() {
        let op;
        while ((op = this.reads.drop())) {
            op();
        }
        while ((op = this.writes.drop())) {
            op.resolve(false);
        }
        this.buf.release();
    }
}
Channel.MAX_WRITES = 1024;
Channel.NEXT_ID = 0;
Channel.SCHEDULE = typeof setImmediate === "function" ? setImmediate : setTimeout;
Channel.RFN = [
    (() => null),
    (acc) => acc,
    (acc, x) => acc.push(x)
];
const defaultErrorHandler = (e, chan, val) => console.log(chan.id, "error occurred", e.message, val !== undefined ? val : "");
const maybeBuffer = (x) => x instanceof FixedBuffer || typeof x === "number";
