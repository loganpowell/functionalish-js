var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { DCons } from "@thi.ng/dcons";
import { illegalArity } from "@thi.ng/errors";
import { Channel } from "./channel";
export class Mult {
    constructor(...args) {
        this.tapID = 0;
        let id, src;
        switch (args.length) {
            case 2:
                id = args[0];
                src = args[1];
                break;
            case 1:
                if (typeof args[0] === "string") {
                    id = args[0];
                }
                else {
                    src = args[0];
                }
                break;
            case 0:
                id = "mult" + Mult.nextID++;
                break;
            default:
                illegalArity(args.length);
        }
        if (src instanceof Channel) {
            this.src = src;
        }
        else {
            this.src = new Channel(id, src);
        }
        this.taps = new DCons();
        this.process();
    }
    get id() {
        return this.src && this.src.id;
    }
    set id(id) {
        this.src && (this.src.id = id);
    }
    channel() {
        return this.src;
    }
    write(val) {
        if (this.src) {
            return this.src.write(val);
        }
        return Promise.resolve(false);
    }
    close(flush = false) {
        return this.src ? this.src.close(flush) : undefined;
    }
    tap(ch) {
        if (this.taps) {
            if (!(ch instanceof Channel)) {
                ch = new Channel(this.src.id + "-tap" + this.tapID++, ch);
            }
            else if (this.taps.find(ch)) {
                return ch;
            }
            this.taps.push(ch);
            return ch;
        }
    }
    untap(ch) {
        if (this.taps) {
            const t = this.taps.find(ch);
            if (t) {
                this.taps.remove(t);
                return true;
            }
        }
        return false;
    }
    untapAll(close = true) {
        if (this.taps) {
            let tap = this.taps.head;
            while (tap) {
                close && tap.value.close();
                this.taps.remove(tap);
                tap = tap.next;
            }
            return true;
        }
        return false;
    }
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            let x;
            while (((x = null), (x = yield this.src.read())) !== undefined) {
                let t = this.taps.head;
                while (t) {
                    if (!(yield t.value.write(x))) {
                        this.taps.remove(t);
                    }
                    t = t.next;
                }
            }
            for (let t of this.taps) {
                yield t.close();
            }
            delete this.src;
            delete this.taps;
            delete this.tapID;
        });
    }
}
Mult.nextID = 0;
