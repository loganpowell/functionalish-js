'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var checks = require('@thi.ng/checks');
var errors = require('@thi.ng/errors');

const SVG_NS = "http://www.w3.org/2000/svg";
const XLINK_NS = "http://www.w3.org/1999/xlink";
const XHTML_NS = "http://www.w3.org/1999/xhtml";
const PROC_TAGS = {
    "?xml": "?>\n",
    "!DOCTYPE": ">\n",
    "!ENTITY": ">\n",
    "!ELEMENT": ">\n",
    "!ATTLIST": ">\n"
};
const ENTITIES = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&apos;"
};
const RE_TAG = /^([^\s\.#]+)(?:#([^\s\.#]+))?(?:\.([^\s#]+))?$/;
const RE_ENTITY = new RegExp(`[${Object.keys(ENTITIES).join("")}]`, "g");
const COMMENT = "__COMMENT__";
const NO_SPANS = {
    button: 1,
    option: 1,
    text: 1,
    textarea: 1
};
const tagMap = (tags) => tags.split(" ").reduce((acc, x) => ((acc[x] = true), acc), {});
const SVG_TAGS = tagMap("animate animateColor animateMotion animateTransform circle clipPath color-profile defs desc discard ellipse feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feDropShadow feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence filter font foreignObject g image line linearGradient marker mask metadata mpath path pattern polygon polyline radialGradient rect set stop style svg switch symbol text textPath title tref tspan use view");
const VOID_TAGS = tagMap("area base br circle col command ellipse embed hr img input keygen line link meta param path polygon polyline rect source stop track use wbr ?xml");

const css = (rules) => {
    let css = "", v;
    for (let r in rules) {
        v = rules[r];
        if (checks.isFunction(v)) {
            v = v(rules);
        }
        v != null && (css += `${r}:${v};`);
    }
    return css;
};

const derefContext = (ctx, keys) => {
    if (ctx == null || !keys || !keys.length)
        return ctx;
    const res = Object.assign({}, ctx);
    for (let k of keys) {
        const v = res[k];
        checks.implementsFunction(v, "deref") && (res[k] = v.deref());
    }
    return res;
};

const escape = (x) => x.replace(RE_ENTITY, (y) => ENTITIES[y]);

const normalize = (tag) => {
    let el = tag[0];
    let match;
    let id;
    let clazz;
    const hasAttribs = checks.isPlainObject(tag[1]);
    const attribs = hasAttribs ? Object.assign({}, tag[1]) : {};
    if (!checks.isString(el) || !(match = RE_TAG.exec(el))) {
        errors.illegalArgs(`"${el}" is not a valid tag name`);
    }
    el = match[1];
    id = match[2];
    clazz = match[3];
    if (id) {
        attribs.id = id;
    }
    if (clazz) {
        clazz = clazz.replace(/\./g, " ");
        if (attribs.class) {
            attribs.class += " " + clazz;
        }
        else {
            attribs.class = clazz;
        }
    }
    if (tag.length > 1) {
        if (checks.isPlainObject(attribs.style)) {
            attribs.style = css(attribs.style);
        }
        tag = tag.slice(hasAttribs ? 2 : 1).filter((x) => x != null);
        if (tag.length > 0) {
            return [el, attribs, tag];
        }
    }
    return [el, attribs];
};

const serialize = (tree, ctx, escape = false, span = false, keys = span, path = [0]) => _serialize(tree, ctx, escape, span, keys, path);
const _serialize = (tree, ctx, esc, span, keys, path) => {
    if (tree == null) {
        return "";
    }
    if (Array.isArray(tree)) {
        return serializeElement(tree, ctx, esc, span, keys, path);
    }
    if (checks.isFunction(tree)) {
        return _serialize(tree(ctx), ctx, esc, span, keys, path);
    }
    if (checks.implementsFunction(tree, "toHiccup")) {
        return _serialize(tree.toHiccup(ctx), ctx, esc, span, keys, path);
    }
    if (checks.implementsFunction(tree, "deref")) {
        return _serialize(tree.deref(), ctx, esc, span, keys, path);
    }
    if (checks.isNotStringAndIterable(tree)) {
        return serializeIter(tree, ctx, esc, span, keys, path);
    }
    tree = esc ? escape(tree.toString()) : tree;
    return span
        ? `<span${keys ? ` key="${path.join("-")}"` : ""}>${tree}</span>`
        : tree;
};
const serializeElement = (tree, ctx, esc, span, keys, path) => {
    if (!tree.length) {
        return "";
    }
    let tag = tree[0];
    if (checks.isFunction(tag)) {
        return _serialize(tag.apply(null, [ctx, ...tree.slice(1)]), ctx, esc, span, keys, path);
    }
    if (checks.implementsFunction(tag, "render")) {
        return _serialize(tag.render.apply(null, [ctx, ...tree.slice(1)]), ctx, esc, span, keys, path);
    }
    if (tag === COMMENT) {
        return serializeComment(tree);
    }
    if (checks.isString(tag)) {
        tree = normalize(tree);
        tag = tree[0];
        const attribs = tree[1];
        if (attribs.__skip || attribs.__serialize === false) {
            return "";
        }
        let body = tree[2];
        let res = `<${tag}`;
        keys && attribs.key === undefined && (attribs.key = path.join("-"));
        res += serializeAttribs(attribs, esc);
        res += body
            ? serializeBody(tag, body, ctx, esc, span, keys, path)
            : !VOID_TAGS[tag]
                ? `></${tag}>`
                : PROC_TAGS[tag] || "/>";
        return res;
    }
    if (checks.isNotStringAndIterable(tree)) {
        return serializeIter(tree, ctx, esc, span, keys, path);
    }
    return errors.illegalArgs(`invalid tree node: ${tree}`);
};
const serializeAttribs = (attribs, esc) => {
    let res = "";
    for (let a in attribs) {
        if (a.startsWith("__"))
            continue;
        let v = attribs[a];
        if (v == null)
            continue;
        if (checks.isFunction(v) && (/^on\w+/.test(a) || (v = v(attribs)) == null))
            continue;
        if (v === true) {
            res += " " + a;
        }
        else if (v !== false) {
            v = v.toString();
            v.length && (res += ` ${a}="${esc ? escape(v) : v}"`);
        }
    }
    return res;
};
const serializeBody = (tag, body, ctx, esc, span, keys, path) => {
    if (VOID_TAGS[tag]) {
        errors.illegalArgs(`No body allowed in tag: ${tag}`);
    }
    const proc = PROC_TAGS[tag];
    let res = proc ? " " : ">";
    span = span && !proc && !NO_SPANS[tag];
    for (let i = 0, n = body.length; i < n; i++) {
        res += _serialize(body[i], ctx, esc, span, keys, [...path, i]);
    }
    return res + (proc || `</${tag}>`);
};
const serializeComment = (tree) => tree.length > 2
    ? `\n<!--\n${tree
        .slice(1)
        .map((x) => "    " + x)
        .join("\n")}\n-->\n`
    : `\n<!-- ${tree[1]} -->\n`;
const serializeIter = (iter, ctx, esc, span, keys, path) => {
    const res = [];
    const p = path.slice(0, path.length - 1);
    let k = 0;
    for (let i of iter) {
        res.push(_serialize(i, ctx, esc, span, keys, [...p, k++]));
    }
    return res.join("");
};

exports.COMMENT = COMMENT;
exports.ENTITIES = ENTITIES;
exports.NO_SPANS = NO_SPANS;
exports.PROC_TAGS = PROC_TAGS;
exports.RE_ENTITY = RE_ENTITY;
exports.RE_TAG = RE_TAG;
exports.SVG_NS = SVG_NS;
exports.SVG_TAGS = SVG_TAGS;
exports.VOID_TAGS = VOID_TAGS;
exports.XHTML_NS = XHTML_NS;
exports.XLINK_NS = XLINK_NS;
exports.css = css;
exports.derefContext = derefContext;
exports.escape = escape;
exports.normalize = normalize;
exports.serialize = serialize;
