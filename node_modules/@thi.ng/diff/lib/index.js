'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var equiv = require('@thi.ng/equiv');

let _cachedFP;
let _cachedPath;
let _cachedEPC = [];
let _cachedPathPos = [];
const cachedFP = (size) => _cachedFP && _cachedFP.length >= size
    ? _cachedFP
    : (_cachedFP = new Int32Array(size));
const cachedPath = (size) => _cachedPath && _cachedPath.length >= size
    ? _cachedPath
    : (_cachedPath = new Int32Array(size));
const simpleDiff = (state, src, key, logDir, mode) => {
    const n = src.length;
    const linear = state.linear;
    state.distance = n;
    if (mode !== 0 ) {
        for (let i = 0, j = 0; i < n; i++, j += 3) {
            linear[j] = logDir;
            linear[j + 1] = i;
            linear[j + 2] = src[i];
        }
        if (mode === 3 ) {
            const _state = state[key];
            for (let i = 0; i < n; i++) {
                _state[i] = src[i];
            }
        }
    }
    return state;
};
const diffArray = (a, b, mode = 3 , equiv$1 = equiv.equiv) => {
    const state = {
        distance: 0,
        adds: {},
        dels: {},
        const: {},
        linear: []
    };
    if (a === b || (a == null && b == null)) {
        return state;
    }
    else if (a == null || a.length === 0) {
        return simpleDiff(state, b, "adds", 1, mode);
    }
    else if (b == null || b.length === 0) {
        return simpleDiff(state, a, "dels", -1, mode);
    }
    const reverse = a.length >= b.length;
    let _a, _b, na, nb;
    if (reverse) {
        _a = b;
        _b = a;
    }
    else {
        _a = a;
        _b = b;
    }
    na = _a.length;
    nb = _b.length;
    const offset = na + 1;
    const delta = nb - na;
    const doff = delta + offset;
    const size = na + nb + 3;
    const path = cachedPath(size).fill(-1, 0, size);
    const fp = cachedFP(size).fill(-1, 0, size);
    const epc = _cachedEPC;
    const pathPos = _cachedPathPos;
    epc.length = 0;
    pathPos.length = 0;
    const snake = (k, p, pp) => {
        const koff = k + offset;
        let r, y;
        if (p > pp) {
            r = path[koff - 1];
            y = p;
        }
        else {
            r = path[koff + 1];
            y = pp;
        }
        let x = y - k;
        while (x < na && y < nb && equiv$1(_a[x], _b[y])) {
            x++;
            y++;
        }
        path[koff] = pathPos.length / 3;
        pathPos.push(x, y, r);
        return y;
    };
    let p = -1, k, ko;
    do {
        p++;
        for (k = -p, ko = k + offset; k < delta; k++, ko++) {
            fp[ko] = snake(k, fp[ko - 1] + 1, fp[ko + 1]);
        }
        for (k = delta + p, ko = k + offset; k > delta; k--, ko--) {
            fp[ko] = snake(k, fp[ko - 1] + 1, fp[ko + 1]);
        }
        fp[doff] = snake(delta, fp[doff - 1] + 1, fp[doff + 1]);
    } while (fp[doff] !== nb);
    state.distance = delta + 2 * p;
    if (mode !== 0 ) {
        p = path[doff] * 3;
        while (p >= 0) {
            epc.push(p);
            p = pathPos[p + 2] * 3;
        }
        if (mode === 3 ) {
            buildFullLog(epc, pathPos, state, _a, _b, reverse);
        }
        else {
            buildLinearLog(epc, pathPos, state, _a, _b, reverse, mode === 1 );
        }
    }
    return state;
};
const buildFullLog = (epc, pathPos, state, a, b, reverse) => {
    const linear = state.linear;
    const _const = state.const;
    let i = epc.length;
    let px = 0;
    let py = 0;
    let adds;
    let dels;
    let aID;
    let dID;
    if (reverse) {
        adds = state.dels;
        dels = state.adds;
        aID = -1;
        dID = 1;
    }
    else {
        adds = state.adds;
        dels = state.dels;
        aID = 1;
        dID = -1;
    }
    for (; --i >= 0;) {
        const e = epc[i];
        const ppx = pathPos[e];
        const ppy = pathPos[e + 1];
        const d = ppy - ppx;
        while (px < ppx || py < ppy) {
            const dp = py - px;
            if (d > dp) {
                linear.push(aID, py, (adds[py] = b[py]));
                py++;
            }
            else if (d < dp) {
                linear.push(dID, px, (dels[px] = a[px]));
                px++;
            }
            else {
                linear.push(0, px, (_const[px] = a[px]));
                px++;
                py++;
            }
        }
    }
};
const buildLinearLog = (epc, pathPos, state, a, b, reverse, inclConst) => {
    const linear = state.linear;
    const aID = reverse ? -1 : 1;
    const dID = reverse ? 1 : -1;
    let i = epc.length, px = 0, py = 0;
    for (; --i >= 0;) {
        const e = epc[i];
        const ppx = pathPos[e];
        const ppy = pathPos[e + 1];
        const d = ppy - ppx;
        while (px < ppx || py < ppy) {
            const dp = py - px;
            if (d > dp) {
                linear.push(aID, py, b[py]);
                py++;
            }
            else if (d < dp) {
                linear.push(dID, px, a[px]);
                px++;
            }
            else {
                inclConst && linear.push(0, px, a[px]);
                px++;
                py++;
            }
        }
    }
};

(function (DiffMode) {
    DiffMode[DiffMode["ONLY_DISTANCE"] = 0] = "ONLY_DISTANCE";
    DiffMode[DiffMode["ONLY_DISTANCE_LINEAR"] = 1] = "ONLY_DISTANCE_LINEAR";
    DiffMode[DiffMode["ONLY_DISTANCE_LINEAR_ONLY_CHANGES"] = 2] = "ONLY_DISTANCE_LINEAR_ONLY_CHANGES";
    DiffMode[DiffMode["FULL"] = 3] = "FULL";
})(exports.DiffMode || (exports.DiffMode = {}));

const diffObject = (a, b, mode = 3 , _equiv = equiv.equiv) => a === b
    ? { distance: 0 }
    : mode === 0
        ? diffObjectDist(a, b, _equiv)
        : diffObjectFull(a, b, _equiv);
const diffObjectDist = (a, b, _equiv) => {
    if (!a)
        a = {};
    if (!b)
        b = {};
    let d = 0;
    for (let k in a) {
        const vb = b[k];
        (vb === undefined || !_equiv(a[k], vb)) && d++;
    }
    for (let k in b) {
        !(k in a) && d++;
    }
    return { distance: d };
};
const diffObjectFull = (a, b, _equiv) => {
    if (!a)
        a = {};
    if (!b)
        b = {};
    let d = 0;
    const adds = [];
    const dels = [];
    const edits = [];
    for (let k in a) {
        const vb = b[k];
        if (vb === undefined) {
            dels.push(k);
            d++;
        }
        else if (!_equiv(a[k], vb)) {
            edits.push(k, vb);
            d++;
        }
    }
    for (let k in b) {
        if (!(k in a)) {
            adds.push(k);
            d++;
        }
    }
    return { distance: d, adds, dels, edits };
};

exports.diffArray = diffArray;
exports.diffObject = diffObject;
