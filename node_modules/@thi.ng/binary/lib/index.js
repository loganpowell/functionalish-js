'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const align = (addr, size) => (size--, (addr + size) & ~size);
const isAligned = (addr, size) => !(addr & (size - 1));

const F64 = new Float64Array(1);
const F32 = new Float32Array(F64.buffer);
const I32 = new Int32Array(F64.buffer);
const U32 = new Uint32Array(F64.buffer);
const IS_LE = ((F64[0] = 2), U32[1] === 0x40000000);
const floatToIntBits = (x) => ((F32[0] = x), I32[0]);
const floatToUintBits = (x) => ((F32[0] = x), U32[0]);
const intBitsToFloat = (x) => ((I32[0] = x), F32[0]);
const uintBitsToFloat = (x) => ((U32[0] = x), F32[0]);
const floatToIntBits64 = (x) => ((F64[0] = x), IS_LE ? [I32[1], I32[0]] : [I32[0], I32[1]]);
const floatToUintBits64 = (x) => ((F64[0] = x), IS_LE ? [U32[1], U32[0]] : [U32[0], U32[1]]);
const intBitsToFloat64 = (hi, lo) => {
    IS_LE ? ((I32[1] = hi), (I32[0] = lo)) : ((I32[0] = hi), (I32[1] = lo));
    return F64[0];
};
const uintBitsToFloat64 = (hi, lo) => {
    IS_LE ? ((U32[1] = hi), (U32[0] = lo)) : ((U32[0] = hi), (U32[1] = lo));
    return F64[0];
};
const floatToSortableInt = (x) => {
    if (x === -0)
        x = 0;
    const i = floatToIntBits(x);
    return x < 0 ? ~i | (1 << 31) : i;
};
const clamp11 = (x) => (x < -1 ? -1 : x > 1 ? 1 : x);
const f32u8 = (x) => (clamp11(x) * 0x7f) & 0xff;
const f32u16 = (x) => (clamp11(x) * 0x7fff) & 0xffff;
const f32u24 = (x) => (clamp11(x) * 0x7fffff) & 0xffffff;
const f32u32 = (x) => (clamp11(x) * 0x7fffffff) >>> 0;
const u8f32 = (x) => ((x &= 0xff), (x | ((x >> 7) * 0xffffff00)) / 0x7f);
const u16f32 = (x) => ((x &= 0xffff), (x | ((x >> 15) * 0xffff0000)) / 0x7fff);
const u24f32 = (x) => ((x &= 0xffffff), (x | ((x >> 23) * 0xff000000)) / 0x7fffff);
const u32f32 = (x) => (x | 0) / 0x7fffffff;

const bytes16 = (x, le = false) => {
    const b0 = x & 0xff;
    const b1 = (x >> 8) & 0xff;
    return le ? [b0, b1] : [b1, b0];
};
const bytes24 = (x, le = false) => {
    const b0 = x & 0xff;
    const b1 = (x >> 8) & 0xff;
    const b2 = (x >> 16) & 0xff;
    return le ? [b0, b1, b2] : [b2, b1, b0];
};
const bytes32 = (x, le = false) => {
    const b0 = x & 0xff;
    const b1 = (x >> 8) & 0xff;
    const b2 = (x >> 16) & 0xff;
    const b3 = (x >> 24) & 0xff;
    return le ? [b0, b1, b2, b3] : [b3, b2, b1, b0];
};
const bytes64 = (hi, lo, le = false) => {
    return le
        ? bytes32(lo, le).concat(bytes32(hi, le))
        : bytes32(hi, le).concat(bytes32(lo, le));
};
const bytesF32 = (x, le = false) => bytes32(floatToUintBits(x), le);
const bytesF64 = (x, le = false) =>
bytes64(...floatToUintBits64(x), le);

const MASKS = new Array(33).fill(0).map((_, i) => Math.pow(2, i) - 1);

const popCount = (x) => ((x = x - ((x >>> 1) & 0x55555555)),
    (x = (x & 0x33333333) + ((x >>> 2) & 0x33333333)),
    (((x + (x >>> 4)) & 0xf0f0f0f) * 0x1010101) >>> 24);
const hammingDist = (x, y) => popCount(x ^ y);
const clz32 = (x) => x !== 0 ? 31 - ((Math.log(x >>> 0) / Math.LN2) | 0) : 32;
const ctz32 = (x) => {
    let c = 32;
    x &= -x;
    x && c--;
    x & 0x0000ffff && (c -= 16);
    x & 0x00ff00ff && (c -= 8);
    x & 0x0f0f0f0f && (c -= 4);
    x & 0x33333333 && (c -= 2);
    x & 0x55555555 && (c -= 1);
    return c;
};
const bitSize = (x) => (x > 1 ? Math.ceil(Math.log2(x)) : 0);

const defMask = (a, b) => (~MASKS[a] & MASKS[b]) >>> 0;
const maskL = (n, x) => (x & MASKS[n]) >>> 0;
const maskH = (n, x) => (x & ~MASKS[n]) >>> 0;

const bitClear = (x, bit) => (x & ~(1 << bit)) >>> 0;
const bitFlip = (x, bit) => (x ^ (1 << bit)) >>> 0;
const bitSet = (x, bit) => (x | (1 << bit)) >>> 0;
const bitSetWindow = (x, y, from, to) => {
    const m = defMask(from, to);
    return (x & ~m) | ((y << (1 << from)) & m);
};
const bitClearWindow = (x, from, to) => x & ~defMask(from, to);

const encodeGray32 = (x) => (x ^ (x >>> 1)) >>> 0;
const decodeGray32 = (x) => {
    x = x ^ (x >>> 16);
    x = x ^ (x >>> 8);
    x = x ^ (x >>> 4);
    x = x ^ (x >>> 2);
    x = x ^ (x >>> 1);
    return x >>> 0;
};

const bitNot = (x) => ~x;
const bitAnd = (a, b) => a & b;
const bitNand = (a, b) => ~(a & b);
const bitOr = (a, b) => a | b;
const bitNor = (a, b) => ~(a | b);
const bitXor = (a, b) => a ^ b;
const bitXnor = (a, b) => ~(a ^ b);
const bitImply = (a, b) => ~a | b;
const bitAoi21 = (a, b, c) => ~(a | (b & c));
const bitOai21 = (a, b, c) => ~(a & (b | c));
const bitAoi22 = (a, b, c, d) => ~((a & b) | (c & d));
const bitOai22 = (a, b, c, d) => ~((a | b) & (c | d));
const bitMux = (a, b, s) => ((a & ~s) | (b & s)) >>> 0;
const bitDemux = (a, b, s) => [
    (a & ~s) >>> 0,
    (b & s) >>> 0
];
const bitNotM = (n, x) => maskL(n, ~x);
const bitAndM = (n, a, b) => maskL(n, a & b);
const bitNandM = (n, a, b) => maskL(n, ~(a & b));
const bitOrM = (n, a, b) => maskL(n, a | b);
const bitNorM = (n, a, b) => maskL(n, ~(a | b));
const bitXorM = (n, a, b) => maskL(n, a ^ b);
const bitXnorM = (n, a, b) => maskL(n, ~(a ^ b));
const bitImplyM = (n, a, b) => maskL(n, ~a | b);
const bitAoi21M = (n, a, b, c) => maskL(n, ~(a | (b & c)));
const bitOai21M = (n, a, b, c) => maskL(n, ~(a & (b | c)));
const bitAoi22M = (n, a, b, c, d) => maskL(n, ~((a & b) | (c & d)));
const bitOai22M = (n, a, b, c, d) => maskL(n, ~((a | b) & (c | d)));
const bitMuxM = (n, a, b, s) => maskL(n, (a & ~s) | (b & s));
const bitDemuxM = (n, a, b, s) => [maskL(n, a & ~s), maskL(n, b & s)];

const isPow2 = (x) => !!x && !(x & (x - 1));
const ceilPow2 = (x) => {
    x += (x === 0);
    --x;
    x |= x >>> 1;
    x |= x >>> 2;
    x |= x >>> 4;
    x |= x >>> 8;
    x |= x >>> 16;
    return x + 1;
};
const floorPow2 = (x) => {
    x |= x >>> 1;
    x |= x >>> 2;
    x |= x >>> 4;
    x |= x >>> 8;
    x |= x >>> 16;
    return x - (x >>> 1);
};

const rotateLeft = (x, n) => ((x << n) | (x >>> (32 - n))) >>> 0;
const rotateRight = (x, n) => ((x >>> n) | (x << (32 - n))) >>> 0;

const splat4_24 = (x) => (x & 0xf) * 0x111111;
const splat4_32 = (x) => ((x & 0xf) * 0x11111111) >>> 0;
const splat8_24 = (x) => (x & 0xff) * 0x010101;
const splat8_32 = (x) => ((x & 0xff) * 0x01010101) >>> 0;
const splat16_32 = (x) => ((x &= 0xffff), ((x << 16) | x) >>> 0);
const same4 = (x) => ((x >> 4) & 0xf) === (x & 0xf);
const same8 = (x) => ((x >> 8) & 0xff) === (x & 0xff);

const lane16 = (x, lane) => (x >>> ((1 - lane) << 4)) & 0xffff;
const lane8 = (x, lane) => (x >>> ((3 - lane) << 3)) & 0xff;
const lane4 = (x, lane) => (x >>> ((7 - lane) << 2)) & 0xf;
const lane2 = (x, lane) => (x >>> ((15 - lane) << 1)) & 0x3;
const setLane16 = (x, y, lane) => lane ? mux(x, y, 0xffff) : mux(x, y << 16, 0xffff0000);
const setLane8 = (x, y, lane) => {
    const l = (3 - lane) << 3;
    return ((~(0xff << l) & x) | ((y & 0xff) << l)) >>> 0;
};
const setLane4 = (x, y, lane) => {
    const l = (7 - lane) << 2;
    return ((~(0xf << l) & x) | ((y & 0xf) << l)) >>> 0;
};
const setLane2 = (x, y, lane) => {
    const l = (15 - lane) << 1;
    return ((~(0x3 << l) & x) | ((y & 0x3) << l)) >>> 0;
};
const swizzle8 = (x, a, b, c, d) => ((lane8(x, a) << 24) |
    (lane8(x, b) << 16) |
    (lane8(x, c) << 8) |
    lane8(x, d)) >>>
    0;
const swizzle4 = (x, a, b, c, d, e, f, g, h) => ((lane4(x, a) << 28) |
    (lane4(x, b) << 24) |
    (lane4(x, c) << 20) |
    (lane4(x, d) << 16) |
    (lane4(x, e) << 12) |
    (lane4(x, f) << 8) |
    (lane4(x, g) << 4) |
    lane4(x, h)) >>>
    0;
const mux = (a, b, mask) => (~mask & a) | (mask & b);
const flip8 = (x) => ((x >>> 24) | ((x >> 8) & 0xff00) | ((x & 0xff00) << 8) | (x << 24)) >>> 0;
const flip16 = (x) => mux(x << 16, x >>> 16, 0xffff);
const flipBytes = flip8;

exports.IS_LE = IS_LE;
exports.MASKS = MASKS;
exports.align = align;
exports.bitAnd = bitAnd;
exports.bitAndM = bitAndM;
exports.bitAoi21 = bitAoi21;
exports.bitAoi21M = bitAoi21M;
exports.bitAoi22 = bitAoi22;
exports.bitAoi22M = bitAoi22M;
exports.bitClear = bitClear;
exports.bitClearWindow = bitClearWindow;
exports.bitDemux = bitDemux;
exports.bitDemuxM = bitDemuxM;
exports.bitFlip = bitFlip;
exports.bitImply = bitImply;
exports.bitImplyM = bitImplyM;
exports.bitMux = bitMux;
exports.bitMuxM = bitMuxM;
exports.bitNand = bitNand;
exports.bitNandM = bitNandM;
exports.bitNor = bitNor;
exports.bitNorM = bitNorM;
exports.bitNot = bitNot;
exports.bitNotM = bitNotM;
exports.bitOai21 = bitOai21;
exports.bitOai21M = bitOai21M;
exports.bitOai22 = bitOai22;
exports.bitOai22M = bitOai22M;
exports.bitOr = bitOr;
exports.bitOrM = bitOrM;
exports.bitSet = bitSet;
exports.bitSetWindow = bitSetWindow;
exports.bitSize = bitSize;
exports.bitXnor = bitXnor;
exports.bitXnorM = bitXnorM;
exports.bitXor = bitXor;
exports.bitXorM = bitXorM;
exports.bytes16 = bytes16;
exports.bytes24 = bytes24;
exports.bytes32 = bytes32;
exports.bytes64 = bytes64;
exports.bytesF32 = bytesF32;
exports.bytesF64 = bytesF64;
exports.ceilPow2 = ceilPow2;
exports.clz32 = clz32;
exports.ctz32 = ctz32;
exports.decodeGray32 = decodeGray32;
exports.defMask = defMask;
exports.encodeGray32 = encodeGray32;
exports.f32u16 = f32u16;
exports.f32u24 = f32u24;
exports.f32u32 = f32u32;
exports.f32u8 = f32u8;
exports.flip16 = flip16;
exports.flip8 = flip8;
exports.flipBytes = flipBytes;
exports.floatToIntBits = floatToIntBits;
exports.floatToIntBits64 = floatToIntBits64;
exports.floatToSortableInt = floatToSortableInt;
exports.floatToUintBits = floatToUintBits;
exports.floatToUintBits64 = floatToUintBits64;
exports.floorPow2 = floorPow2;
exports.hammingDist = hammingDist;
exports.intBitsToFloat = intBitsToFloat;
exports.intBitsToFloat64 = intBitsToFloat64;
exports.isAligned = isAligned;
exports.isPow2 = isPow2;
exports.lane16 = lane16;
exports.lane2 = lane2;
exports.lane4 = lane4;
exports.lane8 = lane8;
exports.maskH = maskH;
exports.maskL = maskL;
exports.mux = mux;
exports.popCount = popCount;
exports.rotateLeft = rotateLeft;
exports.rotateRight = rotateRight;
exports.same4 = same4;
exports.same8 = same8;
exports.setLane16 = setLane16;
exports.setLane2 = setLane2;
exports.setLane4 = setLane4;
exports.setLane8 = setLane8;
exports.splat16_32 = splat16_32;
exports.splat4_24 = splat4_24;
exports.splat4_32 = splat4_32;
exports.splat8_24 = splat8_24;
exports.splat8_32 = splat8_32;
exports.swizzle4 = swizzle4;
exports.swizzle8 = swizzle8;
exports.u16f32 = u16f32;
exports.u24f32 = u24f32;
exports.u32f32 = u32f32;
exports.u8f32 = u8f32;
exports.uintBitsToFloat = uintBitsToFloat;
exports.uintBitsToFloat64 = uintBitsToFloat64;
