'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@thi.ng/api');
var equiv = require('@thi.ng/equiv');
var checks = require('@thi.ng/checks');
var transducers = require('@thi.ng/transducers');
var binary = require('@thi.ng/binary');
var dcons = require('@thi.ng/dcons');
var compare = require('@thi.ng/compare');
var errors = require('@thi.ng/errors');

function dissoc(coll, keys) {
    for (let k of keys) {
        coll.delete(k);
    }
    return coll;
}
const dissocObj = (obj, keys) => {
    for (let k of keys) {
        delete obj[k];
    }
    return obj;
};

const equivMap = (a, b) => {
    if (a === b) {
        return true;
    }
    if (!(b instanceof Map) || a.size !== b.size) {
        return false;
    }
    for (let p of a.entries()) {
        if (!equiv.equiv(b.get(p[0]), p[1])) {
            return false;
        }
    }
    return true;
};
const equivSet = (a, b) => {
    if (a === b) {
        return true;
    }
    if (!(b instanceof Set) || a.size !== b.size) {
        return false;
    }
    for (let k of a.keys()) {
        if (!b.has(k)) {
            return false;
        }
    }
    return true;
};

function into(dest, src) {
    if (checks.isMap(dest)) {
        for (let x of src) {
            dest.set(x[0], x[1]);
        }
    }
    else {
        for (let x of src) {
            dest.add(x);
        }
    }
    return dest;
}

const __private = new WeakMap();
const __vals = (inst) => __private.get(inst).vals;
class ArraySet extends Set {
    constructor(vals, opts = {}) {
        super();
        __private.set(this, { equiv: opts.equiv || equiv.equiv, vals: [] });
        vals && this.into(vals);
    }
    *[Symbol.iterator]() {
        yield* __vals(this);
    }
    get [Symbol.species]() {
        return ArraySet;
    }
    get [Symbol.toStringTag]() {
        return "ArraySet";
    }
    get size() {
        return __vals(this).length;
    }
    copy() {
        const $this = __private.get(this);
        const s = new ArraySet(null, { equiv: $this.equiv });
        __private.get(s).vals = $this.vals.slice();
        return s;
    }
    empty() {
        return new ArraySet(null, this.opts());
    }
    clear() {
        __vals(this).length = 0;
    }
    first() {
        if (this.size) {
            return __vals(this)[0];
        }
    }
    add(key) {
        !this.has(key) && __vals(this).push(key);
        return this;
    }
    into(keys) {
        return into(this, keys);
    }
    has(key) {
        return this.get(key, api.SEMAPHORE) !== api.SEMAPHORE;
    }
    get(key, notFound) {
        const $this = __private.get(this);
        const eq = $this.equiv;
        const vals = $this.vals;
        for (let i = vals.length; --i >= 0;) {
            if (eq(vals[i], key)) {
                return vals[i];
            }
        }
        return notFound;
    }
    delete(key) {
        const $this = __private.get(this);
        const eq = $this.equiv;
        const vals = $this.vals;
        for (let i = vals.length; --i >= 0;) {
            if (eq(vals[i], key)) {
                vals.splice(i, 1);
                return true;
            }
        }
        return false;
    }
    disj(keys) {
        return dissoc(this, keys);
    }
    equiv(o) {
        return equivSet(this, o);
    }
    forEach(fn, thisArg) {
        const vals = __vals(this);
        for (let i = vals.length; --i >= 0;) {
            const v = vals[i];
            fn.call(thisArg, v, v, this);
        }
    }
    *entries() {
        for (let v of __vals(this)) {
            yield [v, v];
        }
    }
    *keys() {
        yield* __vals(this);
    }
    *values() {
        yield* __vals(this);
    }
    opts() {
        return { equiv: __private.get(this).equiv };
    }
}

const commonKeysMap = (a, b, out = []) => {
    for (let k of a.keys()) {
        b.has(k) && out.push(k);
    }
    return out;
};
const commonKeysObj = (a, b, out = []) => {
    for (let k in a) {
        b.hasOwnProperty(k) && out.push(k);
    }
    return out;
};

const empty = (x, ctor) => checks.implementsFunction(x, "empty")
    ? x.empty()
    : new (x[Symbol.species] || ctor)();
const copy = (x, ctor) => checks.implementsFunction(x, "copy")
    ? x.copy()
    : new (x[Symbol.species] || ctor)(x);
const first = (x) => x[Symbol.iterator]().next().value;
const objValues = (src) => {
    const vals = [];
    for (let k in src) {
        src.hasOwnProperty(k) && vals.push(src[k]);
    }
    return vals;
};
const ensureSet = (x) => checks.isSet(x) ? x : new Set(x);

const xformSetOp = (rfn, op, src) => src
    ? transducers.reduce(rfn(), src)
    : [
        () => null,
        (acc) => acc || new Set(),
        (acc, x) => (!acc ? ensureSet(x) : op(acc, ensureSet(x)))
    ];

const difference = (a, b, out) => {
    if (a === b) {
        return out || empty(a, Set);
    }
    out = out ? into(out, a) : copy(a, Set);
    for (let i of b) {
        out.delete(i);
    }
    return out;
};
function differenceR(src) {
    return xformSetOp(differenceR, difference, src);
}

const __private$1 = new WeakMap();
const __map = (map) => __private$1.get(map).map;
class EquivMap extends Map {
    static fromObject(obj, opts) {
        const m = new EquivMap(null, Object.assign({ equiv: (a, b) => a === b }, opts));
        for (let k in obj) {
            obj.hasOwnProperty(k) && m.set(k, obj[k]);
        }
        return m;
    }
    constructor(pairs, opts) {
        super();
        const _opts = Object.assign({ equiv: equiv.equiv, keys: ArraySet }, opts);
        __private$1.set(this, {
            keys: new _opts.keys(null, { equiv: _opts.equiv }),
            map: new Map(),
            opts: _opts
        });
        if (pairs) {
            this.into(pairs);
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    get [Symbol.species]() {
        return EquivMap;
    }
    get [Symbol.toStringTag]() {
        return "EquivMap";
    }
    get size() {
        return __private$1.get(this).keys.size;
    }
    clear() {
        const $this = __private$1.get(this);
        $this.keys.clear();
        $this.map.clear();
    }
    empty() {
        return new EquivMap(null, __private$1.get(this).opts);
    }
    copy() {
        const $this = __private$1.get(this);
        const m = new EquivMap();
        __private$1.set(m, {
            keys: $this.keys.copy(),
            map: new Map($this.map),
            opts: $this.opts
        });
        return m;
    }
    equiv(o) {
        return equivMap(this, o);
    }
    delete(key) {
        const $this = __private$1.get(this);
        key = $this.keys.get(key, api.SEMAPHORE);
        if (key !== api.SEMAPHORE) {
            $this.map.delete(key);
            $this.keys.delete(key);
            return true;
        }
        return false;
    }
    dissoc(keys) {
        return dissoc(this, keys);
    }
    forEach(fn, thisArg) {
        for (let pair of __map(this)) {
            fn.call(thisArg, pair[1], pair[0], this);
        }
    }
    get(key, notFound) {
        const $this = __private$1.get(this);
        key = $this.keys.get(key, api.SEMAPHORE);
        if (key !== api.SEMAPHORE) {
            return $this.map.get(key);
        }
        return notFound;
    }
    has(key) {
        return __private$1.get(this).keys.has(key);
    }
    set(key, value) {
        const $this = __private$1.get(this);
        const k = $this.keys.get(key, api.SEMAPHORE);
        if (k !== api.SEMAPHORE) {
            $this.map.set(k, value);
        }
        else {
            $this.keys.add(key);
            $this.map.set(key, value);
        }
        return this;
    }
    into(pairs) {
        return into(this, pairs);
    }
    entries() {
        return __map(this).entries();
    }
    keys() {
        return __map(this).keys();
    }
    values() {
        return __map(this).values();
    }
    opts() {
        return __private$1.get(this).opts;
    }
}

const __private$2 = new WeakMap();
const __iterator = (map, id) => function* () {
    for (let p of __private$2.get(map).bins) {
        if (p)
            yield p[id];
    }
};
const DEFAULT_CAP = 16;
class HashMap extends Map {
    constructor(pairs, opts) {
        super();
        const m = binary.ceilPow2(Math.min(opts.cap || DEFAULT_CAP, 4)) - 1;
        __private$2.set(this, {
            hash: opts.hash,
            equiv: opts.equiv || equiv.equiv,
            load: opts.load || 0.75,
            mask: m,
            bins: new Array(m + 1),
            size: 0
        });
        if (pairs) {
            this.into(pairs);
        }
    }
    get [Symbol.species]() {
        return HashMap;
    }
    get [Symbol.toStringTag]() {
        return "HashMap";
    }
    get size() {
        return __private$2.get(this).size;
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    *entries() {
        for (let p of __private$2.get(this).bins) {
            if (p)
                yield [p[0], p[1]];
        }
    }
    keys() {
        return __iterator(this, 0)();
    }
    values() {
        return __iterator(this, 1)();
    }
    forEach(fn, thisArg) {
        for (let pair of __private$2.get(this).bins) {
            fn.call(thisArg, pair[1], pair[0], this);
        }
    }
    clear() {
        const $this = __private$2.get(this);
        $this.bins = new Array(DEFAULT_CAP);
        $this.mask = 15;
        $this.size = 0;
    }
    empty() {
        return new HashMap(null, this.opts({ cap: DEFAULT_CAP }));
    }
    copy() {
        const $this = __private$2.get(this);
        const m = new HashMap(null, this.opts({ cap: 4 }));
        Object.assign(__private$2.get(m), {
            bins: $this.bins.slice(),
            mask: $this.mask,
            size: $this.size
        });
        return m;
    }
    equiv(o) {
        return equivMap(this, o);
    }
    has(key) {
        const $this = __private$2.get(this);
        const i = this.find(key, $this);
        return i >= 0 && $this.bins[i] != undefined;
    }
    get(key, notFound) {
        const $this = __private$2.get(this);
        const i = this.find(key, $this);
        return i >= 0 && $this.bins[i] ? $this.bins[i][1] : notFound;
    }
    set(key, val) {
        const $this = __private$2.get(this);
        let i = this.find(key, $this);
        if (i >= 0 && $this.bins[i]) {
            $this.bins[i][1] = val;
            return this;
        }
        if ($this.size > $this.mask * $this.load) {
            this.resize($this);
            i = this.find(key, $this);
        }
        $this.bins[i] = [key, val];
        $this.size++;
        return this;
    }
    delete(key) {
        const $this = __private$2.get(this);
        let i = this.find(key, $this);
        const bins = $this.bins;
        if (i >= 0 && !bins[i]) {
            return false;
        }
        $this.size--;
        const m = $this.mask;
        let j = i;
        let k;
        while (true) {
            delete bins[i];
            do {
                j = (j + 1) & m;
                if (!bins[j])
                    return true;
                k = $this.hash(bins[j][0]) & m;
            } while (i <= j ? i < k && k <= j : i < k || k <= j);
            bins[i] = bins[j];
            i = j;
        }
    }
    into(pairs) {
        return into(this, pairs);
    }
    dissoc(keys) {
        return dissoc(this, keys);
    }
    opts(overrides) {
        const $this = __private$2.get(this);
        return Object.assign({ hash: $this.hash, equiv: $this.equiv, load: $this.load, cap: $this.mask + 1 }, overrides);
    }
    find(key, $this) {
        const m = $this.mask;
        const bins = $this.bins;
        const equiv = $this.equiv;
        let i = m;
        let h = $this.hash(key) & m;
        while (bins[h] && !equiv(bins[h][0], key)) {
            i--;
            if (i < 0)
                return -1;
            h = (h + 1) & $this.mask;
        }
        return h;
    }
    resize($this) {
        const src = $this.bins;
        const cap = ($this.mask + 1) * 2;
        $this.bins = new Array(cap);
        $this.mask = cap - 1;
        $this.size = 0;
        for (let p of src) {
            if (p)
                this.set(p[0], p[1]);
        }
    }
}

const selectKeysMap = (src, ks) => {
    const dest = empty(src, Map);
    for (let k of ks) {
        src.has(k) && dest.set(k, src.get(k));
    }
    return dest;
};
const selectKeysObj = (src, ks) => {
    const dest = {};
    for (let k of ks) {
        src.hasOwnProperty(k) && (dest[k] = src[k]);
    }
    return dest;
};

const indexed = (records, ks) => {
    const res = new EquivMap();
    let x, ik, rv;
    for (x of records) {
        ik = selectKeysObj(x, ks);
        rv = res.get(ik);
        !rv && res.set(ik, (rv = empty(records, Set)));
        rv.add(x);
    }
    return res;
};

const intersection = (a, b, out) => {
    out = out || empty(a, Set);
    if (a === b) {
        return into(out, a);
    }
    if (b.size < a.size) {
        return intersection(b, a, out);
    }
    for (let i of b) {
        if (a.has(i)) {
            out.add(i);
        }
    }
    return out;
};
function intersectionR(src) {
    return xformSetOp(intersectionR, intersection, src);
}

const invertMap = (src, dest) => {
    dest = dest || new Map();
    for (let p of src) {
        dest.set(p[1], p[0]);
    }
    return dest;
};
const invertObj = (src, dest = {}) => {
    for (let k in src) {
        dest[src[k]] = k;
    }
    return dest;
};

const mergeMap = (dest, ...xs) => {
    for (let x of xs) {
        for (let pair of x) {
            dest.set(pair[0], pair[1]);
        }
    }
    return dest;
};
const mergeObj = (dest, ...xs) => Object.assign(dest, ...xs);

const renameKeysMap = (src, km, out) => {
    out = out || empty(src, Map);
    for (let [k, v] of src) {
        out.set(km.has(k) ? km.get(k) : k, v);
    }
    return out;
};
const renameKeysObj = (src, km, out = {}) => {
    for (let k in src) {
        out[km.hasOwnProperty(k) ? km[k] : k] = src[k];
    }
    return out;
};

const join = (a, b) => {
    if (a.size && b.size) {
        const ks = commonKeysObj(first(a) || {}, first(b) || {});
        let aa, bb;
        if (a.size <= b.size) {
            aa = a;
            bb = b;
        }
        else {
            aa = b;
            bb = a;
        }
        const idx = indexed(aa, ks);
        const res = empty(a, Set);
        for (let x of bb) {
            const found = idx.get(selectKeysObj(x, ks));
            if (found) {
                for (let f of found) {
                    res.add(mergeObj(Object.assign({}, f), x));
                }
            }
        }
        return res;
    }
    return empty(a, Set);
};
const joinWith = (a, b, kmap) => {
    if (a.size && b.size) {
        let aa, bb;
        let k;
        if (a.size <= b.size) {
            aa = a;
            bb = b;
            k = invertObj(kmap);
        }
        else {
            aa = b;
            bb = a;
            k = kmap;
        }
        const idx = indexed(aa, objValues(k));
        const ks = Object.keys(k);
        const res = empty(a, Set);
        for (let x of bb) {
            const found = idx.get(renameKeysObj(selectKeysObj(x, ks), k));
            if (found) {
                for (let f of found) {
                    res.add(mergeObj(Object.assign({}, f), x));
                }
            }
        }
        return res;
    }
    return empty(a, Set);
};
joinWith(new Set([{ a: 1, b: 2 }]), new Set([{ id: 1, c: 2 }]), { a: "id" });

const __private$3 = new WeakMap();
const __vals$1 = (inst) => __private$3.get(inst).vals;
class LLSet extends Set {
    constructor(vals, opts = {}) {
        super();
        __private$3.set(this, {
            equiv: opts.equiv || equiv.equiv,
            vals: new dcons.DCons()
        });
        vals && this.into(vals);
    }
    *[Symbol.iterator]() {
        yield* __vals$1(this);
    }
    get [Symbol.species]() {
        return LLSet;
    }
    get [Symbol.toStringTag]() {
        return "LLSet";
    }
    get size() {
        return __vals$1(this).length;
    }
    copy() {
        const $this = __private$3.get(this);
        const s = new LLSet(null, this.opts());
        __private$3.get(s).vals = $this.vals.copy();
        return s;
    }
    empty() {
        return new LLSet(null, this.opts());
    }
    clear() {
        __vals$1(this).clear();
    }
    first() {
        if (this.size) {
            return __vals$1(this).head.value;
        }
    }
    add(key) {
        !this.has(key) && __vals$1(this).push(key);
        return this;
    }
    into(keys) {
        return into(this, keys);
    }
    has(key) {
        return this.get(key, api.SEMAPHORE) !== api.SEMAPHORE;
    }
    get(key, notFound) {
        const $this = __private$3.get(this);
        const eq = $this.equiv;
        let i = $this.vals.head;
        while (i) {
            if (eq(i.value, key)) {
                return i.value;
            }
            i = i.next;
        }
        return notFound;
    }
    delete(key) {
        const $this = __private$3.get(this);
        const eq = $this.equiv;
        let i = $this.vals.head;
        while (i) {
            if (eq(i.value, key)) {
                $this.vals.splice(i, 1);
                return true;
            }
            i = i.next;
        }
        return false;
    }
    disj(keys) {
        return dissoc(this, keys);
    }
    equiv(o) {
        return equivSet(this, o);
    }
    forEach(fn, thisArg) {
        let i = __vals$1(this).head;
        while (i) {
            fn.call(thisArg, i.value, i.value, this);
            i = i.next;
        }
    }
    *entries() {
        for (let v of __vals$1(this)) {
            yield [v, v];
        }
    }
    *keys() {
        yield* __vals$1(this);
    }
    *values() {
        yield* __vals$1(this);
    }
    opts() {
        return { equiv: __private$3.get(this).equiv };
    }
}

const mergeApplyMap = (src, xs) => {
    const res = copy(src, Map);
    for (let [k, v] of xs) {
        res.set(k, checks.isFunction(v) ? v(res.get(k)) : v);
    }
    return res;
};
const mergeApplyObj = (src, xs) => {
    const res = Object.assign({}, src);
    for (let k in xs) {
        const v = xs[k];
        res[k] = checks.isFunction(v) ? v(res[k]) : v;
    }
    return res;
};

const mergeMapWith = (f, dest, ...xs) => {
    const res = copy(dest, Map);
    for (let x of xs) {
        for (let [k, v] of x) {
            res.set(k, res.has(k) ? f(res.get(k), v) : v);
        }
    }
    return res;
};
const mergeObjWith = (f, dest, ...xs) => {
    const res = Object.assign({}, dest);
    for (let x of xs) {
        for (let k in x) {
            const v = x[k];
            res[k] = res.hasOwnProperty(k) ? f(dest[k], v) : v;
        }
    }
    return res;
};

const mergeDeepObj = (dest, ...xs) => mergeObjWith((a, b) => checks.isPlainObject(a) && checks.isPlainObject(b) ? mergeDeepObj(a, b) : b, dest, ...xs);

class Node {
    constructor(k, v, h) {
        this.k = k;
        this.v = v;
        this.next = new Array(h + 1);
    }
}
const __private$4 = new WeakMap();
class SortedMap extends Map {
    constructor(pairs, opts = {}) {
        super();
        const cap = opts.capacity || SortedMap.DEFAULT_CAP;
        const maxh = Math.ceil(Math.log2(cap));
        __private$4.set(this, {
            head: new Node(null, null, 0),
            cap: Math.pow(2, maxh),
            cmp: opts.compare || compare.compare,
            p: opts.probability || SortedMap.DEFAULT_P,
            maxh,
            length: 0,
            h: 0
        });
        if (pairs) {
            this.into(pairs);
        }
    }
    static fromObject(obj, opts) {
        const m = new SortedMap(null, Object.assign({ capacity: Object.keys(obj).length }, opts));
        for (let k in obj) {
            obj.hasOwnProperty(k) && m.set(k, obj[k]);
        }
        return m;
    }
    get [Symbol.species]() {
        return SortedMap;
    }
    *[Symbol.iterator]() {
        let node = __private$4.get(this).head;
        while ((node = node.next[0])) {
            yield [node.k, node.v];
        }
    }
    *entries(key, max = false) {
        const $this = __private$4.get(this);
        let node = $this.head;
        const cmp = $this.cmp;
        let code;
        if (max) {
            while ((node = node.next[0])) {
                if (key === undefined || (code = cmp(node.k, key)) <= 0) {
                    yield [node.k, node.v];
                    if (code === 0)
                        return;
                }
            }
        }
        else {
            while ((node = node.next[0])) {
                if (key === undefined || (code = cmp(node.k, key)) >= 0) {
                    yield [node.k, node.v];
                }
            }
        }
    }
    keys(key, max = false) {
        return transducers.map((p) => p[0], this.entries(key, max));
    }
    values(key, max = false) {
        return transducers.map((p) => p[1], this.entries(key, max));
    }
    get size() {
        return __private$4.get(this).length;
    }
    clear() {
        const $this = __private$4.get(this);
        $this.head = new Node(null, null, 0);
        $this.length = 0;
        $this.h = 0;
    }
    empty() {
        return new SortedMap(null, Object.assign(Object.assign({}, this.opts()), { capacity: SortedMap.DEFAULT_CAP }));
    }
    copy() {
        return new SortedMap(this, this.opts());
    }
    compare(o) {
        const n = this.size;
        const m = o.size;
        if (n < m)
            return -1;
        if (n > m)
            return 1;
        const i = this.entries();
        const j = o.entries();
        let x, y;
        let c;
        while (((x = i.next()), (y = j.next()), !x.done && !y.done)) {
            if ((c = compare.compare(x.value[0], y.value[0])) !== 0 ||
                (c = compare.compare(x.value[1], y.value[1])) !== 0) {
                return c;
            }
        }
        return 0;
    }
    equiv(o) {
        return equivMap(this, o);
    }
    first() {
        const node = __private$4.get(this).head.next[0];
        return node ? [node.k, node.v] : undefined;
    }
    get(k, notFound) {
        const node = this.findPredNode(k).next[0];
        return node && __private$4.get(this).cmp(node.k, k) === 0
            ? node.v
            : notFound;
    }
    has(key) {
        return this.get(key, api.SEMAPHORE) !== api.SEMAPHORE;
    }
    set(k, v) {
        const $this = __private$4.get(this);
        let node = $this.head;
        let level = $this.h;
        let stack = new Array(level);
        const cmp = $this.cmp;
        let code;
        while (level >= 0) {
            while (node.next[level] &&
                (code = cmp(node.next[level].k, k)) < 0) {
                node = node.next[level];
            }
            if (node.next[level] && code === 0) {
                do {
                    node.next[level].v = v;
                } while (--level >= 0);
                return this;
            }
            stack[level--] = node;
        }
        const h = this.pickHeight($this.maxh, $this.h, $this.p);
        node = new Node(k, v, h);
        while ($this.h < h) {
            stack[++$this.h] = $this.head;
        }
        for (let i = 0; i <= h; i++) {
            node.next[i] = stack[i].next[i];
            stack[i].next[i] = node;
        }
        $this.length++;
        if ($this.length >= $this.cap) {
            $this.cap *= 2;
            $this.maxh++;
        }
        return this;
    }
    delete(k) {
        const $this = __private$4.get(this);
        let node = $this.head;
        let level = $this.h;
        let removed = false;
        const cmp = $this.cmp;
        let code;
        while (level >= 0) {
            while (node.next[level] &&
                (code = cmp(node.next[level].k, k)) < 0) {
                node = node.next[level];
            }
            if (node.next[level] && code === 0) {
                removed = true;
                node.next[level] = node.next[level].next[level];
                if (node == $this.head && !node.next[level]) {
                    $this.h = Math.max(0, $this.h - 1);
                }
            }
            level--;
        }
        if (removed)
            $this.length--;
        return removed;
    }
    into(pairs) {
        return into(this, pairs);
    }
    dissoc(keys) {
        return dissoc(this, keys);
    }
    forEach(fn, thisArg) {
        for (let p of this) {
            fn.call(thisArg, p[1], p[0], this);
        }
    }
    $reduce(rfn, acc) {
        let node = __private$4.get(this).head;
        while ((node = node.next[0]) && !transducers.isReduced(acc)) {
            acc = rfn(acc, [node.k, node.v]);
        }
        return acc;
    }
    opts() {
        const $this = __private$4.get(this);
        return {
            capacity: $this.cap,
            compare: $this.cmp,
            probability: $this.p
        };
    }
    findPredNode(k) {
        const $this = __private$4.get(this);
        const cmp = $this.cmp;
        let node = $this.head;
        let level = $this.h;
        while (level >= 0) {
            while (node.next[level] && cmp(node.next[level].k, k) < 0) {
                node = node.next[level];
            }
            level--;
        }
        return node;
    }
    pickHeight(maxh, h, p) {
        const max = Math.min(maxh, h + 1);
        let level = 0;
        while (Math.random() < p && level < max) {
            level++;
        }
        return level;
    }
}
SortedMap.DEFAULT_CAP = 8;
SortedMap.DEFAULT_P = 1 / Math.E;

const __private$5 = new WeakMap();
class SortedSet extends Set {
    constructor(values, opts) {
        super();
        __private$5.set(this, new SortedMap(values ? transducers.map((x) => [x, x], values) : null, opts));
    }
    [Symbol.iterator]() {
        return this.keys();
    }
    get [Symbol.species]() {
        return SortedSet;
    }
    get [Symbol.toStringTag]() {
        return "SortedSet";
    }
    get size() {
        return __private$5.get(this).size;
    }
    copy() {
        return new SortedSet(this.keys(), this.opts());
    }
    empty() {
        return new SortedSet(null, Object.assign(Object.assign({}, this.opts()), { capacity: SortedMap.DEFAULT_CAP }));
    }
    compare(o) {
        const n = this.size;
        const m = o.size;
        if (n < m)
            return -1;
        if (n > m)
            return 1;
        const i = this.entries();
        const j = o.entries();
        let x, y;
        let c;
        while (((x = i.next()), (y = j.next()), !x.done && !y.done)) {
            if ((c = compare.compare(x.value[0], y.value[0])) !== 0) {
                return c;
            }
        }
        return 0;
    }
    equiv(o) {
        return equivSet(this, o);
    }
    $reduce(rfn, acc) {
        return __private$5.get(this).$reduce((_acc, x) => rfn(_acc, x[0]), acc);
    }
    entries(key, max = false) {
        return __private$5.get(this).entries(key, max);
    }
    keys(key, max = false) {
        return __private$5.get(this).keys(key, max);
    }
    values(key, max = false) {
        return __private$5.get(this).values(key, max);
    }
    add(key) {
        __private$5.get(this).set(key, key);
        return this;
    }
    into(keys) {
        return into(this, keys);
    }
    clear() {
        __private$5.get(this).clear();
    }
    first() {
        const first = __private$5.get(this).first();
        return first ? first[0] : undefined;
    }
    delete(key) {
        return __private$5.get(this).delete(key);
    }
    disj(keys) {
        return dissoc(this, keys);
    }
    forEach(fn, thisArg) {
        for (let p of this) {
            fn.call(thisArg, p, p, this);
        }
    }
    has(key) {
        return __private$5.get(this).has(key);
    }
    get(key, notFound) {
        return __private$5.get(this).get(key, notFound);
    }
    opts() {
        return __private$5.get(this).opts();
    }
}

const __private$6 = new WeakMap();
const fail = () => errors.illegalArgs(`dense & sparse arrays must be of same size`);
class ASparseSet extends Set {
    constructor(dense, sparse) {
        super();
        __private$6.set(this, { dense, sparse, n: 0 });
    }
    [Symbol.iterator]() {
        return this.keys();
    }
    get size() {
        return __private$6.get(this).n;
    }
    get capacity() {
        return __private$6.get(this).dense.length;
    }
    clear() {
        __private$6.get(this).n = 0;
    }
    equiv(o) {
        if (this === o) {
            return true;
        }
        if (!(o instanceof Set) || this.size !== o.size) {
            return false;
        }
        const $this = __private$6.get(this);
        const d = $this.dense;
        for (let i = $this.n; --i >= 0;) {
            if (!o.has(d[i])) {
                return false;
            }
        }
        return true;
    }
    add(key) {
        const $this = __private$6.get(this);
        const dense = $this.dense;
        const sparse = $this.sparse;
        const max = dense.length;
        const i = sparse[key];
        const n = $this.n;
        if (key < max && n < max && !(i < n && dense[i] === key)) {
            dense[n] = key;
            sparse[key] = n;
            $this.n++;
        }
        return this;
    }
    delete(key) {
        const $this = __private$6.get(this);
        const dense = $this.dense;
        const sparse = $this.sparse;
        const i = sparse[key];
        if (i < $this.n && dense[i] === key) {
            const j = dense[--$this.n];
            dense[i] = j;
            sparse[j] = i;
            return true;
        }
        return false;
    }
    has(key) {
        const $this = __private$6.get(this);
        const i = $this.sparse[key];
        return i < $this.n && $this.dense[i] === key;
    }
    get(key, notFound = -1) {
        return this.has(key) ? key : notFound;
    }
    first() {
        const $this = __private$6.get(this);
        return $this.n ? $this.dense[0] : undefined;
    }
    into(keys) {
        return into(this, keys);
    }
    disj(keys) {
        return dissoc(this, keys);
    }
    forEach(fn, thisArg) {
        const $this = __private$6.get(this);
        const d = $this.dense;
        const n = $this.n;
        for (let i = 0; i < n; i++) {
            const v = d[i];
            fn.call(thisArg, v, v, this);
        }
    }
    *entries() {
        const $this = __private$6.get(this);
        const d = $this.dense;
        const n = $this.n;
        for (let i = 0; i < n; i++) {
            yield [d[i], d[i]];
        }
    }
    *keys() {
        const $this = __private$6.get(this);
        const d = $this.dense;
        const n = $this.n;
        for (let i = 0; i < n; i++) {
            yield d[i];
        }
    }
    values() {
        return this.keys();
    }
    __copyTo(dest) {
        const $this = __private$6.get(this);
        const $c = __private$6.get(dest);
        $c.dense = $this.dense.slice();
        $c.sparse = $this.sparse.slice();
        $c.n = $this.n;
        return dest;
    }
}
class SparseSet8 extends ASparseSet {
    constructor(n, sparse) {
        checks.isNumber(n)
            ? super(new Uint8Array(n), new Uint8Array(n))
            : n.length === sparse.length
                ? super(n, sparse)
                : fail();
    }
    get [Symbol.species]() {
        return SparseSet8;
    }
    get [Symbol.toStringTag]() {
        return "SparseSet8";
    }
    copy() {
        return this.__copyTo(new SparseSet8(0));
    }
    empty() {
        return new SparseSet8(this.capacity);
    }
}
class SparseSet16 extends ASparseSet {
    constructor(n, sparse) {
        checks.isNumber(n)
            ? super(new Uint16Array(n), new Uint16Array(n))
            : n.length === sparse.length
                ? super(n, sparse)
                : fail();
    }
    get [Symbol.species]() {
        return SparseSet16;
    }
    get [Symbol.toStringTag]() {
        return "SparseSet16";
    }
    copy() {
        return this.__copyTo(new SparseSet16(0));
    }
    empty() {
        return new SparseSet16(this.capacity);
    }
}
class SparseSet32 extends ASparseSet {
    constructor(n, sparse) {
        checks.isNumber(n)
            ? super(new Uint32Array(n), new Uint32Array(n))
            : n.length === sparse.length
                ? super(n, sparse)
                : fail();
    }
    get [Symbol.species]() {
        return SparseSet32;
    }
    get [Symbol.toStringTag]() {
        return "SparseSet32";
    }
    copy() {
        return this.__copyTo(new SparseSet32(0));
    }
    empty() {
        return new SparseSet32(this.capacity);
    }
}
const sparseSet = (n) => n <= 0x100
    ? new SparseSet8(n)
    : n <= 0x10000
        ? new SparseSet16(n)
        : new SparseSet32(n);

const union = (a, b, out) => {
    if (a.size < b.size) {
        const t = a;
        a = b;
        b = t;
    }
    out = out ? into(out, a) : copy(a, Set);
    return a === b ? out : into(out, b);
};
function unionR(src) {
    return xformSetOp(unionR, union, src);
}

const withoutKeysMap = (src, keys) => {
    const ks = ensureSet(keys);
    const dest = empty(src, Map);
    for (let p of src.entries()) {
        const k = p[0];
        !ks.has(k) && dest.set(k, p[1]);
    }
    return dest;
};
const withoutKeysObj = (src, keys) => {
    const ks = ensureSet(keys);
    const dest = {};
    for (let k in src) {
        src.hasOwnProperty(k) && !ks.has(k) && (dest[k] = src[k]);
    }
    return dest;
};

exports.ASparseSet = ASparseSet;
exports.ArraySet = ArraySet;
exports.EquivMap = EquivMap;
exports.HashMap = HashMap;
exports.LLSet = LLSet;
exports.SortedMap = SortedMap;
exports.SortedSet = SortedSet;
exports.SparseSet16 = SparseSet16;
exports.SparseSet32 = SparseSet32;
exports.SparseSet8 = SparseSet8;
exports.commonKeysMap = commonKeysMap;
exports.commonKeysObj = commonKeysObj;
exports.difference = difference;
exports.differenceR = differenceR;
exports.dissoc = dissoc;
exports.dissocObj = dissocObj;
exports.indexed = indexed;
exports.intersection = intersection;
exports.intersectionR = intersectionR;
exports.into = into;
exports.invertMap = invertMap;
exports.invertObj = invertObj;
exports.join = join;
exports.joinWith = joinWith;
exports.mergeApplyMap = mergeApplyMap;
exports.mergeApplyObj = mergeApplyObj;
exports.mergeDeepObj = mergeDeepObj;
exports.mergeMap = mergeMap;
exports.mergeMapWith = mergeMapWith;
exports.mergeObj = mergeObj;
exports.mergeObjWith = mergeObjWith;
exports.renameKeysMap = renameKeysMap;
exports.renameKeysObj = renameKeysObj;
exports.selectKeysMap = selectKeysMap;
exports.selectKeysObj = selectKeysObj;
exports.sparseSet = sparseSet;
exports.union = union;
exports.unionR = unionR;
exports.withoutKeysMap = withoutKeysMap;
exports.withoutKeysObj = withoutKeysObj;
