!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@thi.ng/api"),require("@thi.ng/equiv"),require("@thi.ng/checks"),require("@thi.ng/transducers"),require("@thi.ng/binary"),require("@thi.ng/dcons"),require("@thi.ng/compare"),require("@thi.ng/errors")):"function"==typeof define&&define.amd?define(["exports","@thi.ng/api","@thi.ng/equiv","@thi.ng/checks","@thi.ng/transducers","@thi.ng/binary","@thi.ng/dcons","@thi.ng/compare","@thi.ng/errors"],t):t(((e=e||self).thi=e.thi||{},e.thi.ng=e.thi.ng||{},e.thi.ng.associative={}),e.thi.ng.api,e.thi.ng.equiv,e.thi.ng.checks,e.thi.ng.transducers,e.thi.ng.binary,e.thi.ng.dcons,e.thi.ng.compare,e.thi.ng.errors)}(this,(function(e,t,s,r,n,i,o,h,a){"use strict";function u(e,t){for(let s of t)e.delete(s);return e}const c=(e,t)=>{if(e===t)return!0;if(!(t instanceof Map)||e.size!==t.size)return!1;for(let r of e.entries())if(!s.equiv(t.get(r[0]),r[1]))return!1;return!0},l=(e,t)=>{if(e===t)return!0;if(!(t instanceof Set)||e.size!==t.size)return!1;for(let s of e.keys())if(!t.has(s))return!1;return!0};function g(e,t){if(r.isMap(e))for(let s of t)e.set(s[0],s[1]);else for(let s of t)e.add(s);return e}const p=new WeakMap,f=e=>p.get(e).vals;class d extends Set{constructor(e,t={}){super(),p.set(this,{equiv:t.equiv||s.equiv,vals:[]}),e&&this.into(e)}*[Symbol.iterator](){yield*f(this)}get[Symbol.species](){return d}get[Symbol.toStringTag](){return"ArraySet"}get size(){return f(this).length}copy(){const e=p.get(this),t=new d(null,{equiv:e.equiv});return p.get(t).vals=e.vals.slice(),t}empty(){return new d(null,this.opts())}clear(){f(this).length=0}first(){if(this.size)return f(this)[0]}add(e){return!this.has(e)&&f(this).push(e),this}into(e){return g(this,e)}has(e){return this.get(e,t.SEMAPHORE)!==t.SEMAPHORE}get(e,t){const s=p.get(this),r=s.equiv,n=s.vals;for(let t=n.length;--t>=0;)if(r(n[t],e))return n[t];return t}delete(e){const t=p.get(this),s=t.equiv,r=t.vals;for(let t=r.length;--t>=0;)if(s(r[t],e))return r.splice(t,1),!0;return!1}disj(e){return u(this,e)}equiv(e){return l(this,e)}forEach(e,t){const s=f(this);for(let r=s.length;--r>=0;){const n=s[r];e.call(t,n,n,this)}}*entries(){for(let e of f(this))yield[e,e]}*keys(){yield*f(this)}*values(){yield*f(this)}opts(){return{equiv:p.get(this).equiv}}}const y=(e,t,s=[])=>{for(let r in e)t.hasOwnProperty(r)&&s.push(r);return s},m=(e,t)=>r.implementsFunction(e,"empty")?e.empty():new(e[Symbol.species]||t),v=(e,t)=>r.implementsFunction(e,"copy")?e.copy():new(e[Symbol.species]||t)(e),S=e=>e[Symbol.iterator]().next().value,b=e=>r.isSet(e)?e:new Set(e),w=(e,t,s)=>s?n.reduce(e(),s):[()=>null,e=>e||new Set,(e,s)=>e?t(e,b(s)):b(s)],k=(e,t,s)=>{if(e===t)return s||m(e,Set);s=s?g(s,e):v(e,Set);for(let e of t)s.delete(e);return s};const M=new WeakMap,x=e=>M.get(e).map;class O extends Map{static fromObject(e,t){const s=new O(null,Object.assign({equiv:(e,t)=>e===t},t));for(let t in e)e.hasOwnProperty(t)&&s.set(t,e[t]);return s}constructor(e,t){super();const r=Object.assign({equiv:s.equiv,keys:d},t);M.set(this,{keys:new r.keys(null,{equiv:r.equiv}),map:new Map,opts:r}),e&&this.into(e)}[Symbol.iterator](){return this.entries()}get[Symbol.species](){return O}get[Symbol.toStringTag](){return"EquivMap"}get size(){return M.get(this).keys.size}clear(){const e=M.get(this);e.keys.clear(),e.map.clear()}empty(){return new O(null,M.get(this).opts)}copy(){const e=M.get(this),t=new O;return M.set(t,{keys:e.keys.copy(),map:new Map(e.map),opts:e.opts}),t}equiv(e){return c(this,e)}delete(e){const s=M.get(this);return(e=s.keys.get(e,t.SEMAPHORE))!==t.SEMAPHORE&&(s.map.delete(e),s.keys.delete(e),!0)}dissoc(e){return u(this,e)}forEach(e,t){for(let s of x(this))e.call(t,s[1],s[0],this)}get(e,s){const r=M.get(this);return(e=r.keys.get(e,t.SEMAPHORE))!==t.SEMAPHORE?r.map.get(e):s}has(e){return M.get(this).keys.has(e)}set(e,s){const r=M.get(this),n=r.keys.get(e,t.SEMAPHORE);return n!==t.SEMAPHORE?r.map.set(n,s):(r.keys.add(e),r.map.set(e,s)),this}into(e){return g(this,e)}entries(){return x(this).entries()}keys(){return x(this).keys()}values(){return x(this).values()}opts(){return M.get(this).opts}}const q=new WeakMap,z=(e,t)=>function*(){for(let s of q.get(e).bins)s&&(yield s[t])};class E extends Map{constructor(e,t){super();const r=i.ceilPow2(Math.min(t.cap||16,4))-1;q.set(this,{hash:t.hash,equiv:t.equiv||s.equiv,load:t.load||.75,mask:r,bins:new Array(r+1),size:0}),e&&this.into(e)}get[Symbol.species](){return E}get[Symbol.toStringTag](){return"HashMap"}get size(){return q.get(this).size}[Symbol.iterator](){return this.entries()}*entries(){for(let e of q.get(this).bins)e&&(yield[e[0],e[1]])}keys(){return z(this,0)()}values(){return z(this,1)()}forEach(e,t){for(let s of q.get(this).bins)e.call(t,s[1],s[0],this)}clear(){const e=q.get(this);e.bins=new Array(16),e.mask=15,e.size=0}empty(){return new E(null,this.opts({cap:16}))}copy(){const e=q.get(this),t=new E(null,this.opts({cap:4}));return Object.assign(q.get(t),{bins:e.bins.slice(),mask:e.mask,size:e.size}),t}equiv(e){return c(this,e)}has(e){const t=q.get(this),s=this.find(e,t);return s>=0&&null!=t.bins[s]}get(e,t){const s=q.get(this),r=this.find(e,s);return r>=0&&s.bins[r]?s.bins[r][1]:t}set(e,t){const s=q.get(this);let r=this.find(e,s);return r>=0&&s.bins[r]?(s.bins[r][1]=t,this):(s.size>s.mask*s.load&&(this.resize(s),r=this.find(e,s)),s.bins[r]=[e,t],s.size++,this)}delete(e){const t=q.get(this);let s=this.find(e,t);const r=t.bins;if(s>=0&&!r[s])return!1;t.size--;const n=t.mask;let i,o=s;for(;;){delete r[s];do{if(o=o+1&n,!r[o])return!0;i=t.hash(r[o][0])&n}while(s<=o?s<i&&i<=o:s<i||i<=o);r[s]=r[o],s=o}}into(e){return g(this,e)}dissoc(e){return u(this,e)}opts(e){const t=q.get(this);return Object.assign({hash:t.hash,equiv:t.equiv,load:t.load,cap:t.mask+1},e)}find(e,t){const s=t.mask,r=t.bins,n=t.equiv;let i=s,o=t.hash(e)&s;for(;r[o]&&!n(r[o][0],e);){if(i--,i<0)return-1;o=o+1&t.mask}return o}resize(e){const t=e.bins,s=2*(e.mask+1);e.bins=new Array(s),e.mask=s-1,e.size=0;for(let e of t)e&&this.set(e[0],e[1])}}const A=(e,t)=>{const s={};for(let r of t)e.hasOwnProperty(r)&&(s[r]=e[r]);return s},j=(e,t)=>{const s=new O;let r,n,i;for(r of e)n=A(r,t),i=s.get(n),!i&&s.set(n,i=m(e,Set)),i.add(r);return s},P=(e,t,s)=>{if(s=s||m(e,Set),e===t)return g(s,e);if(t.size<e.size)return P(t,e,s);for(let r of t)e.has(r)&&s.add(r);return s};const T=(e,t={})=>{for(let s in e)t[e[s]]=s;return t},H=(e,...t)=>Object.assign(e,...t),R=(e,t,s={})=>{for(let r in e)s[t.hasOwnProperty(r)?t[r]:r]=e[r];return s},_=(e,t,s)=>{if(e.size&&t.size){let r,n,i;e.size<=t.size?(r=e,n=t,i=T(s)):(r=t,n=e,i=s);const o=j(r,(e=>{const t=[];for(let s in e)e.hasOwnProperty(s)&&t.push(e[s]);return t})(i)),h=Object.keys(i),a=m(e,Set);for(let e of n){const t=o.get(R(A(e,h),i));if(t)for(let s of t)a.add(H(Object.assign({},s),e))}return a}return m(e,Set)};_(new Set([{a:1,b:2}]),new Set([{id:1,c:2}]),{a:"id"});const U=new WeakMap,F=e=>U.get(e).vals;class L extends Set{constructor(e,t={}){super(),U.set(this,{equiv:t.equiv||s.equiv,vals:new o.DCons}),e&&this.into(e)}*[Symbol.iterator](){yield*F(this)}get[Symbol.species](){return L}get[Symbol.toStringTag](){return"LLSet"}get size(){return F(this).length}copy(){const e=U.get(this),t=new L(null,this.opts());return U.get(t).vals=e.vals.copy(),t}empty(){return new L(null,this.opts())}clear(){F(this).clear()}first(){if(this.size)return F(this).head.value}add(e){return!this.has(e)&&F(this).push(e),this}into(e){return g(this,e)}has(e){return this.get(e,t.SEMAPHORE)!==t.SEMAPHORE}get(e,t){const s=U.get(this),r=s.equiv;let n=s.vals.head;for(;n;){if(r(n.value,e))return n.value;n=n.next}return t}delete(e){const t=U.get(this),s=t.equiv;let r=t.vals.head;for(;r;){if(s(r.value,e))return t.vals.splice(r,1),!0;r=r.next}return!1}disj(e){return u(this,e)}equiv(e){return l(this,e)}forEach(e,t){let s=F(this).head;for(;s;)e.call(t,s.value,s.value,this),s=s.next}*entries(){for(let e of F(this))yield[e,e]}*keys(){yield*F(this)}*values(){yield*F(this)}opts(){return{equiv:U.get(this).equiv}}}const W=(e,t,...s)=>{const r=Object.assign({},t);for(let n of s)for(let s in n){const i=n[s];r[s]=r.hasOwnProperty(s)?e(t[s],i):i}return r},D=(e,...t)=>W((e,t)=>r.isPlainObject(e)&&r.isPlainObject(t)?D(e,t):t,e,...t);class K{constructor(e,t,s){this.k=e,this.v=t,this.next=new Array(s+1)}}const C=new WeakMap;class N extends Map{constructor(e,t={}){super();const s=t.capacity||N.DEFAULT_CAP,r=Math.ceil(Math.log2(s));C.set(this,{head:new K(null,null,0),cap:Math.pow(2,r),cmp:t.compare||h.compare,p:t.probability||N.DEFAULT_P,maxh:r,length:0,h:0}),e&&this.into(e)}static fromObject(e,t){const s=new N(null,Object.assign({capacity:Object.keys(e).length},t));for(let t in e)e.hasOwnProperty(t)&&s.set(t,e[t]);return s}get[Symbol.species](){return N}*[Symbol.iterator](){let e=C.get(this).head;for(;e=e.next[0];)yield[e.k,e.v]}*entries(e,t=!1){const s=C.get(this);let r=s.head;const n=s.cmp;let i;if(t){for(;r=r.next[0];)if((void 0===e||(i=n(r.k,e))<=0)&&(yield[r.k,r.v],0===i))return}else for(;r=r.next[0];)(void 0===e||(i=n(r.k,e))>=0)&&(yield[r.k,r.v])}keys(e,t=!1){return n.map(e=>e[0],this.entries(e,t))}values(e,t=!1){return n.map(e=>e[1],this.entries(e,t))}get size(){return C.get(this).length}clear(){const e=C.get(this);e.head=new K(null,null,0),e.length=0,e.h=0}empty(){return new N(null,Object.assign(Object.assign({},this.opts()),{capacity:N.DEFAULT_CAP}))}copy(){return new N(this,this.opts())}compare(e){const t=this.size,s=e.size;if(t<s)return-1;if(t>s)return 1;const r=this.entries(),n=e.entries();let i,o,a;for(;i=r.next(),o=n.next(),!i.done&&!o.done;)if(0!==(a=h.compare(i.value[0],o.value[0]))||0!==(a=h.compare(i.value[1],o.value[1])))return a;return 0}equiv(e){return c(this,e)}first(){const e=C.get(this).head.next[0];return e?[e.k,e.v]:void 0}get(e,t){const s=this.findPredNode(e).next[0];return s&&0===C.get(this).cmp(s.k,e)?s.v:t}has(e){return this.get(e,t.SEMAPHORE)!==t.SEMAPHORE}set(e,t){const s=C.get(this);let r=s.head,n=s.h,i=new Array(n);const o=s.cmp;let h;for(;n>=0;){for(;r.next[n]&&(h=o(r.next[n].k,e))<0;)r=r.next[n];if(r.next[n]&&0===h){do{r.next[n].v=t}while(--n>=0);return this}i[n--]=r}const a=this.pickHeight(s.maxh,s.h,s.p);for(r=new K(e,t,a);s.h<a;)i[++s.h]=s.head;for(let e=0;e<=a;e++)r.next[e]=i[e].next[e],i[e].next[e]=r;return s.length++,s.length>=s.cap&&(s.cap*=2,s.maxh++),this}delete(e){const t=C.get(this);let s=t.head,r=t.h,n=!1;const i=t.cmp;let o;for(;r>=0;){for(;s.next[r]&&(o=i(s.next[r].k,e))<0;)s=s.next[r];s.next[r]&&0===o&&(n=!0,s.next[r]=s.next[r].next[r],s!=t.head||s.next[r]||(t.h=Math.max(0,t.h-1))),r--}return n&&t.length--,n}into(e){return g(this,e)}dissoc(e){return u(this,e)}forEach(e,t){for(let s of this)e.call(t,s[1],s[0],this)}$reduce(e,t){let s=C.get(this).head;for(;(s=s.next[0])&&!n.isReduced(t);)t=e(t,[s.k,s.v]);return t}opts(){const e=C.get(this);return{capacity:e.cap,compare:e.cmp,probability:e.p}}findPredNode(e){const t=C.get(this),s=t.cmp;let r=t.head,n=t.h;for(;n>=0;){for(;r.next[n]&&s(r.next[n].k,e)<0;)r=r.next[n];n--}return r}pickHeight(e,t,s){const r=Math.min(e,t+1);let n=0;for(;Math.random()<s&&n<r;)n++;return n}}N.DEFAULT_CAP=8,N.DEFAULT_P=1/Math.E;const $=new WeakMap;class B extends Set{constructor(e,t){super(),$.set(this,new N(e?n.map(e=>[e,e],e):null,t))}[Symbol.iterator](){return this.keys()}get[Symbol.species](){return B}get[Symbol.toStringTag](){return"SortedSet"}get size(){return $.get(this).size}copy(){return new B(this.keys(),this.opts())}empty(){return new B(null,Object.assign(Object.assign({},this.opts()),{capacity:N.DEFAULT_CAP}))}compare(e){const t=this.size,s=e.size;if(t<s)return-1;if(t>s)return 1;const r=this.entries(),n=e.entries();let i,o,a;for(;i=r.next(),o=n.next(),!i.done&&!o.done;)if(0!==(a=h.compare(i.value[0],o.value[0])))return a;return 0}equiv(e){return l(this,e)}$reduce(e,t){return $.get(this).$reduce((t,s)=>e(t,s[0]),t)}entries(e,t=!1){return $.get(this).entries(e,t)}keys(e,t=!1){return $.get(this).keys(e,t)}values(e,t=!1){return $.get(this).values(e,t)}add(e){return $.get(this).set(e,e),this}into(e){return g(this,e)}clear(){$.get(this).clear()}first(){const e=$.get(this).first();return e?e[0]:void 0}delete(e){return $.get(this).delete(e)}disj(e){return u(this,e)}forEach(e,t){for(let s of this)e.call(t,s,s,this)}has(e){return $.get(this).has(e)}get(e,t){return $.get(this).get(e,t)}opts(){return $.get(this).opts()}}const G=new WeakMap,I=()=>a.illegalArgs("dense & sparse arrays must be of same size");class J extends Set{constructor(e,t){super(),G.set(this,{dense:e,sparse:t,n:0})}[Symbol.iterator](){return this.keys()}get size(){return G.get(this).n}get capacity(){return G.get(this).dense.length}clear(){G.get(this).n=0}equiv(e){if(this===e)return!0;if(!(e instanceof Set)||this.size!==e.size)return!1;const t=G.get(this),s=t.dense;for(let r=t.n;--r>=0;)if(!e.has(s[r]))return!1;return!0}add(e){const t=G.get(this),s=t.dense,r=t.sparse,n=s.length,i=r[e],o=t.n;return e<n&&o<n&&!(i<o&&s[i]===e)&&(s[o]=e,r[e]=o,t.n++),this}delete(e){const t=G.get(this),s=t.dense,r=t.sparse,n=r[e];if(n<t.n&&s[n]===e){const e=s[--t.n];return s[n]=e,r[e]=n,!0}return!1}has(e){const t=G.get(this),s=t.sparse[e];return s<t.n&&t.dense[s]===e}get(e,t=-1){return this.has(e)?e:t}first(){const e=G.get(this);return e.n?e.dense[0]:void 0}into(e){return g(this,e)}disj(e){return u(this,e)}forEach(e,t){const s=G.get(this),r=s.dense,n=s.n;for(let s=0;s<n;s++){const n=r[s];e.call(t,n,n,this)}}*entries(){const e=G.get(this),t=e.dense,s=e.n;for(let e=0;e<s;e++)yield[t[e],t[e]]}*keys(){const e=G.get(this),t=e.dense,s=e.n;for(let e=0;e<s;e++)yield t[e]}values(){return this.keys()}__copyTo(e){const t=G.get(this),s=G.get(e);return s.dense=t.dense.slice(),s.sparse=t.sparse.slice(),s.n=t.n,e}}class Q extends J{constructor(e,t){r.isNumber(e)?super(new Uint8Array(e),new Uint8Array(e)):e.length===t.length?super(e,t):I()}get[Symbol.species](){return Q}get[Symbol.toStringTag](){return"SparseSet8"}copy(){return this.__copyTo(new Q(0))}empty(){return new Q(this.capacity)}}class V extends J{constructor(e,t){r.isNumber(e)?super(new Uint16Array(e),new Uint16Array(e)):e.length===t.length?super(e,t):I()}get[Symbol.species](){return V}get[Symbol.toStringTag](){return"SparseSet16"}copy(){return this.__copyTo(new V(0))}empty(){return new V(this.capacity)}}class X extends J{constructor(e,t){r.isNumber(e)?super(new Uint32Array(e),new Uint32Array(e)):e.length===t.length?super(e,t):I()}get[Symbol.species](){return X}get[Symbol.toStringTag](){return"SparseSet32"}copy(){return this.__copyTo(new X(0))}empty(){return new X(this.capacity)}}const Y=(e,t,s)=>{if(e.size<t.size){const s=e;e=t,t=s}return s=s?g(s,e):v(e,Set),e===t?s:g(s,t)};e.ASparseSet=J,e.ArraySet=d,e.EquivMap=O,e.HashMap=E,e.LLSet=L,e.SortedMap=N,e.SortedSet=B,e.SparseSet16=V,e.SparseSet32=X,e.SparseSet8=Q,e.commonKeysMap=(e,t,s=[])=>{for(let r of e.keys())t.has(r)&&s.push(r);return s},e.commonKeysObj=y,e.difference=k,e.differenceR=function e(t){return w(e,k,t)},e.dissoc=u,e.dissocObj=(e,t)=>{for(let s of t)delete e[s];return e},e.indexed=j,e.intersection=P,e.intersectionR=function e(t){return w(e,P,t)},e.into=g,e.invertMap=(e,t)=>{t=t||new Map;for(let s of e)t.set(s[1],s[0]);return t},e.invertObj=T,e.join=(e,t)=>{if(e.size&&t.size){const s=y(S(e)||{},S(t)||{});let r,n;e.size<=t.size?(r=e,n=t):(r=t,n=e);const i=j(r,s),o=m(e,Set);for(let e of n){const t=i.get(A(e,s));if(t)for(let s of t)o.add(H(Object.assign({},s),e))}return o}return m(e,Set)},e.joinWith=_,e.mergeApplyMap=(e,t)=>{const s=v(e,Map);for(let[e,n]of t)s.set(e,r.isFunction(n)?n(s.get(e)):n);return s},e.mergeApplyObj=(e,t)=>{const s=Object.assign({},e);for(let e in t){const n=t[e];s[e]=r.isFunction(n)?n(s[e]):n}return s},e.mergeDeepObj=D,e.mergeMap=(e,...t)=>{for(let s of t)for(let t of s)e.set(t[0],t[1]);return e},e.mergeMapWith=(e,t,...s)=>{const r=v(t,Map);for(let t of s)for(let[s,n]of t)r.set(s,r.has(s)?e(r.get(s),n):n);return r},e.mergeObj=H,e.mergeObjWith=W,e.renameKeysMap=(e,t,s)=>{s=s||m(e,Map);for(let[r,n]of e)s.set(t.has(r)?t.get(r):r,n);return s},e.renameKeysObj=R,e.selectKeysMap=(e,t)=>{const s=m(e,Map);for(let r of t)e.has(r)&&s.set(r,e.get(r));return s},e.selectKeysObj=A,e.sparseSet=e=>e<=256?new Q(e):e<=65536?new V(e):new X(e),e.union=Y,e.unionR=function e(t){return w(e,Y,t)},e.withoutKeysMap=(e,t)=>{const s=b(t),r=m(e,Map);for(let t of e.entries()){const e=t[0];!s.has(e)&&r.set(e,t[1])}return r},e.withoutKeysObj=(e,t)=>{const s=b(t),r={};for(let t in e)e.hasOwnProperty(t)&&!s.has(t)&&(r[t]=e[t]);return r},Object.defineProperty(e,"__esModule",{value:!0})}));