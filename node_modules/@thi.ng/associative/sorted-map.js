import { SEMAPHORE } from "@thi.ng/api";
import { compare } from "@thi.ng/compare";
import { isReduced, map } from "@thi.ng/transducers";
import { dissoc } from "./dissoc";
import { equivMap } from "./internal/equiv";
import { into } from "./into";
class Node {
    constructor(k, v, h) {
        this.k = k;
        this.v = v;
        this.next = new Array(h + 1);
    }
}
// stores private properties for all instances
// http://fitzgeraldnick.com/2014/01/13/hiding-implementation-details-with-e6-weakmaps.html
const __private = new WeakMap();
export class SortedMap extends Map {
    /**
     * Creates new {@link SortedMap} instance with optionally given pairs
     * and/or options.
     *
     * @param pairs - key-value pairs
     * @param opts - config options
     */
    constructor(pairs, opts = {}) {
        super();
        const cap = opts.capacity || SortedMap.DEFAULT_CAP;
        const maxh = Math.ceil(Math.log2(cap));
        __private.set(this, {
            head: new Node(null, null, 0),
            cap: Math.pow(2, maxh),
            cmp: opts.compare || compare,
            p: opts.probability || SortedMap.DEFAULT_P,
            maxh,
            length: 0,
            h: 0
        });
        if (pairs) {
            this.into(pairs);
        }
    }
    /**
     * Creates new {@link SortedMap} instance from given object's key-value
     * pairs.
     *
     * @param obj - source object
     * @param opts - config options
     */
    static fromObject(obj, opts) {
        const m = new SortedMap(null, Object.assign({ capacity: Object.keys(obj).length }, opts));
        for (let k in obj) {
            obj.hasOwnProperty(k) && m.set(k, obj[k]);
        }
        return m;
    }
    get [Symbol.species]() {
        return SortedMap;
    }
    *[Symbol.iterator]() {
        let node = __private.get(this).head;
        while ((node = node.next[0])) {
            yield [node.k, node.v];
        }
    }
    *entries(key, max = false) {
        const $this = __private.get(this);
        let node = $this.head;
        const cmp = $this.cmp;
        let code;
        if (max) {
            while ((node = node.next[0])) {
                if (key === undefined || (code = cmp(node.k, key)) <= 0) {
                    yield [node.k, node.v];
                    if (code === 0)
                        return;
                }
            }
        }
        else {
            while ((node = node.next[0])) {
                if (key === undefined || (code = cmp(node.k, key)) >= 0) {
                    yield [node.k, node.v];
                }
            }
        }
    }
    keys(key, max = false) {
        return map((p) => p[0], this.entries(key, max));
    }
    values(key, max = false) {
        return map((p) => p[1], this.entries(key, max));
    }
    get size() {
        return __private.get(this).length;
    }
    clear() {
        const $this = __private.get(this);
        $this.head = new Node(null, null, 0);
        $this.length = 0;
        $this.h = 0;
    }
    empty() {
        return new SortedMap(null, Object.assign(Object.assign({}, this.opts()), { capacity: SortedMap.DEFAULT_CAP }));
    }
    copy() {
        return new SortedMap(this, this.opts());
    }
    compare(o) {
        const n = this.size;
        const m = o.size;
        if (n < m)
            return -1;
        if (n > m)
            return 1;
        const i = this.entries();
        const j = o.entries();
        let x, y;
        let c;
        while (((x = i.next()), (y = j.next()), !x.done && !y.done)) {
            if ((c = compare(x.value[0], y.value[0])) !== 0 ||
                (c = compare(x.value[1], y.value[1])) !== 0) {
                return c;
            }
        }
        return 0;
    }
    equiv(o) {
        return equivMap(this, o);
    }
    first() {
        const node = __private.get(this).head.next[0];
        return node ? [node.k, node.v] : undefined;
    }
    get(k, notFound) {
        const node = this.findPredNode(k).next[0];
        return node && __private.get(this).cmp(node.k, k) === 0
            ? node.v
            : notFound;
    }
    has(key) {
        return this.get(key, SEMAPHORE) !== SEMAPHORE;
    }
    set(k, v) {
        const $this = __private.get(this);
        let node = $this.head;
        let level = $this.h;
        let stack = new Array(level);
        const cmp = $this.cmp;
        let code;
        while (level >= 0) {
            while (node.next[level] &&
                (code = cmp(node.next[level].k, k)) < 0) {
                node = node.next[level];
            }
            if (node.next[level] && code === 0) {
                do {
                    node.next[level].v = v;
                } while (--level >= 0);
                return this;
            }
            stack[level--] = node;
        }
        const h = this.pickHeight($this.maxh, $this.h, $this.p);
        node = new Node(k, v, h);
        while ($this.h < h) {
            stack[++$this.h] = $this.head;
        }
        for (let i = 0; i <= h; i++) {
            node.next[i] = stack[i].next[i];
            stack[i].next[i] = node;
        }
        $this.length++;
        if ($this.length >= $this.cap) {
            $this.cap *= 2;
            $this.maxh++;
        }
        return this;
    }
    delete(k) {
        const $this = __private.get(this);
        let node = $this.head;
        let level = $this.h;
        let removed = false;
        const cmp = $this.cmp;
        let code;
        while (level >= 0) {
            while (node.next[level] &&
                (code = cmp(node.next[level].k, k)) < 0) {
                node = node.next[level];
            }
            if (node.next[level] && code === 0) {
                removed = true;
                node.next[level] = node.next[level].next[level];
                if (node == $this.head && !node.next[level]) {
                    $this.h = Math.max(0, $this.h - 1);
                }
            }
            level--;
        }
        if (removed)
            $this.length--;
        return removed;
    }
    into(pairs) {
        return into(this, pairs);
    }
    dissoc(keys) {
        return dissoc(this, keys);
    }
    forEach(fn, thisArg) {
        for (let p of this) {
            fn.call(thisArg, p[1], p[0], this);
        }
    }
    $reduce(rfn, acc) {
        let node = __private.get(this).head;
        while ((node = node.next[0]) && !isReduced(acc)) {
            acc = rfn(acc, [node.k, node.v]);
        }
        return acc;
    }
    opts() {
        const $this = __private.get(this);
        return {
            capacity: $this.cap,
            compare: $this.cmp,
            probability: $this.p
        };
    }
    findPredNode(k) {
        const $this = __private.get(this);
        const cmp = $this.cmp;
        let node = $this.head;
        let level = $this.h;
        while (level >= 0) {
            while (node.next[level] && cmp(node.next[level].k, k) < 0) {
                node = node.next[level];
            }
            level--;
        }
        return node;
    }
    pickHeight(maxh, h, p) {
        const max = Math.min(maxh, h + 1);
        let level = 0;
        while (Math.random() < p && level < max) {
            level++;
        }
        return level;
    }
}
SortedMap.DEFAULT_CAP = 8;
SortedMap.DEFAULT_P = 1 / Math.E;
