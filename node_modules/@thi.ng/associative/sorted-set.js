import { compare } from "@thi.ng/compare";
import { map } from "@thi.ng/transducers";
import { dissoc } from "./dissoc";
import { equivSet } from "./internal/equiv";
import { into } from "./into";
import { SortedMap } from "./sorted-map";
const __private = new WeakMap();
/**
 * Sorted set implementation with standard ES6 Set API, customizable
 * value equality and comparison semantics and additional functionality:
 *
 * - range queries (via {@link SortedSet.entries},
 *   {@link SortedSet.keys}, {@link SortedSet.values})
 * - multiple value addition/deletion via {@link SortedSet.into} and
 *   {@link SortedSet.disj}
 *
 * Furthermore, this class implements the {@link @thi.ng/api#ICopy},
 * IEmpty`, {@link @thi.ng/api#ICompare} and {@link @thi.ng/api#IEquiv}
 * interfaces defined by {@link @thi.ng/api# | @thi.ng/api}. The latter two allow
 * instances to be used as keys themselves in other data types defined
 * in this (and other) package(s).
 *
 * This set uses a {@link SortedMap} as backing store and therefore has
 * the same resizing characteristics.
 */
export class SortedSet extends Set {
    /**
     * Creates new instance with optional given values and/or
     * implementation options. The options are the same as used by
     * {@link SortedMap}.
     *
     * @param values - input values
     * @param opts - config options
     */
    constructor(values, opts) {
        super();
        __private.set(this, new SortedMap(values ? map((x) => [x, x], values) : null, opts));
    }
    [Symbol.iterator]() {
        return this.keys();
    }
    get [Symbol.species]() {
        return SortedSet;
    }
    get [Symbol.toStringTag]() {
        return "SortedSet";
    }
    get size() {
        return __private.get(this).size;
    }
    copy() {
        return new SortedSet(this.keys(), this.opts());
    }
    empty() {
        return new SortedSet(null, Object.assign(Object.assign({}, this.opts()), { capacity: SortedMap.DEFAULT_CAP }));
    }
    compare(o) {
        const n = this.size;
        const m = o.size;
        if (n < m)
            return -1;
        if (n > m)
            return 1;
        const i = this.entries();
        const j = o.entries();
        let x, y;
        let c;
        while (((x = i.next()), (y = j.next()), !x.done && !y.done)) {
            if ((c = compare(x.value[0], y.value[0])) !== 0) {
                return c;
            }
        }
        return 0;
    }
    equiv(o) {
        return equivSet(this, o);
    }
    $reduce(rfn, acc) {
        return __private.get(this).$reduce((_acc, x) => rfn(_acc, x[0]), acc);
    }
    entries(key, max = false) {
        return __private.get(this).entries(key, max);
    }
    keys(key, max = false) {
        return __private.get(this).keys(key, max);
    }
    values(key, max = false) {
        return __private.get(this).values(key, max);
    }
    add(key) {
        __private.get(this).set(key, key);
        return this;
    }
    into(keys) {
        return into(this, keys);
    }
    clear() {
        __private.get(this).clear();
    }
    first() {
        const first = __private.get(this).first();
        return first ? first[0] : undefined;
    }
    delete(key) {
        return __private.get(this).delete(key);
    }
    disj(keys) {
        return dissoc(this, keys);
    }
    forEach(fn, thisArg) {
        for (let p of this) {
            fn.call(thisArg, p, p, this);
        }
    }
    has(key) {
        return __private.get(this).has(key);
    }
    get(key, notFound) {
        return __private.get(this).get(key, notFound);
    }
    opts() {
        return __private.get(this).opts();
    }
}
