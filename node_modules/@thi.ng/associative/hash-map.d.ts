import type { Fn, Fn3, ICopy, IEmpty, IEquiv, Pair, Predicate2 } from "@thi.ng/api";
import type { HashMapOpts } from "./api";
interface HashMapState<K, V> {
    hash: Fn<K, number>;
    equiv: Predicate2<K>;
    load: number;
    bins: Pair<K, V>[];
    mask: number;
    size: number;
}
/**
 * Configurable hash map implementation w/ ES6 Map API. Uses open
 * addressing / linear probing to resolve key collisions. Supports any
 * key types via mandatory user supplied hash function.
 *
 * See {@link HashMapOpts} for further configuration & behavior details.
 *
 * @example
 * ```ts
 * import { HashMap } from "@thi.ng/associative"
 * import { hash } from "@thi.ng/vectors"
 *
 * m = new HashMap([], { hash })
 * m.set([1, 2], "a");
 * m.set([3, 4], "b");
 * m.set([1, 2], "c");
 * // HashMap { [ 1, 2 ] => 'c', [ 3, 4 ] => 'b' }
 * ```
 *
 */
export declare class HashMap<K, V> extends Map<K, V> implements Iterable<Pair<K, V>>, ICopy<HashMap<K, V>>, IEmpty<HashMap<K, V>>, IEquiv {
    constructor(pairs: Iterable<Pair<K, V>> | null, opts: HashMapOpts<K>);
    get [Symbol.species](): typeof HashMap;
    get [Symbol.toStringTag](): string;
    get size(): number;
    [Symbol.iterator](): IterableIterator<Pair<K, V>>;
    entries(): IterableIterator<Pair<K, V>>;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    forEach(fn: Fn3<V, Readonly<K>, Map<K, V>, void>, thisArg?: any): void;
    clear(): void;
    empty(): HashMap<K, V>;
    copy(): HashMap<K, V>;
    equiv(o: any): boolean;
    has(key: K): boolean;
    get(key: K, notFound?: V): V | undefined;
    set(key: K, val: V): this;
    delete(key: K): boolean;
    into(pairs: Iterable<Pair<K, V>>): this;
    dissoc(keys: Iterable<K>): this;
    opts(overrides?: Partial<HashMapOpts<K>>): HashMapOpts<K>;
    protected find(key: K, $this: HashMapState<K, V>): number;
    protected resize($this: HashMapState<K, V>): void;
}
export {};
//# sourceMappingURL=hash-map.d.ts.map