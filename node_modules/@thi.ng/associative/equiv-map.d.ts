import type { EquivMapOpts } from "./api";
import type { Fn3, ICopy, IEmpty, IEquiv, IObjectOf, Pair } from "@thi.ng/api";
export declare class EquivMap<K, V> extends Map<K, V> implements Iterable<Pair<K, V>>, ICopy<EquivMap<K, V>>, IEmpty<EquivMap<K, V>>, IEquiv {
    /**
     * Converts given vanilla object into an {@link EquivMap} instance with
     * default (or optionally provided) options and returns it. By
     * default uses strict `===` equality check for `equiv` option.
     *
     * @param obj - source object
     * @param opts - config options
     */
    static fromObject<T>(obj: IObjectOf<T>, opts?: Partial<EquivMapOpts<string>>): EquivMap<string, T>;
    /**
     * Creates a new instance with optional initial key-value pairs and
     * provided options. If no `opts` are given, uses `ArraySet` for
     * storing canonical keys and {@link @thi.ng/equiv#equiv} for
     * checking key equivalence.
     *
     * @param pairs - key-value pairs
     * @param opts - config options
     */
    constructor(pairs?: Iterable<Pair<K, V>> | null, opts?: Partial<EquivMapOpts<K>>);
    [Symbol.iterator](): IterableIterator<Pair<K, V>>;
    get [Symbol.species](): typeof EquivMap;
    get [Symbol.toStringTag](): string;
    get size(): number;
    clear(): void;
    empty(): EquivMap<K, V>;
    copy(): EquivMap<K, V>;
    equiv(o: any): boolean;
    delete(key: K): boolean;
    dissoc(keys: Iterable<K>): this;
    forEach(fn: Fn3<V, Readonly<K>, Map<K, V>, void>, thisArg?: any): void;
    get(key: K, notFound?: V): V | undefined;
    has(key: K): boolean;
    set(key: K, value: V): this;
    into(pairs: Iterable<Pair<K, V>>): this;
    entries(): IterableIterator<Pair<K, V>>;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    opts(): EquivMapOpts<K>;
}
//# sourceMappingURL=equiv-map.d.ts.map