import type { Fn3, ICompare, Pair } from "@thi.ng/api";
import type { IReducible, ReductionFn } from "@thi.ng/transducers";
import type { IEquivSet, SortedSetOpts } from "./api";
/**
 * Sorted set implementation with standard ES6 Set API, customizable
 * value equality and comparison semantics and additional functionality:
 *
 * - range queries (via {@link SortedSet.entries},
 *   {@link SortedSet.keys}, {@link SortedSet.values})
 * - multiple value addition/deletion via {@link SortedSet.into} and
 *   {@link SortedSet.disj}
 *
 * Furthermore, this class implements the {@link @thi.ng/api#ICopy},
 * IEmpty`, {@link @thi.ng/api#ICompare} and {@link @thi.ng/api#IEquiv}
 * interfaces defined by {@link @thi.ng/api# | @thi.ng/api}. The latter two allow
 * instances to be used as keys themselves in other data types defined
 * in this (and other) package(s).
 *
 * This set uses a {@link SortedMap} as backing store and therefore has
 * the same resizing characteristics.
 */
export declare class SortedSet<T> extends Set<T> implements IEquivSet<T>, ICompare<Set<T>>, IReducible<any, T> {
    /**
     * Creates new instance with optional given values and/or
     * implementation options. The options are the same as used by
     * {@link SortedMap}.
     *
     * @param values - input values
     * @param opts - config options
     */
    constructor(values?: Iterable<T> | null, opts?: Partial<SortedSetOpts<T>>);
    [Symbol.iterator](): IterableIterator<T>;
    get [Symbol.species](): typeof SortedSet;
    get [Symbol.toStringTag](): string;
    get size(): number;
    copy(): SortedSet<T>;
    empty(): SortedSet<T>;
    compare(o: Set<T>): number;
    equiv(o: any): boolean;
    $reduce(rfn: ReductionFn<any, T>, acc: any): any;
    entries(key?: T, max?: boolean): IterableIterator<Pair<T, T>>;
    keys(key?: T, max?: boolean): IterableIterator<T>;
    values(key?: T, max?: boolean): IterableIterator<T>;
    add(key: T): this;
    into(keys: Iterable<T>): this;
    clear(): void;
    first(): T;
    delete(key: T): boolean;
    disj(keys: Iterable<T>): this;
    forEach(fn: Fn3<Readonly<T>, Readonly<T>, Set<T>, void>, thisArg?: any): void;
    has(key: T): boolean;
    get(key: T, notFound?: T): T | undefined;
    opts(): SortedSetOpts<T>;
}
//# sourceMappingURL=sorted-set.d.ts.map