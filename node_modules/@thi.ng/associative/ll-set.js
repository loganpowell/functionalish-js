import { SEMAPHORE } from "@thi.ng/api";
import { DCons } from "@thi.ng/dcons";
import { equiv } from "@thi.ng/equiv";
import { dissoc } from "./dissoc";
import { equivSet } from "./internal/equiv";
import { into } from "./into";
const __private = new WeakMap();
const __vals = (inst) => __private.get(inst).vals;
/**
 * Similar to {@link ArraySet}, this class is an alternative implementation of
 * the native ES6 Set API using a {@link @thi.ng/dcons#DCons} linked
 * list as backing store and a customizable value equality / equivalence
 * predicate. By the default uses {@link @thi.ng/equiv#equiv} for
 * equivalence checking.
 *
 * Additionally, the type also implements the {@link @thi.ng/api#ICopy}, {@link @thi.ng/api#IEmpty} and
 * {@link @thi.ng/api#IEquiv} interfaces itself.
 */
export class LLSet extends Set {
    constructor(vals, opts = {}) {
        super();
        __private.set(this, {
            equiv: opts.equiv || equiv,
            vals: new DCons()
        });
        vals && this.into(vals);
    }
    *[Symbol.iterator]() {
        yield* __vals(this);
    }
    get [Symbol.species]() {
        return LLSet;
    }
    get [Symbol.toStringTag]() {
        return "LLSet";
    }
    get size() {
        return __vals(this).length;
    }
    copy() {
        const $this = __private.get(this);
        const s = new LLSet(null, this.opts());
        __private.get(s).vals = $this.vals.copy();
        return s;
    }
    empty() {
        return new LLSet(null, this.opts());
    }
    clear() {
        __vals(this).clear();
    }
    first() {
        if (this.size) {
            return __vals(this).head.value;
        }
    }
    add(key) {
        !this.has(key) && __vals(this).push(key);
        return this;
    }
    into(keys) {
        return into(this, keys);
    }
    has(key) {
        return this.get(key, SEMAPHORE) !== SEMAPHORE;
    }
    /**
     * Returns the canonical (stored) value for `key`, if present. If
     * the set contains no equivalent for `key`, returns `notFound`.
     *
     * @param key - search key
     * @param notFound - default value
     */
    get(key, notFound) {
        const $this = __private.get(this);
        const eq = $this.equiv;
        let i = $this.vals.head;
        while (i) {
            if (eq(i.value, key)) {
                return i.value;
            }
            i = i.next;
        }
        return notFound;
    }
    delete(key) {
        const $this = __private.get(this);
        const eq = $this.equiv;
        let i = $this.vals.head;
        while (i) {
            if (eq(i.value, key)) {
                $this.vals.splice(i, 1);
                return true;
            }
            i = i.next;
        }
        return false;
    }
    disj(keys) {
        return dissoc(this, keys);
    }
    equiv(o) {
        return equivSet(this, o);
    }
    forEach(fn, thisArg) {
        let i = __vals(this).head;
        while (i) {
            fn.call(thisArg, i.value, i.value, this);
            i = i.next;
        }
    }
    *entries() {
        for (let v of __vals(this)) {
            yield [v, v];
        }
    }
    *keys() {
        yield* __vals(this);
    }
    *values() {
        yield* __vals(this);
    }
    opts() {
        return { equiv: __private.get(this).equiv };
    }
}
