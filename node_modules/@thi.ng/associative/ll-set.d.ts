import type { Fn3, Pair } from "@thi.ng/api";
import type { EquivSetOpts, IEquivSet } from "./api";
/**
 * Similar to {@link ArraySet}, this class is an alternative implementation of
 * the native ES6 Set API using a {@link @thi.ng/dcons#DCons} linked
 * list as backing store and a customizable value equality / equivalence
 * predicate. By the default uses {@link @thi.ng/equiv#equiv} for
 * equivalence checking.
 *
 * Additionally, the type also implements the {@link @thi.ng/api#ICopy}, {@link @thi.ng/api#IEmpty} and
 * {@link @thi.ng/api#IEquiv} interfaces itself.
 */
export declare class LLSet<T> extends Set<T> implements IEquivSet<T> {
    constructor(vals?: Iterable<T> | null, opts?: Partial<EquivSetOpts<T>>);
    [Symbol.iterator](): IterableIterator<T>;
    get [Symbol.species](): typeof LLSet;
    get [Symbol.toStringTag](): string;
    get size(): number;
    copy(): LLSet<T>;
    empty(): LLSet<T>;
    clear(): void;
    first(): T | undefined;
    add(key: T): this;
    into(keys: Iterable<T>): this;
    has(key: T): boolean;
    /**
     * Returns the canonical (stored) value for `key`, if present. If
     * the set contains no equivalent for `key`, returns `notFound`.
     *
     * @param key - search key
     * @param notFound - default value
     */
    get(key: T, notFound?: T): T | undefined;
    delete(key: T): boolean;
    disj(keys: Iterable<T>): this;
    equiv(o: any): boolean;
    forEach(fn: Fn3<Readonly<T>, Readonly<T>, Set<T>, void>, thisArg?: any): void;
    entries(): IterableIterator<Pair<T, T>>;
    keys(): IterableIterator<T>;
    values(): IterableIterator<T>;
    opts(): EquivSetOpts<T>;
}
//# sourceMappingURL=ll-set.d.ts.map