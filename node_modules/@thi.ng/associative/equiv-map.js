import { SEMAPHORE } from "@thi.ng/api";
import { equiv } from "@thi.ng/equiv";
import { ArraySet } from "./array-set";
import { dissoc } from "./dissoc";
import { equivMap } from "./internal/equiv";
import { into } from "./into";
const __private = new WeakMap();
const __map = (map) => __private.get(map).map;
export class EquivMap extends Map {
    /**
     * Converts given vanilla object into an {@link EquivMap} instance with
     * default (or optionally provided) options and returns it. By
     * default uses strict `===` equality check for `equiv` option.
     *
     * @param obj - source object
     * @param opts - config options
     */
    static fromObject(obj, opts) {
        const m = new EquivMap(null, Object.assign({ equiv: (a, b) => a === b }, opts));
        for (let k in obj) {
            obj.hasOwnProperty(k) && m.set(k, obj[k]);
        }
        return m;
    }
    /**
     * Creates a new instance with optional initial key-value pairs and
     * provided options. If no `opts` are given, uses `ArraySet` for
     * storing canonical keys and {@link @thi.ng/equiv#equiv} for
     * checking key equivalence.
     *
     * @param pairs - key-value pairs
     * @param opts - config options
     */
    constructor(pairs, opts) {
        super();
        const _opts = Object.assign({ equiv, keys: ArraySet }, opts);
        __private.set(this, {
            keys: new _opts.keys(null, { equiv: _opts.equiv }),
            map: new Map(),
            opts: _opts
        });
        if (pairs) {
            this.into(pairs);
        }
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    get [Symbol.species]() {
        return EquivMap;
    }
    get [Symbol.toStringTag]() {
        return "EquivMap";
    }
    get size() {
        return __private.get(this).keys.size;
    }
    clear() {
        const $this = __private.get(this);
        $this.keys.clear();
        $this.map.clear();
    }
    empty() {
        return new EquivMap(null, __private.get(this).opts);
    }
    copy() {
        const $this = __private.get(this);
        const m = new EquivMap();
        __private.set(m, {
            keys: $this.keys.copy(),
            map: new Map($this.map),
            opts: $this.opts
        });
        return m;
    }
    equiv(o) {
        return equivMap(this, o);
    }
    delete(key) {
        const $this = __private.get(this);
        key = $this.keys.get(key, SEMAPHORE);
        if (key !== SEMAPHORE) {
            $this.map.delete(key);
            $this.keys.delete(key);
            return true;
        }
        return false;
    }
    dissoc(keys) {
        return dissoc(this, keys);
    }
    forEach(fn, thisArg) {
        for (let pair of __map(this)) {
            fn.call(thisArg, pair[1], pair[0], this);
        }
    }
    get(key, notFound) {
        const $this = __private.get(this);
        key = $this.keys.get(key, SEMAPHORE);
        if (key !== SEMAPHORE) {
            return $this.map.get(key);
        }
        return notFound;
    }
    has(key) {
        return __private.get(this).keys.has(key);
    }
    set(key, value) {
        const $this = __private.get(this);
        const k = $this.keys.get(key, SEMAPHORE);
        if (k !== SEMAPHORE) {
            $this.map.set(k, value);
        }
        else {
            $this.keys.add(key);
            $this.map.set(key, value);
        }
        return this;
    }
    into(pairs) {
        return into(this, pairs);
    }
    entries() {
        return __map(this).entries();
    }
    keys() {
        return __map(this).keys();
    }
    values() {
        return __map(this).values();
    }
    opts() {
        return __private.get(this).opts;
    }
}
