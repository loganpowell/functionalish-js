import { EquivMap } from "@thi.ng/associative";
import { unsupported } from "@thi.ng/errors";
import { LOGGER } from "./api";
import { Subscription, subscription } from "./subscription";
import { optsWithID } from "./utils/idgen";
/**
 * Topic based stream splitter. Applies `topic` function to each
 * received value and only forwards it to the child subscriptions of the
 * returned topic.
 *
 * @remarks
 * The actual topic (return value from `topic` fn) can be of any type,
 * apart from `undefined`. Complex topics (e.g objects / arrays) are
 * allowed and they're matched with registered topics using
 * {@link @thi.ng/equiv#equiv} by default (but customizable via `equiv`
 * option). Each topic can have any number of subscribers.
 *
 * If a `xform` transducer is given, it is always applied prior to
 * passing the input to the topic function. I.e. in this case the topic
 * function will receive the transformed inputs.
 *
 * {@link PubSub} supports dynamic topic subscriptions and
 * unsubscriptions via {@link PubSub.(subscribeTopic:1)} and
 * {@link PubSub.unsubscribeTopic}. However, the standard
 * {@link ISubscribable.(subscribe:1)} /
 * {@link ISubscribable.unsubscribe} methods are NOT supported (since
 * meaningless) and will throw an error! `unsubscribe()` can only be
 * called WITHOUT argument to unsubscribe the entire `PubSub` instance
 * (incl. all topic subscriptions) from the parent stream.
 *
 * @param opts -
 */
export const pubsub = (opts) => new PubSub(opts);
export class PubSub extends Subscription {
    constructor(opts) {
        opts = opts || {};
        super(undefined, optsWithID("pubsub", {
            xform: opts.xform
        }));
        this.topicfn = opts.topic;
        this.topics = new EquivMap(undefined, {
            equiv: opts.equiv
        });
    }
    /**
     * Unsupported. Use {@link PubSub.(subscribeTopic:1)} instead.
     */
    subscribe() {
        return unsupported(`use subscribeTopic() instead`);
    }
    /**
     * Unsupported. Use {@link PubSub.(subscribeTopic:1)} instead.
     */
    transform() {
        return unsupported(`use subscribeTopic() instead`);
    }
    subscribeTopic(topicID, sub, opts) {
        let t = this.topics.get(topicID);
        !t && this.topics.set(topicID, (t = subscription()));
        return t.subscribe(sub, opts);
    }
    unsubscribeTopic(topicID, sub) {
        const t = this.topics.get(topicID);
        return t ? t.unsubscribe(sub) : false;
    }
    unsubscribe(sub) {
        if (!sub) {
            for (let t of this.topics.values()) {
                t.unsubscribe();
            }
            this.topics.clear();
            return super.unsubscribe();
        }
        return unsupported();
    }
    done() {
        for (let t of this.topics.values()) {
            t.done();
        }
        super.done();
    }
    dispatch(x) {
        LOGGER.debug(this.id, "dispatch", x);
        const t = this.topicfn(x);
        if (t !== undefined) {
            const sub = this.topics.get(t);
            if (sub) {
                try {
                    sub.next && sub.next(x);
                }
                catch (e) {
                    sub.error ? sub.error(e) : this.error(e);
                }
            }
        }
    }
}
