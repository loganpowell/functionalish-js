import { isPlainObject } from "@thi.ng/checks";
import { comp, labeled, mapVals, partitionSync } from "@thi.ng/transducers";
import { LOGGER } from "./api";
import { Subscription } from "./subscription";
import { optsWithID } from "./utils/idgen";
/**
 * Similar to {@link StreamMerge}, but with extra synchronization of
 * inputs. Before emitting any new values, {@link StreamSync} collects
 * values until at least one has been received from *all* inputs. Once
 * that's the case, the collected values are sent as labeled tuple
 * object to downstream subscribers.
 *
 * @remarks
 * Each value in the emitted tuple objects is stored under their input
 * stream's ID. Only the last value received from each input is passed
 * on. After the initial tuple has been emitted, you can choose from two
 * possible behaviors:
 *
 * 1) Any future change in any input will produce a new result tuple.
 *    These tuples will retain the most recently read values from other
 *    inputs. This behavior is the default and illustrated in the above
 *    schematic.
 * 2) If the `reset` option is `true`, every input will have to provide
 *    at least one new value again until another result tuple is
 *    produced.
 *
 * Any done inputs are automatically removed. By default, `StreamSync`
 * calls {@link ISubscriber.done} when the last active input is done,
 * but this behavior can be overridden via the provided options.
 *
 * Input streams can be added and removed dynamically and the emitted
 * tuple size adjusts to the current number of inputs (the next time a
 * value is received from any input).
 *
 * If the `reset` option is enabled, the last emitted tuple is allowed
 * to be incomplete, by default. To only allow complete tuples, also set
 * the `all` option to `false`.
 *
 * The synchronization is done via the
 * {@link @thi.ng/transducers#(partitionSync:1)} transducer fro the
 * {@link @thi.ng/transducers# | @thi.ng/transducers} package. See this
 * function's docs for further details.
 *
 * @example
 * ```ts
 * const a = rs.stream();
 * const b = rs.stream();
 * s = sync({ src: { a, b } }).subscribe(trace("result: "));
 * a.next(1);
 * b.next(2);
 * // result: { a: 1, b: 2 }
 * ```
 *
 * Also see: {@link StreamSyncOpts}
 *
 * @param opts -
 */
export const sync = (opts) => new StreamSync(opts);
export class StreamSync extends Subscription {
    constructor(opts) {
        const srcIDs = new Set();
        const psync = partitionSync(srcIDs, {
            key: (x) => x[0],
            mergeOnly: opts.mergeOnly === true,
            reset: opts.reset === true,
            all: opts.all !== false,
            backPressure: opts.backPressure || 0
        });
        const mapv = mapVals((x) => x[1]);
        super(undefined, optsWithID("streamsync", Object.assign(Object.assign({}, opts), { xform: opts.xform
                ? comp(psync, mapv, opts.xform)
                : comp(psync, mapv) })));
        this.sources = new Map();
        this.realSourceIDs = new Map();
        this.invRealSourceIDs = new Map();
        this.idSources = new Map();
        this.sourceIDs = srcIDs;
        opts.src && this.addAll(opts.src);
    }
    add(src, id) {
        id || (id = src.id);
        this.ensureState();
        this.sourceIDs.add(id);
        this.realSourceIDs.set(id, src.id);
        this.invRealSourceIDs.set(src.id, id);
        this.idSources.set(src.id, src);
        this.sources.set(src, src.subscribe({
            next: (x) => {
                if (x[1] instanceof Subscription) {
                    this.add(x[1]);
                }
                else {
                    this.next(x);
                }
            },
            done: () => this.markDone(src),
            __owner: this
        }, labeled(id), { id: `in-${id}` }));
    }
    addAll(src) {
        if (isPlainObject(src)) {
            // pre-add all source ids for partitionSync
            for (let id in src) {
                this.sourceIDs.add(id);
            }
            for (let id in src) {
                this.add(src[id], id);
            }
        }
        else {
            // pre-add all source ids for partitionSync
            for (let s of src) {
                this.sourceIDs.add(s.id);
            }
            for (let s of src) {
                this.add(s);
            }
        }
    }
    remove(src) {
        const sub = this.sources.get(src);
        if (sub) {
            const id = this.invRealSourceIDs.get(src.id);
            LOGGER.info(`removing src: ${src.id} (${id})`);
            this.sourceIDs.delete(id);
            this.realSourceIDs.delete(id);
            this.invRealSourceIDs.delete(src.id);
            this.idSources.delete(src.id);
            this.sources.delete(src);
            sub.unsubscribe();
            return true;
        }
        return false;
    }
    removeID(id) {
        const src = this.getSourceForID(id);
        return src ? this.remove(src) : false;
    }
    removeAll(src) {
        // pre-remove all source ids for partitionSync
        for (let s of src) {
            this.sourceIDs.delete(this.invRealSourceIDs.get(s.id));
        }
        let ok = true;
        for (let s of src) {
            ok = this.remove(s) && ok;
        }
        return ok;
    }
    removeAllIDs(ids) {
        let ok = true;
        for (let id of ids) {
            ok = this.removeID(id) && ok;
        }
        return ok;
    }
    getSourceForID(id) {
        return this.idSources.get(this.realSourceIDs.get(id));
    }
    getSources() {
        const res = {};
        for (let [id, src] of this.idSources) {
            res[this.invRealSourceIDs.get(id)] = src;
        }
        return res;
    }
    unsubscribe(sub) {
        if (!sub) {
            for (let s of this.sources.values()) {
                s.unsubscribe();
            }
            this.state = 2 /* DONE */;
            this.sources.clear();
            this.sourceIDs.clear();
            this.realSourceIDs.clear();
            this.invRealSourceIDs.clear();
            this.idSources.clear();
        }
        return super.unsubscribe(sub);
    }
    markDone(src) {
        this.remove(src);
        if (this.closeIn === 1 /* FIRST */ ||
            (this.closeIn === 2 /* LAST */ && !this.sources.size)) {
            this.done();
        }
    }
}
