import { Subscription } from "../subscription";
import { optsWithID } from "../utils/idgen";
/**
 * Returns a {@link Subscription} that calls the
 * {@link ISubscriber.error} handlers of all child subscriptions with an
 * arbitrary error object after a given time.
 *
 * @remarks
 * If no `error` is given, uses a new `Error` instance by default. If
 * `resetTimeout` is false (default), the error is emitted regardless of
 * any received values in the meantime. However, if `true`, the timeout
 * resets with each received value and then only triggers once the time
 * interval since the last value has exceeded.
 *
 * @param timeoutMs - timeout period in milliseconds
 * @param opts -
 */
export const timeout = (timeoutMs, opts) => new Timeout(timeoutMs, opts);
class Timeout extends Subscription {
    constructor(timeoutMs, opts) {
        opts = optsWithID("timeout", opts);
        super(undefined, opts);
        this.timeoutMs = timeoutMs;
        this.errorObj = opts.error;
        this.resetTimeout = opts.reset === true;
        this.reset();
    }
    next(x) {
        if (this.resetTimeout) {
            clearTimeout(this.timeoutId);
            this.reset();
        }
        super.next(x);
    }
    reset() {
        this.timeoutId = setTimeout(() => {
            if (this.state < 2 /* DONE */) {
                this.error(this.errorObj ||
                    new Error(`Timeout stream "${this.id}" after ${this.timeoutMs} ms`));
            }
        }, this.timeoutMs);
    }
    cleanup() {
        clearTimeout(this.timeoutId);
        super.cleanup();
    }
}
