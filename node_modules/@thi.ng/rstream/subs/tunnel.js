import { LOGGER } from "../api";
import { Subscription } from "../subscription";
import { nextID } from "../utils/idgen";
import { makeWorker } from "../utils/worker";
/**
 * Returns a {@link Subscription} which processes received values via
 * the configured worker(s) and then passes values received back from
 * the worker(s) downstream, thereby allowing workers to be used
 * transparently for stream processing.
 *
 * @remarks
 * Multiple worker instances are supported for concurrent processing.
 * See the {@link TunnelOpts} for details.
 *
 * Also see {@link forkJoin} and {@link postWorker}.
 *
 * @param opts -
 */
export const tunnel = (opts) => new Tunnel(opts);
export class Tunnel extends Subscription {
    constructor(opts) {
        super(undefined, { id: opts.id || `tunnel-${nextID()}` });
        this.src = opts.src;
        this.workers = new Array(opts.maxWorkers || 1);
        this.transferables = opts.transferables;
        this.terminate = opts.terminate || 1000;
        this.interrupt = opts.interrupt || false;
        this.index = 0;
    }
    next(x) {
        if (this.state < 2 /* DONE */) {
            let tx;
            if (this.transferables) {
                tx = this.transferables(x);
            }
            let worker = this.workers[this.index];
            if (this.interrupt && worker) {
                worker.terminate();
                worker = null;
            }
            if (!worker) {
                this.workers[this.index++] = worker = makeWorker(this.src);
                this.index %= this.workers.length;
                worker.addEventListener("message", (e) => this.dispatch(e.data));
                worker.addEventListener("error", (e) => this.error(e));
            }
            worker.postMessage(x, tx || []);
        }
    }
    done() {
        super.done();
        if (this.terminate > 0) {
            setTimeout(() => {
                LOGGER.info("terminating workers...");
                this.workers.forEach((worker) => worker && worker.terminate());
                delete this.workers;
            }, this.terminate);
        }
    }
}
