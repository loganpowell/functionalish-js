import { ISubscribable, TransformableOpts } from "./api";
import { Subscription } from "./subscription";
import type { IObjectOf } from "@thi.ng/api";
export interface StreamSyncOpts<A, B> extends TransformableOpts<IObjectOf<A>, B> {
    /**
     * Either an array or object of input streams / subscribables. If
     * the latter, the object keys are used to label the inputs, else
     * their `id` is used as label.
     */
    src: ISubscribable<A>[] | IObjectOf<ISubscribable<A>>;
    /**
     * If true (default: false) *no* input synchronization (waiting for
     * values) is applied and `StreamSync` will emit potentially
     * partially populated tuple objects for each received input value.
     * However, as with the default behavior, tuples will retain the
     * most recent consumed value from other inputs.
     */
    mergeOnly: boolean;
    /**
     * If true, StreamSync waits for new values from *all* inputs before
     * a new tuple is produced. If false, that synchronization
     * only happens for the very first tuple.
     *
     * @defaultValue false
     */
    reset: boolean;
    /**
     * By default, the last emitted tuple is allowed to be incomplete
     * (in case all inputs closed). To only allow complete tuples, set
     * the `all` to false.
     *
     * @defaultValue true
     */
    all: boolean;
    /**
     * If greater than 0, then each labeled input will cache upto the
     * stated number of input values, even if other inputs have not yet
     * produced new values. Once the limit is reached, `partitionSync()`
     * will throw an `IllegalState` error.
     *
     * Enabling this option will cause the same behavior as if `reset`
     * is enabled (regardless of the actual configured `reset` setting).
     * I.e. new results are only produced when ALL required inputs have
     * available values...
     */
    backPressure: number;
}
/**
 * Similar to {@link StreamMerge}, but with extra synchronization of
 * inputs. Before emitting any new values, {@link StreamSync} collects
 * values until at least one has been received from *all* inputs. Once
 * that's the case, the collected values are sent as labeled tuple
 * object to downstream subscribers.
 *
 * @remarks
 * Each value in the emitted tuple objects is stored under their input
 * stream's ID. Only the last value received from each input is passed
 * on. After the initial tuple has been emitted, you can choose from two
 * possible behaviors:
 *
 * 1) Any future change in any input will produce a new result tuple.
 *    These tuples will retain the most recently read values from other
 *    inputs. This behavior is the default and illustrated in the above
 *    schematic.
 * 2) If the `reset` option is `true`, every input will have to provide
 *    at least one new value again until another result tuple is
 *    produced.
 *
 * Any done inputs are automatically removed. By default, `StreamSync`
 * calls {@link ISubscriber.done} when the last active input is done,
 * but this behavior can be overridden via the provided options.
 *
 * Input streams can be added and removed dynamically and the emitted
 * tuple size adjusts to the current number of inputs (the next time a
 * value is received from any input).
 *
 * If the `reset` option is enabled, the last emitted tuple is allowed
 * to be incomplete, by default. To only allow complete tuples, also set
 * the `all` option to `false`.
 *
 * The synchronization is done via the
 * {@link @thi.ng/transducers#(partitionSync:1)} transducer fro the
 * {@link @thi.ng/transducers# | @thi.ng/transducers} package. See this
 * function's docs for further details.
 *
 * @example
 * ```ts
 * const a = rs.stream();
 * const b = rs.stream();
 * s = sync({ src: { a, b } }).subscribe(trace("result: "));
 * a.next(1);
 * b.next(2);
 * // result: { a: 1, b: 2 }
 * ```
 *
 * Also see: {@link StreamSyncOpts}
 *
 * @param opts -
 */
export declare const sync: <A, B>(opts: Partial<StreamSyncOpts<A, B>>) => StreamSync<A, B>;
export declare class StreamSync<A, B> extends Subscription<A, B> {
    /**
     * maps actual inputs to their virtual input subs
     */
    sources: Map<ISubscribable<A>, Subscription<A, [string, A]>>;
    /**
     * maps real source IDs to their actual input
     */
    idSources: Map<string, ISubscribable<A>>;
    /**
     * maps (potentially aliased) input IDs to their actual src.id
     */
    realSourceIDs: Map<string, string>;
    /**
     * maps real src.id to (potentially aliased) input IDs
     */
    invRealSourceIDs: Map<string, string>;
    /**
     * set of (potentially aliased) input IDs
     * these IDs are used to label inputs in result tuple
     */
    sourceIDs: Set<string>;
    constructor(opts: Partial<StreamSyncOpts<A, B>>);
    add(src: ISubscribable<A>, id?: string): void;
    addAll(src: ISubscribable<A>[] | IObjectOf<ISubscribable<A>>): void;
    remove(src: ISubscribable<A>): boolean;
    removeID(id: string): boolean;
    removeAll(src: ISubscribable<A>[]): boolean;
    removeAllIDs(ids: string[]): boolean;
    getSourceForID(id: string): ISubscribable<A> | undefined;
    getSources(): IObjectOf<ISubscribable<A>>;
    unsubscribe(sub?: Subscription<B, any>): boolean;
    protected markDone(src: ISubscribable<A>): void;
}
//# sourceMappingURL=stream-sync.d.ts.map