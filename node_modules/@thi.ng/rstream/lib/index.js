'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@thi.ng/api');
var transducers = require('@thi.ng/transducers');
var checks = require('@thi.ng/checks');
var arrays = require('@thi.ng/arrays');
var errors = require('@thi.ng/errors');
var associative = require('@thi.ng/associative');
var atom = require('@thi.ng/atom');

(function (State) {
    State[State["IDLE"] = 0] = "IDLE";
    State[State["ACTIVE"] = 1] = "ACTIVE";
    State[State["DONE"] = 2] = "DONE";
    State[State["ERROR"] = 3] = "ERROR";
    State[State["DISABLED"] = 4] = "DISABLED";
})(exports.State || (exports.State = {}));
(function (CloseMode) {
    CloseMode[CloseMode["NEVER"] = 0] = "NEVER";
    CloseMode[CloseMode["FIRST"] = 1] = "FIRST";
    CloseMode[CloseMode["LAST"] = 2] = "LAST";
})(exports.CloseMode || (exports.CloseMode = {}));
exports.LOGGER = api.NULL_LOGGER;
const setLogger = (logger) => (exports.LOGGER = logger);

let NEXT_ID = 0;
const nextID = () => NEXT_ID++;
const optsWithID = (prefix, opts) => ((!opts || !opts.id ? Object.assign(Object.assign({}, opts), { id: prefix + "-" + nextID() }) : opts));

const subscription = (sub, opts) => new Subscription(sub, opts);
class Subscription {
    constructor(sub, opts = {}) {
        this.state = 0 ;
        this.parent = opts.parent;
        this.closeIn =
            opts.closeIn !== undefined ? opts.closeIn : 2 ;
        this.closeOut =
            opts.closeOut !== undefined ? opts.closeOut : 2 ;
        this.cacheLast = opts.cache !== false;
        this.id = opts.id || `sub-${nextID()}`;
        this.last = api.SEMAPHORE;
        this.subs = [];
        if (sub) {
            this.subs.push(sub);
        }
        if (opts.xform) {
            this.xform = opts.xform(transducers.push());
        }
    }
    deref() {
        return this.last !== api.SEMAPHORE ? this.last : undefined;
    }
    getState() {
        return this.state;
    }
    subscribe(...args) {
        this.ensureState();
        let sub;
        let opts = args.length > 1 && checks.isPlainObject(arrays.peek(args))
            ? Object.assign({}, args.pop()) : {};
        switch (args.length) {
            case 1:
                if (checks.isFunction(args[0])) {
                    opts.xform = args[0];
                    !opts.id && (opts.id = `xform-${nextID()}`);
                }
                else {
                    sub = args[0];
                }
                break;
            case 2:
                sub = args[0];
                opts.xform = args[1];
                break;
            default:
                errors.illegalArity(args.length);
        }
        if (checks.implementsFunction(sub, "subscribe")) {
            sub.parent = this;
        }
        else {
            sub = subscription(sub, Object.assign({ parent: this }, opts));
        }
        this.last !== api.SEMAPHORE && sub.next(this.last);
        return this.addWrapped(sub);
    }
    subscribeAll(...subs) {
        const wrapped = [];
        for (let s of subs) {
            wrapped.push(this.subscribe(s));
        }
        return wrapped;
    }
    transform(...xf) {
        const n = xf.length - 1;
        return checks.isPlainObject(xf[n])
            ? this.subscribe(transducers.comp(...xf.slice(0, n)), xf[n])
            : this.subscribe(transducers.comp(...xf));
    }
    unsubscribe(sub) {
        exports.LOGGER.debug(this.id, "unsub start", sub ? sub.id : "self");
        if (!sub) {
            let res = true;
            if (this.parent) {
                res = this.parent.unsubscribe(this);
            }
            this.state = 2 ;
            this.cleanup();
            return res;
        }
        if (this.subs) {
            exports.LOGGER.debug(this.id, "unsub child", sub.id);
            const idx = this.subs.indexOf(sub);
            if (idx >= 0) {
                this.subs.splice(idx, 1);
                if (this.closeOut === 1  ||
                    (!this.subs.length && this.closeOut !== 0 )) {
                    this.unsubscribe();
                }
                return true;
            }
        }
        return false;
    }
    next(x) {
        if (this.state < 2 ) {
            if (this.xform) {
                const acc = this.xform[2]([], x);
                const uacc = transducers.unreduced(acc);
                const n = uacc.length;
                for (let i = 0; i < n; i++) {
                    this.dispatch(uacc[i]);
                }
                if (transducers.isReduced(acc)) {
                    this.done();
                }
            }
            else {
                this.dispatch(x);
            }
        }
    }
    done() {
        exports.LOGGER.debug(this.id, "entering done()");
        if (this.state < 2 ) {
            if (this.xform) {
                const acc = this.xform[1]([]);
                const uacc = transducers.unreduced(acc);
                const n = uacc.length;
                for (let i = 0; i < n; i++) {
                    this.dispatch(uacc[i]);
                }
            }
            this.state = 2 ;
            for (let s of [...this.subs]) {
                try {
                    s.done && s.done();
                }
                catch (e) {
                    s.error ? s.error(e) : this.error(e);
                }
            }
            this.unsubscribe();
            exports.LOGGER.debug(this.id, "exiting done()");
        }
    }
    error(e) {
        this.state = 3 ;
        let notified = false;
        if (this.subs && this.subs.length) {
            for (let s of this.subs.slice()) {
                if (s.error) {
                    s.error(e);
                    notified = true;
                }
            }
        }
        if (!notified) {
            exports.LOGGER.warn(this.id, "unhandled error:", e);
            if (this.parent) {
                exports.LOGGER.debug(this.id, "unsubscribing...");
                this.unsubscribe();
                this.state = 3 ;
            }
        }
    }
    addWrapped(wrapped) {
        this.subs.push(wrapped);
        this.state = 1 ;
        return wrapped;
    }
    dispatch(x) {
        this.cacheLast && (this.last = x);
        const subs = this.subs;
        let s;
        if (subs.length === 1) {
            s = subs[0];
            try {
                s.next && s.next(x);
            }
            catch (e) {
                s.error ? s.error(e) : this.error(e);
            }
        }
        else {
            for (let i = subs.length; --i >= 0;) {
                s = subs[i];
                try {
                    s.next && s.next(x);
                }
                catch (e) {
                    s.error ? s.error(e) : this.error(e);
                }
            }
        }
    }
    ensureState() {
        if (this.state >= 2 ) {
            errors.illegalState(`operation not allowed in state ${this.state}`);
        }
    }
    cleanup() {
        exports.LOGGER.debug(this.id, "cleanup");
        this.subs.length = 0;
        delete this.parent;
        delete this.xform;
        delete this.last;
    }
}

const sync = (opts) => new StreamSync(opts);
class StreamSync extends Subscription {
    constructor(opts) {
        const srcIDs = new Set();
        const psync = transducers.partitionSync(srcIDs, {
            key: (x) => x[0],
            mergeOnly: opts.mergeOnly === true,
            reset: opts.reset === true,
            all: opts.all !== false,
            backPressure: opts.backPressure || 0
        });
        const mapv = transducers.mapVals((x) => x[1]);
        super(undefined, optsWithID("streamsync", Object.assign(Object.assign({}, opts), { xform: opts.xform
                ? transducers.comp(psync, mapv, opts.xform)
                : transducers.comp(psync, mapv) })));
        this.sources = new Map();
        this.realSourceIDs = new Map();
        this.invRealSourceIDs = new Map();
        this.idSources = new Map();
        this.sourceIDs = srcIDs;
        opts.src && this.addAll(opts.src);
    }
    add(src, id) {
        id || (id = src.id);
        this.ensureState();
        this.sourceIDs.add(id);
        this.realSourceIDs.set(id, src.id);
        this.invRealSourceIDs.set(src.id, id);
        this.idSources.set(src.id, src);
        this.sources.set(src, src.subscribe({
            next: (x) => {
                if (x[1] instanceof Subscription) {
                    this.add(x[1]);
                }
                else {
                    this.next(x);
                }
            },
            done: () => this.markDone(src),
            __owner: this
        }, transducers.labeled(id), { id: `in-${id}` }));
    }
    addAll(src) {
        if (checks.isPlainObject(src)) {
            for (let id in src) {
                this.sourceIDs.add(id);
            }
            for (let id in src) {
                this.add(src[id], id);
            }
        }
        else {
            for (let s of src) {
                this.sourceIDs.add(s.id);
            }
            for (let s of src) {
                this.add(s);
            }
        }
    }
    remove(src) {
        const sub = this.sources.get(src);
        if (sub) {
            const id = this.invRealSourceIDs.get(src.id);
            exports.LOGGER.info(`removing src: ${src.id} (${id})`);
            this.sourceIDs.delete(id);
            this.realSourceIDs.delete(id);
            this.invRealSourceIDs.delete(src.id);
            this.idSources.delete(src.id);
            this.sources.delete(src);
            sub.unsubscribe();
            return true;
        }
        return false;
    }
    removeID(id) {
        const src = this.getSourceForID(id);
        return src ? this.remove(src) : false;
    }
    removeAll(src) {
        for (let s of src) {
            this.sourceIDs.delete(this.invRealSourceIDs.get(s.id));
        }
        let ok = true;
        for (let s of src) {
            ok = this.remove(s) && ok;
        }
        return ok;
    }
    removeAllIDs(ids) {
        let ok = true;
        for (let id of ids) {
            ok = this.removeID(id) && ok;
        }
        return ok;
    }
    getSourceForID(id) {
        return this.idSources.get(this.realSourceIDs.get(id));
    }
    getSources() {
        const res = {};
        for (let [id, src] of this.idSources) {
            res[this.invRealSourceIDs.get(id)] = src;
        }
        return res;
    }
    unsubscribe(sub) {
        if (!sub) {
            for (let s of this.sources.values()) {
                s.unsubscribe();
            }
            this.state = 2 ;
            this.sources.clear();
            this.sourceIDs.clear();
            this.realSourceIDs.clear();
            this.invRealSourceIDs.clear();
            this.idSources.clear();
        }
        return super.unsubscribe(sub);
    }
    markDone(src) {
        this.remove(src);
        if (this.closeIn === 1  ||
            (this.closeIn === 2  && !this.sources.size)) {
            this.done();
        }
    }
}

const inlineWorker = (src) => makeWorker(new Blob([src], { type: "text/javascript" }));
const makeWorker = (worker) => worker instanceof Worker
    ? worker
    : new Worker(worker instanceof Blob ? URL.createObjectURL(worker) : worker);

const tunnel = (opts) => new Tunnel(opts);
class Tunnel extends Subscription {
    constructor(opts) {
        super(undefined, { id: opts.id || `tunnel-${nextID()}` });
        this.src = opts.src;
        this.workers = new Array(opts.maxWorkers || 1);
        this.transferables = opts.transferables;
        this.terminate = opts.terminate || 1000;
        this.interrupt = opts.interrupt || false;
        this.index = 0;
    }
    next(x) {
        if (this.state < 2 ) {
            let tx;
            if (this.transferables) {
                tx = this.transferables(x);
            }
            let worker = this.workers[this.index];
            if (this.interrupt && worker) {
                worker.terminate();
                worker = null;
            }
            if (!worker) {
                this.workers[this.index++] = worker = makeWorker(this.src);
                this.index %= this.workers.length;
                worker.addEventListener("message", (e) => this.dispatch(e.data));
                worker.addEventListener("error", (e) => this.error(e));
            }
            worker.postMessage(x, tx || []);
        }
    }
    done() {
        super.done();
        if (this.terminate > 0) {
            setTimeout(() => {
                exports.LOGGER.info("terminating workers...");
                this.workers.forEach((worker) => worker && worker.terminate());
                delete this.workers;
            }, this.terminate);
        }
    }
}

const forkJoin = (opts) => {
    const numWorkers = opts.numWorkers || navigator.hardwareConcurrency || 4;
    const workerIDs = transducers.range(numWorkers);
    return sync({
        src: [
            ...transducers.map((id) => opts.src
                .transform(transducers.map((x) => opts.fork(id, numWorkers, x)))
                .subscribe(tunnel({
                src: opts.worker,
                transferables: opts.transferables,
                interrupt: opts.interrupt === true,
                terminate: opts.terminate,
                id: String(id)
            })), workerIDs)
        ],
        xform: transducers.comp(
        transducers.map((results) => [...transducers.map((id) => results[id], workerIDs)]),
        transducers.map(opts.join)),
        reset: true,
        backPressure: opts.backPressure
    });
};
const forkBuffer = (minChunkSize = 1) => (id, numWorkers, buf) => {
    const chunkSize = Math.max(minChunkSize, (buf.length / numWorkers) | 0);
    return id < numWorkers - 1
        ? buf.slice(id * chunkSize, (id + 1) * chunkSize)
        : buf.slice(id * chunkSize);
};
const joinBuffer = (fn) => fn
    ? (parts) => [...transducers.mapcat(fn, parts)]
    : (parts) => Array.prototype.concat.apply([], parts);

const metaStream = (factory, opts) => new MetaStream(factory, opts);
class MetaStream extends Subscription {
    constructor(factory, opts) {
        super(undefined, optsWithID("metastram", opts));
        this.factory = factory;
    }
    next(x) {
        if (this.state < 2 ) {
            if (this.stream) {
                this.stream.unsubscribe(this.sub);
            }
            let stream = this.factory(x);
            if (stream) {
                this.stream = stream;
                this.sub = this.stream.subscribe({
                    next: (x) => {
                        stream === this.stream && super.dispatch(x);
                    },
                    done: () => {
                        this.stream.unsubscribe(this.sub);
                        if (stream === this.stream) {
                            this.stream = undefined;
                            this.sub = undefined;
                        }
                    },
                    error: (e) => super.error(e),
                    __owner: this
                });
            }
        }
    }
    done() {
        if (this.stream) {
            this.detach();
        }
        super.done();
    }
    unsubscribe(sub) {
        if (this.stream && (!sub || this.subs.length === 1)) {
            this.detach();
        }
        return super.unsubscribe();
    }
    detach() {
        api.assert(!!this.stream, "input stream already removed");
        this.stream.unsubscribe(this.sub);
        delete this.stream;
        delete this.sub;
    }
}

const pubsub = (opts) => new PubSub(opts);
class PubSub extends Subscription {
    constructor(opts) {
        opts = opts || {};
        super(undefined, optsWithID("pubsub", {
            xform: opts.xform
        }));
        this.topicfn = opts.topic;
        this.topics = new associative.EquivMap(undefined, {
            equiv: opts.equiv
        });
    }
    subscribe() {
        return errors.unsupported(`use subscribeTopic() instead`);
    }
    transform() {
        return errors.unsupported(`use subscribeTopic() instead`);
    }
    subscribeTopic(topicID, sub, opts) {
        let t = this.topics.get(topicID);
        !t && this.topics.set(topicID, (t = subscription()));
        return t.subscribe(sub, opts);
    }
    unsubscribeTopic(topicID, sub) {
        const t = this.topics.get(topicID);
        return t ? t.unsubscribe(sub) : false;
    }
    unsubscribe(sub) {
        if (!sub) {
            for (let t of this.topics.values()) {
                t.unsubscribe();
            }
            this.topics.clear();
            return super.unsubscribe();
        }
        return errors.unsupported();
    }
    done() {
        for (let t of this.topics.values()) {
            t.done();
        }
        super.done();
    }
    dispatch(x) {
        exports.LOGGER.debug(this.id, "dispatch", x);
        const t = this.topicfn(x);
        if (t !== undefined) {
            const sub = this.topics.get(t);
            if (sub) {
                try {
                    sub.next && sub.next(x);
                }
                catch (e) {
                    sub.error ? sub.error(e) : this.error(e);
                }
            }
        }
    }
}

function stream(src, opts) {
    return new Stream(src, opts);
}
class Stream extends Subscription {
    constructor(src, opts) {
        const [_src, _opts] = checks.isFunction(src) ? [src, opts] : [undefined, src];
        super(undefined, optsWithID("stream", _opts));
        this.src = _src;
        this._inited = false;
    }
    subscribe(...args) {
        const wrapped = super.subscribe.apply(this, args);
        if (!this._inited) {
            this._cancel = (this.src && this.src(this)) || (() => void 0);
            this._inited = true;
        }
        return wrapped;
    }
    unsubscribe(sub) {
        const res = super.unsubscribe(sub);
        if (res &&
            (!sub ||
                ((!this.subs || !this.subs.length) &&
                    this.closeOut !== 0 ))) {
            this.cancel();
        }
        return res;
    }
    done() {
        this.cancel();
        super.done();
        delete this.src;
        delete this._cancel;
    }
    error(e) {
        super.error(e);
        this.cancel();
    }
    cancel() {
        if (this._cancel) {
            exports.LOGGER.debug(this.id, "cancel");
            const f = this._cancel;
            delete this._cancel;
            f();
        }
    }
}

const merge = (opts) => new StreamMerge(opts);
class StreamMerge extends Subscription {
    constructor(opts) {
        opts = opts || {};
        super(undefined, optsWithID("streammerge", opts));
        this.sources = new Map();
        opts.src && this.addAll(opts.src);
    }
    add(src) {
        this.ensureState();
        this.sources.set(src, src.subscribe({
            next: (x) => {
                if (x instanceof Subscription) {
                    this.add(x);
                }
                else {
                    this.next(x);
                }
            },
            done: () => this.markDone(src),
            __owner: this
        }, { id: `in-${src.id}` }));
    }
    addAll(src) {
        for (let s of src) {
            this.add(s);
        }
    }
    remove(src) {
        const sub = this.sources.get(src);
        if (sub) {
            this.sources.delete(src);
            sub.unsubscribe();
            return true;
        }
        return false;
    }
    removeID(id) {
        for (let s of this.sources) {
            if (s[0].id === id) {
                return this.remove(s[0]);
            }
        }
        return false;
    }
    removeAll(src) {
        let ok = true;
        for (let s of src) {
            ok = this.remove(s) && ok;
        }
        return ok;
    }
    removeAllIDs(ids) {
        let ok = true;
        for (let id of ids) {
            ok = this.removeID(id) && ok;
        }
        return ok;
    }
    unsubscribe(sub) {
        if (!sub) {
            for (let s of this.sources.values()) {
                s.unsubscribe();
            }
            this.state = 2 ;
            this.sources.clear();
        }
        return super.unsubscribe(sub);
    }
    markDone(src) {
        this.remove(src);
        if (this.closeIn === 1  ||
            (this.closeIn === 2  && !this.sources.size)) {
            this.done();
        }
    }
}

const fromIterable = (src, opts = {}) => new Stream((stream) => {
    const iter = src[Symbol.iterator]();
    const id = setInterval(() => {
        let val;
        if ((val = iter.next()).done) {
            clearInterval(id);
            stream.closeIn !== 0  && stream.done();
        }
        else {
            stream.next(val.value);
        }
    }, opts.delay || 0);
    return () => clearInterval(id);
}, optsWithID("iterable", opts));
const fromIterableSync = (src, opts) => new Stream((stream) => {
    for (let s of src) {
        stream.next(s);
    }
    stream.closeIn !== 0  && stream.done();
}, optsWithID("iterable-sync", opts));

function trigger(x = true) {
    return fromIterable([x], optsWithID("trigger"));
}

const fromInterval = (delay, opts) => {
    opts = optsWithID("interval", Object.assign({ num: Infinity }, opts));
    return new Stream((stream) => {
        let i = 0;
        let count = opts.num;
        stream.next(i++);
        let id = setInterval(() => {
            stream.next(i++);
            if (--count <= 0) {
                clearInterval(id);
                stream.closeIn !== 0  && stream.done();
            }
        }, delay);
        return () => clearInterval(id);
    }, opts);
};

const fromRAF = (opts) => checks.isNode()
    ? fromInterval(16, opts)
    : new Stream((stream) => {
        let i = 0;
        let isActive = true;
        let loop = () => {
            isActive && stream.next(i++);
            isActive && (id = requestAnimationFrame(loop));
        };
        let id = requestAnimationFrame(loop);
        return () => {
            isActive = false;
            cancelAnimationFrame(id);
        };
    }, optsWithID("raf", opts));

const tween = (src, initial, mix, stop, clock) => sync({
    src: {
        src,
        _: clock == null
            ? fromRAF()
            : checks.isNumber(clock)
                ? fromInterval(clock)
                : clock
    },
    closeIn: 1
}).transform(transducers.scan(transducers.reducer(() => initial, (acc, { src }) => mix(acc, src))), transducers.dedupe(stop || (() => false)));
const tweenNumber = (src, init = 0, speed = 0.05, eps = 1e-3, clock) => tween(src, init, (a, b) => a + (b - a) * speed, (a, b) => Math.abs(a - b) < eps, clock);

const fromAtom = (atom, opts) => {
    opts = optsWithID("atom", Object.assign({ emitFirst: true, changed: (a, b) => a !== b }, opts));
    return new Stream((stream) => {
        atom.addWatch(stream.id, (_, prev, curr) => {
            if (opts.changed(prev, curr)) {
                stream.next(curr);
            }
        });
        opts.emitFirst && stream.next(atom.deref());
        return () => atom.removeWatch(stream.id);
    }, opts);
};

const fromEvent = (src, name, listenerOpts = false, streamOpts) => new Stream((stream) => {
    let listener = (e) => stream.next(e);
    src.addEventListener(name, listener, listenerOpts);
    return () => src.removeEventListener(name, listener, listenerOpts);
}, optsWithID(`event-${name}`, streamOpts));
const fromDOMEvent = (src, name, listenerOpts = false, streamOpts) => fromEvent(src, name, listenerOpts, streamOpts);

const fromPromise = (src, opts) => {
    let canceled = false;
    let isError = false;
    let err = {};
    src.catch((e) => {
        err = e;
        isError = true;
    });
    return new Stream((stream) => {
        src.then((x) => {
            if (!canceled && stream.getState() < 2 ) {
                if (isError) {
                    stream.error(err);
                    err = null;
                }
                else {
                    stream.next(x);
                    stream.closeIn !== 0  && stream.done();
                }
            }
        }, (e) => stream.error(e));
        return () => {
            canceled = true;
        };
    }, optsWithID("promise", opts));
};

const fromPromises = (promises, opts) => fromPromise(Promise.all(promises), optsWithID("promises", opts)).transform(transducers.mapcat((x) => x));

const fromView = (atom$1, opts) => {
    opts = optsWithID("view", opts);
    return new Stream((stream) => {
        let isActive = true;
        const tx = opts.tx;
        const view = new atom.View(atom$1, opts.path, tx
            ? (x) => isActive && ((x = tx(x)), stream.next(x), x)
            : (x) => isActive && (stream.next(x), x), false, opts.equiv);
        return () => {
            isActive = false;
            view.release();
        };
    });
};

const fromWorker = (worker, opts) => {
    const _worker = makeWorker(worker);
    opts = optsWithID("worker", opts);
    return new Stream((stream) => {
        const ml = (e) => {
            stream.next(e.data);
        };
        const el = (e) => {
            stream.error(e.data);
        };
        _worker.addEventListener("message", ml);
        _worker.addEventListener("error", el);
        return () => {
            _worker.removeEventListener("message", ml);
            _worker.removeEventListener("error", el);
            if (opts.terminate !== false) {
                exports.LOGGER.info("terminating worker", _worker);
                _worker.terminate();
            }
        };
    }, opts);
};

class ASidechain extends Subscription {
    constructor(opts) {
        super(undefined, opts);
    }
    unsubscribe(sub) {
        const res = super.unsubscribe(sub);
        if (!sub || !this.subs.length) {
            this.sideSub.unsubscribe();
        }
        return res;
    }
    done() {
        this.sideSub.unsubscribe();
        super.done();
    }
}

const bisect = (pred, truthy, falsy) => {
    const sub = new PubSub({ topic: pred });
    truthy && sub.subscribeTopic(true, truthy);
    falsy && sub.subscribeTopic(false, falsy);
    return sub;
};

const postWorker = (worker, transfer = false, terminate = 0) => {
    const _worker = makeWorker(worker);
    return {
        next(x) {
            if (x instanceof Promise) {
                x.then((y) => this.next(y));
                return;
            }
            let tx;
            if (transfer) {
                const ta = checks.isTypedArray(x);
                if (ta || checks.isTransferable(x)) {
                    tx = [ta ? x.buffer : x];
                }
            }
            _worker.postMessage(x, tx || []);
        },
        done() {
            if (terminate > 0) {
                setTimeout(() => {
                    exports.LOGGER.info("terminating worker...");
                    _worker.terminate();
                }, terminate);
            }
        }
    };
};

const resolve = (opts) => new Resolver(opts);
class Resolver extends Subscription {
    constructor(opts = {}) {
        super(undefined, optsWithID("resolve"));
        this.outstanding = 0;
        this.fail = opts.fail;
    }
    next(x) {
        this.outstanding++;
        x.then((y) => {
            if (this.state < 2 ) {
                this.dispatch(y);
                if (--this.outstanding === 0) {
                    this.done();
                }
            }
            else {
                exports.LOGGER.warn(`resolved value in state ${this.state} (${x})`);
            }
        }, (e) => {
            if (this.fail) {
                this.fail(e);
            }
            else {
                this.error(e);
            }
        });
    }
    done() {
        if (this.parent.getState() === 2  && this.outstanding === 0) {
            super.done();
        }
    }
}

const sidechainPartition = (side, opts) => new SidechainPartition(side, opts);
class SidechainPartition extends ASidechain {
    constructor(side, opts) {
        opts = optsWithID("sidepart", opts);
        super(opts);
        this.buf = [];
        const pred = opts.pred || (() => true);
        const $this = this;
        this.sideSub = side.subscribe({
            next(x) {
                if ($this.buf.length && pred(x)) {
                    $this.dispatch($this.buf);
                    $this.buf = [];
                }
            },
            done() {
                if ($this.buf.length) {
                    $this.dispatch($this.buf);
                }
                $this.done();
                delete $this.buf;
            }
        });
    }
    next(x) {
        if (this.state < 2 ) {
            this.buf.push(x);
        }
    }
}

const sidechainToggle = (side, opts) => new SidechainToggle(side, opts);
class SidechainToggle extends ASidechain {
    constructor(side, opts) {
        opts = optsWithID("sidetoggle", opts);
        super(opts);
        this.isActive = !!opts.initial;
        const pred = opts.pred || (() => true);
        const $this = this;
        this.sideSub = side.subscribe({
            next(x) {
                if (pred(x)) {
                    $this.isActive = !$this.isActive;
                }
            },
            done() {
                $this.done();
            }
        });
    }
    next(x) {
        if (this.isActive && this.state < 2 ) {
            super.next(x);
        }
    }
}

const timeout = (timeoutMs, opts) => new Timeout(timeoutMs, opts);
class Timeout extends Subscription {
    constructor(timeoutMs, opts) {
        opts = optsWithID("timeout", opts);
        super(undefined, opts);
        this.timeoutMs = timeoutMs;
        this.errorObj = opts.error;
        this.resetTimeout = opts.reset === true;
        this.reset();
    }
    next(x) {
        if (this.resetTimeout) {
            clearTimeout(this.timeoutId);
            this.reset();
        }
        super.next(x);
    }
    reset() {
        this.timeoutId = setTimeout(() => {
            if (this.state < 2 ) {
                this.error(this.errorObj ||
                    new Error(`Timeout stream "${this.id}" after ${this.timeoutMs} ms`));
            }
        }, this.timeoutMs);
    }
    cleanup() {
        clearTimeout(this.timeoutId);
        super.cleanup();
    }
}

const trace = (prefix) => ({
    next(x) {
        prefix ? console.log(prefix, x) : console.log(x);
    },
    done() {
        prefix ? console.log(prefix, "done") : console.log("done");
    },
    error(e) {
        prefix ? console.log(prefix, "error", e) : console.log("error", e);
    }
});

const transduce = (src, xform, rfn, init) => {
    let acc = init !== undefined ? init : rfn[0]();
    let sub;
    return new Promise((resolve, reject) => {
        sub = src.subscribe({
            next(x) {
                const _acc = rfn[2](acc, x);
                if (transducers.isReduced(_acc)) {
                    resolve(_acc.deref());
                }
                else {
                    acc = _acc;
                }
            },
            done() {
                resolve(acc);
            },
            error(e) {
                reject(e);
            }
        }, xform);
    }).then((fulfilled) => {
        sub.unsubscribe();
        return fulfilled;
    }, (rejected) => {
        sub.unsubscribe();
        throw rejected;
    });
};

exports.ASidechain = ASidechain;
exports.MetaStream = MetaStream;
exports.PubSub = PubSub;
exports.Resolver = Resolver;
exports.SidechainPartition = SidechainPartition;
exports.SidechainToggle = SidechainToggle;
exports.Stream = Stream;
exports.StreamMerge = StreamMerge;
exports.StreamSync = StreamSync;
exports.Subscription = Subscription;
exports.Tunnel = Tunnel;
exports.bisect = bisect;
exports.forkBuffer = forkBuffer;
exports.forkJoin = forkJoin;
exports.fromAtom = fromAtom;
exports.fromDOMEvent = fromDOMEvent;
exports.fromEvent = fromEvent;
exports.fromInterval = fromInterval;
exports.fromIterable = fromIterable;
exports.fromIterableSync = fromIterableSync;
exports.fromPromise = fromPromise;
exports.fromPromises = fromPromises;
exports.fromRAF = fromRAF;
exports.fromView = fromView;
exports.fromWorker = fromWorker;
exports.inlineWorker = inlineWorker;
exports.joinBuffer = joinBuffer;
exports.makeWorker = makeWorker;
exports.merge = merge;
exports.metaStream = metaStream;
exports.nextID = nextID;
exports.optsWithID = optsWithID;
exports.postWorker = postWorker;
exports.pubsub = pubsub;
exports.resolve = resolve;
exports.setLogger = setLogger;
exports.sidechainPartition = sidechainPartition;
exports.sidechainToggle = sidechainToggle;
exports.stream = stream;
exports.subscription = subscription;
exports.sync = sync;
exports.timeout = timeout;
exports.trace = trace;
exports.transduce = transduce;
exports.trigger = trigger;
exports.tunnel = tunnel;
exports.tween = tween;
exports.tweenNumber = tweenNumber;
