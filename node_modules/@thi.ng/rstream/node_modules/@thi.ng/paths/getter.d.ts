import type { Fn, Keys, Keys1, Keys2, Keys3, Keys4, Keys5, Keys6, Keys7, Path, Val1, Val2, Val3, Val4, Val5, Val6, Val7, Val8 } from "@thi.ng/api";
/**
 * Composes a getter function for given nested lookup path. Optimized
 * fast execution paths are provided for path lengths <= 4.
 *
 * @remarks
 * Supports any `[]`-indexable data structure (arrays, objects,
 * strings).
 *
 * If `path` is given as string, it will be split using `.`. Returns
 * function which accepts single object and when called, returns value
 * at given path.
 *
 * If any intermediate key is not present in the given obj, descent
 * stops and the function returns `undefined`.
 *
 * If `path` is an empty string or array, the returned getter will
 * simply return the given state arg (identity function).
 *
 * Also see: `getIn()`
 *
 * @example
 * ```ts
 * interface Foo {
 *   a: { b: { c: number; } }
 * }
 *
 * // fully typed getter
 * g = getter<Foo, "a", "b", "c">(["a","b","c"]);
 *
 * // error (wrong `d` key)
 * g = getter<Foo, "a", "b", "d">(["a","b","d"]);
 *
 * // unchecked (accepts any, returns any)
 * g = getter("a.b.c");
 *
 * g({ a: { b: { c: 23} } }) // 23
 * g({ x: 23 }) // undefined
 * g() // undefined
 * ```
 *
 * @param path -
 */
export declare const getter: (path: Path) => Fn<any, any>;
/**
 * Type checked version of {@link getter}.
 *
 * @param path -
 */
export declare function getterT<T>(path: []): Fn<T, T>;
export declare function getterT<T, A extends Keys<T>>(path: [A]): Fn<T, Val1<T, A>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>>(path: [A, B]): Fn<T, Val2<T, A, B>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>>(path: [A, B, C]): Fn<T, Val3<T, A, B, C>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>>(path: [A, B, C, D]): Fn<T, Val4<T, A, B, C, D>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>, E extends Keys4<T, A, B, C, D>>(path: [A, B, C, D, E]): Fn<T, Val5<T, A, B, C, D, E>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>, E extends Keys4<T, A, B, C, D>, F extends Keys5<T, A, B, C, D, E>>(path: [A, B, C, D, E, F]): Fn<T, Val6<T, A, B, C, D, E, F>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>, E extends Keys4<T, A, B, C, D>, F extends Keys5<T, A, B, C, D, E>, G extends Keys6<T, A, B, C, D, E, F>>(path: [A, B, C, D, E, F, G]): Fn<T, Val7<T, A, B, C, D, E, F, G>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>, E extends Keys4<T, A, B, C, D>, F extends Keys5<T, A, B, C, D, E>, G extends Keys6<T, A, B, C, D, E, F>, H extends Keys7<T, A, B, C, D, E, F, G>>(path: [A, B, C, D, E, F, G, H]): Fn<T, Val8<T, A, B, C, D, E, F, G, H>>;
export declare function getterT<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>, E extends Keys4<T, A, B, C, D>, F extends Keys5<T, A, B, C, D, E>, G extends Keys6<T, A, B, C, D, E, F>, H extends Keys7<T, A, B, C, D, E, F, G>>(path: [A, B, C, D, E, F, G, H, ...any[]]): Fn<T, any>;
//# sourceMappingURL=getter.d.ts.map