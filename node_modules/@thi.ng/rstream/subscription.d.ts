import { IDeref } from "@thi.ng/api";
import { Reducer, Transducer } from "@thi.ng/transducers";
import { CloseMode, CommonOpts, ISubscribable, ISubscriber, ITransformable, State, SubscriptionOpts } from "./api";
/**
 * Creates a new {@link Subscription} instance, the fundamental datatype
 * and building block provided by this package.
 *
 * @remarks
 * Most other types in rstream, including {@link Stream}s, are
 * `Subscription`s and all can be:
 *
 * - linked into directed graphs (sync or async & not necessarily DAGs)
 * - transformed using transducers (incl. support for early termination)
 * - can have any number of subscribers (optionally each w/ their own
 *   transducers)
 * - recursively unsubscribe themselves from parent after their last
 *   subscriber unsubscribed (configurable)
 * - will go into a non-recoverable error state if none of the
 *   subscribers has an error handler itself
 * - implement the {@link @thi.ng/api#IDeref} interface
 *
 * Subscription behavior can be customized via the additional (optional)
 * options arg. See `CommonOpts` and `SubscriptionOpts` for further
 * details.
 *
 * @example
 * ```ts
 * // as reactive value mechanism (same as with stream() above)
 * s = subscription();
 * s.subscribe(trace("s1"));
 * s.subscribe(trace("s2"), { xform: tx.filter((x) => x > 25) });
 *
 * // external trigger
 * s.next(23);
 * // s1 23
 * s.next(42);
 * // s1 42
 * // s2 42
 * ```
 *
 * @param sub -
 * @param opts -
 */
export declare const subscription: <A, B>(sub?: ISubscriber<B> | undefined, opts?: Partial<SubscriptionOpts<A, B>> | undefined) => Subscription<A, B>;
export declare class Subscription<A, B> implements IDeref<B | undefined>, ISubscriber<A>, ISubscribable<B>, ITransformable<B> {
    id: string;
    closeIn: CloseMode;
    closeOut: CloseMode;
    protected parent?: ISubscribable<A>;
    protected subs: ISubscriber<B>[];
    protected xform?: Reducer<B[], A>;
    protected state: State;
    protected cacheLast: boolean;
    protected last: any;
    constructor(sub?: ISubscriber<B>, opts?: Partial<SubscriptionOpts<A, B>>);
    deref(): B | undefined;
    getState(): State;
    /**
     * Creates new child subscription with given subscriber and/or
     * transducer and optional subscription ID.
     */
    subscribe(sub: Partial<ISubscriber<B>>, opts?: Partial<CommonOpts>): Subscription<B, B>;
    subscribe<C>(sub: Subscription<B, C>): Subscription<B, C>;
    subscribe<C>(xform: Transducer<B, C>, opts?: Partial<CommonOpts>): Subscription<B, C>;
    subscribe<C>(sub: Partial<ISubscriber<C>>, xform: Transducer<B, C>, opts?: Partial<CommonOpts>): Subscription<B, C>;
    /**
     * Returns array of new child subscriptions for all given
     * subscribers.
     *
     * @param subs -
     */
    subscribeAll(...subs: ISubscriber<B>[]): Subscription<B, B>[];
    /**
     * Creates a new child subscription using given transducers and
     * optional subscription ID. Supports up to 4 transducers and if
     * more than one transducer is given, composes them in left-to-right
     * order using {@link @thi.ng/transducers#(comp:1)}.
     *
     * Shorthand for `subscribe(comp(xf1, xf2,...), id)`
     */
    transform<C>(a: Transducer<B, C>, opts?: Partial<CommonOpts>): Subscription<B, C>;
    transform<C, D>(a: Transducer<B, C>, b: Transducer<C, D>, opts?: Partial<CommonOpts>): Subscription<B, D>;
    transform<C, D, E>(a: Transducer<B, C>, b: Transducer<C, D>, c: Transducer<D, E>, opts?: Partial<CommonOpts>): Subscription<B, E>;
    transform<C, D, E, F>(a: Transducer<B, C>, b: Transducer<C, D>, c: Transducer<D, E>, d: Transducer<E, F>, opts?: Partial<CommonOpts>): Subscription<B, F>;
    /**
     * If called without arg, removes this subscription from parent (if
     * any), cleans up internal state and goes into DONE state. If
     * called with arg, removes the sub from internal pool and if no
     * other subs are remaining also cleans up itself and goes into DONE
     * state.
     *
     * @param sub -
     */
    unsubscribe(sub?: Subscription<B, any>): boolean;
    next(x: A): void;
    done(): void;
    error(e: any): void;
    protected addWrapped(wrapped: Subscription<any, any>): Subscription<any, any>;
    protected dispatch(x: B): void;
    protected ensureState(): void;
    protected cleanup(): void;
}
//# sourceMappingURL=subscription.d.ts.map