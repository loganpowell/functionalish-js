import { SEMAPHORE } from "@thi.ng/api";
import { peek } from "@thi.ng/arrays";
import { implementsFunction, isFunction, isPlainObject } from "@thi.ng/checks";
import { illegalArity, illegalState } from "@thi.ng/errors";
import { comp, isReduced, push, unreduced } from "@thi.ng/transducers";
import { LOGGER } from "./api";
import { nextID } from "./utils/idgen";
/**
 * Creates a new {@link Subscription} instance, the fundamental datatype
 * and building block provided by this package.
 *
 * @remarks
 * Most other types in rstream, including {@link Stream}s, are
 * `Subscription`s and all can be:
 *
 * - linked into directed graphs (sync or async & not necessarily DAGs)
 * - transformed using transducers (incl. support for early termination)
 * - can have any number of subscribers (optionally each w/ their own
 *   transducers)
 * - recursively unsubscribe themselves from parent after their last
 *   subscriber unsubscribed (configurable)
 * - will go into a non-recoverable error state if none of the
 *   subscribers has an error handler itself
 * - implement the {@link @thi.ng/api#IDeref} interface
 *
 * Subscription behavior can be customized via the additional (optional)
 * options arg. See `CommonOpts` and `SubscriptionOpts` for further
 * details.
 *
 * @example
 * ```ts
 * // as reactive value mechanism (same as with stream() above)
 * s = subscription();
 * s.subscribe(trace("s1"));
 * s.subscribe(trace("s2"), { xform: tx.filter((x) => x > 25) });
 *
 * // external trigger
 * s.next(23);
 * // s1 23
 * s.next(42);
 * // s1 42
 * // s2 42
 * ```
 *
 * @param sub -
 * @param opts -
 */
export const subscription = (sub, opts) => new Subscription(sub, opts);
export class Subscription {
    constructor(sub, opts = {}) {
        this.state = 0 /* IDLE */;
        this.parent = opts.parent;
        this.closeIn =
            opts.closeIn !== undefined ? opts.closeIn : 2 /* LAST */;
        this.closeOut =
            opts.closeOut !== undefined ? opts.closeOut : 2 /* LAST */;
        this.cacheLast = opts.cache !== false;
        this.id = opts.id || `sub-${nextID()}`;
        this.last = SEMAPHORE;
        this.subs = [];
        if (sub) {
            this.subs.push(sub);
        }
        if (opts.xform) {
            this.xform = opts.xform(push());
        }
    }
    deref() {
        return this.last !== SEMAPHORE ? this.last : undefined;
    }
    getState() {
        return this.state;
    }
    subscribe(...args) {
        this.ensureState();
        let sub;
        let opts = args.length > 1 && isPlainObject(peek(args))
            ? Object.assign({}, args.pop()) : {};
        switch (args.length) {
            case 1:
                if (isFunction(args[0])) {
                    opts.xform = args[0];
                    !opts.id && (opts.id = `xform-${nextID()}`);
                }
                else {
                    sub = args[0];
                }
                break;
            case 2:
                sub = args[0];
                opts.xform = args[1];
                break;
            default:
                illegalArity(args.length);
        }
        if (implementsFunction(sub, "subscribe")) {
            sub.parent = this;
        }
        else {
            // FIXME inherit options from this sub or defaults?
            sub = subscription(sub, Object.assign({ parent: this }, opts));
        }
        this.last !== SEMAPHORE && sub.next(this.last);
        return this.addWrapped(sub);
    }
    /**
     * Returns array of new child subscriptions for all given
     * subscribers.
     *
     * @param subs -
     */
    subscribeAll(...subs) {
        const wrapped = [];
        for (let s of subs) {
            wrapped.push(this.subscribe(s));
        }
        return wrapped;
    }
    transform(...xf) {
        const n = xf.length - 1;
        return isPlainObject(xf[n])
            ? this.subscribe(comp(...xf.slice(0, n)), xf[n])
            : this.subscribe(comp(...xf));
    }
    /**
     * If called without arg, removes this subscription from parent (if
     * any), cleans up internal state and goes into DONE state. If
     * called with arg, removes the sub from internal pool and if no
     * other subs are remaining also cleans up itself and goes into DONE
     * state.
     *
     * @param sub -
     */
    unsubscribe(sub) {
        LOGGER.debug(this.id, "unsub start", sub ? sub.id : "self");
        if (!sub) {
            let res = true;
            if (this.parent) {
                res = this.parent.unsubscribe(this);
            }
            this.state = 2 /* DONE */;
            this.cleanup();
            return res;
        }
        if (this.subs) {
            LOGGER.debug(this.id, "unsub child", sub.id);
            const idx = this.subs.indexOf(sub);
            if (idx >= 0) {
                this.subs.splice(idx, 1);
                if (this.closeOut === 1 /* FIRST */ ||
                    (!this.subs.length && this.closeOut !== 0 /* NEVER */)) {
                    this.unsubscribe();
                }
                return true;
            }
        }
        return false;
    }
    next(x) {
        if (this.state < 2 /* DONE */) {
            if (this.xform) {
                const acc = this.xform[2]([], x);
                const uacc = unreduced(acc);
                const n = uacc.length;
                for (let i = 0; i < n; i++) {
                    this.dispatch(uacc[i]);
                }
                if (isReduced(acc)) {
                    this.done();
                }
            }
            else {
                this.dispatch(x);
            }
        }
    }
    done() {
        LOGGER.debug(this.id, "entering done()");
        if (this.state < 2 /* DONE */) {
            if (this.xform) {
                const acc = this.xform[1]([]);
                const uacc = unreduced(acc);
                const n = uacc.length;
                for (let i = 0; i < n; i++) {
                    this.dispatch(uacc[i]);
                }
            }
            this.state = 2 /* DONE */;
            for (let s of [...this.subs]) {
                try {
                    s.done && s.done();
                }
                catch (e) {
                    s.error ? s.error(e) : this.error(e);
                }
            }
            this.unsubscribe();
            LOGGER.debug(this.id, "exiting done()");
        }
    }
    error(e) {
        this.state = 3 /* ERROR */;
        let notified = false;
        if (this.subs && this.subs.length) {
            for (let s of this.subs.slice()) {
                if (s.error) {
                    s.error(e);
                    notified = true;
                }
            }
        }
        if (!notified) {
            LOGGER.warn(this.id, "unhandled error:", e);
            if (this.parent) {
                LOGGER.debug(this.id, "unsubscribing...");
                this.unsubscribe();
                this.state = 3 /* ERROR */;
            }
        }
    }
    addWrapped(wrapped) {
        this.subs.push(wrapped);
        this.state = 1 /* ACTIVE */;
        return wrapped;
    }
    dispatch(x) {
        // LOGGER.debug(this.id, "dispatch", x);
        this.cacheLast && (this.last = x);
        const subs = this.subs;
        let s;
        if (subs.length === 1) {
            s = subs[0];
            try {
                s.next && s.next(x);
            }
            catch (e) {
                s.error ? s.error(e) : this.error(e);
            }
        }
        else {
            for (let i = subs.length; --i >= 0;) {
                s = subs[i];
                try {
                    s.next && s.next(x);
                }
                catch (e) {
                    s.error ? s.error(e) : this.error(e);
                }
            }
        }
    }
    ensureState() {
        if (this.state >= 2 /* DONE */) {
            illegalState(`operation not allowed in state ${this.state}`);
        }
    }
    cleanup() {
        LOGGER.debug(this.id, "cleanup");
        this.subs.length = 0;
        delete this.parent;
        delete this.xform;
        delete this.last;
    }
}
