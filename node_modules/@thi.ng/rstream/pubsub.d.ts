import { EquivMap } from "@thi.ng/associative";
import { CommonOpts, ISubscriber } from "./api";
import { Subscription } from "./subscription";
import type { Fn, Predicate2 } from "@thi.ng/api";
import type { Transducer } from "@thi.ng/transducers";
export interface PubSubOpts<A, B> {
    /**
     * Topic function. Incoming values will be routed to topic
     * subscriptions using this function's return value.
     */
    topic: Fn<B, any>;
    /**
     * Optional transformer for incoming values. If given, `xform` will
     * be applied first and the transformed value passed to the
     * `topic` fn.
     */
    xform?: Transducer<A, B>;
    /**
     * Equivalence check for topic values. Should return truthy result
     * if given topics are considered equal.
     */
    equiv?: Predicate2<B>;
    /**
     * Optional subscription ID for the PubSub instance.
     */
    id?: string;
}
/**
 * Topic based stream splitter. Applies `topic` function to each
 * received value and only forwards it to the child subscriptions of the
 * returned topic.
 *
 * @remarks
 * The actual topic (return value from `topic` fn) can be of any type,
 * apart from `undefined`. Complex topics (e.g objects / arrays) are
 * allowed and they're matched with registered topics using
 * {@link @thi.ng/equiv#equiv} by default (but customizable via `equiv`
 * option). Each topic can have any number of subscribers.
 *
 * If a `xform` transducer is given, it is always applied prior to
 * passing the input to the topic function. I.e. in this case the topic
 * function will receive the transformed inputs.
 *
 * {@link PubSub} supports dynamic topic subscriptions and
 * unsubscriptions via {@link PubSub.(subscribeTopic:1)} and
 * {@link PubSub.unsubscribeTopic}. However, the standard
 * {@link ISubscribable.(subscribe:1)} /
 * {@link ISubscribable.unsubscribe} methods are NOT supported (since
 * meaningless) and will throw an error! `unsubscribe()` can only be
 * called WITHOUT argument to unsubscribe the entire `PubSub` instance
 * (incl. all topic subscriptions) from the parent stream.
 *
 * @param opts -
 */
export declare const pubsub: <A, B>(opts: PubSubOpts<A, B>) => PubSub<A, B>;
export declare class PubSub<A, B> extends Subscription<A, B> {
    topicfn: Fn<B, any>;
    topics: EquivMap<any, Subscription<B, B>>;
    constructor(opts?: PubSubOpts<A, B>);
    /**
     * Unsupported. Use {@link PubSub.(subscribeTopic:1)} instead.
     */
    subscribe(): Subscription<B, any>;
    /**
     * Unsupported. Use {@link PubSub.(subscribeTopic:1)} instead.
     */
    transform(): Subscription<B, any>;
    subscribeTopic<C>(topicID: any, xform: Transducer<B, C>, opts?: Partial<CommonOpts>): Subscription<B, C>;
    subscribeTopic<C>(topicID: any, opts?: Partial<CommonOpts>): Subscription<B, C>;
    subscribeTopic(topicID: any, sub: Partial<ISubscriber<B>>, opts?: Partial<CommonOpts>): Subscription<B, B>;
    unsubscribeTopic(topicID: any, sub: Subscription<B, any>): boolean;
    unsubscribe(sub: Subscription<B, any>): boolean;
    done(): void;
    protected dispatch(x: B): void;
}
//# sourceMappingURL=pubsub.d.ts.map