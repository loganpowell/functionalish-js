import { Stream } from "../stream";
import { optsWithID } from "../utils/idgen";
/**
 * Returns a {@link Stream} of values from provided iterable, emitted at
 * the given `delay` interval.
 *
 * @remarks
 * Asynchronously starts pulling values from source iterable when the
 * first subscriber becomes available. The values are processed &
 * emitted via `setInterval()`, using the given `delay` value (default:
 * 0). By default, once the iterable is exhausted (if finite), calls
 * {@link ISubscriber.done} to close the stream, but this can be
 * re-configured via provided {@link CommonOpts | options}.
 *
 * @param src -
 * @param opts -
 */
export const fromIterable = (src, opts = {}) => new Stream((stream) => {
    const iter = src[Symbol.iterator]();
    const id = setInterval(() => {
        let val;
        if ((val = iter.next()).done) {
            clearInterval(id);
            stream.closeIn !== 0 /* NEVER */ && stream.done();
        }
        else {
            stream.next(val.value);
        }
    }, opts.delay || 0);
    return () => clearInterval(id);
}, optsWithID("iterable", opts));
/**
 * Creates a new {@link Stream} of given iterable which synchronously calls
 * `.next()` for each item of the iterable when the first (and in this
 * case the only one) subscriber becomes available. Once the iterable is
 * exhausted (MUST be finite!), then calls `.done()` by default, but can
 * be avoided by passing `false` as last argument.
 *
 * @param src -
 * @param opts -
 */
export const fromIterableSync = (src, opts) => new Stream((stream) => {
    for (let s of src) {
        stream.next(s);
    }
    stream.closeIn !== 0 /* NEVER */ && stream.done();
}, optsWithID("iterable-sync", opts));
