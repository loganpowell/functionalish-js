'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var checks = require('@thi.ng/checks');
var errors = require('@thi.ng/errors');
var transducers = require('@thi.ng/transducers');

const DEFAULT_VENDORS = ["-moz-", "-ms-", "-o-", "-webkit-"];
const COMPACT = {
    rules: "",
    ruleSep: ",",
    valSep: "",
    decls: "",
    declStart: "{",
    declEnd: "}",
    indent: "",
    comments: false
};
const PRETTY = {
    rules: "\n",
    ruleSep: ", ",
    valSep: " ",
    decls: "\n",
    declStart: " {\n",
    declEnd: "}\n",
    indent: "    ",
    comments: true
};

const EMPTY = new Set();
const NO_SPACES = ":[";
const xfSel = transducers.comp(transducers.flatten(), transducers.map((x) => (NO_SPACES.indexOf(x.charAt(0)) >= 0 ? x : " " + x)));
const withScope = (xf, scope) => transducers.comp(xf, transducers.map((x) => (checks.isString(x) && x.indexOf(" .") == 0 ? x + scope : x)));
const expand = (acc, parent, rules, opts) => {
    const n = rules.length;
    const sel = [];
    let curr, isFn;
    const process = (i, r) => {
        let rfn = null;
        if (checks.isArray(r)) {
            expand(acc, makeSelector(parent, sel), r, opts);
        }
        else if (checks.isIterable(r) && !checks.isString(r)) {
            expand(acc, makeSelector(parent, sel), [...r], opts);
        }
        else if ((isFn = checks.isFunction(r)) || (rfn = opts.fns[r])) {
            if (!parent.length) {
                if (rfn) {
                    rfn.apply(null, rules.slice(i + 1))(acc, opts);
                    return true;
                }
                r(acc, opts);
            }
            else if (isFn) {
                process(i, r());
            }
            else {
                errors.illegalArgs(`quoted fn ('${r}') only allowed at head position`);
            }
        }
        else if (checks.isPlainObject(r)) {
            curr = Object.assign(curr || {}, r);
        }
        else if (r != null) {
            sel.push(r);
        }
    };
    for (let i = 0; i < n; i++) {
        if (process(i, rules[i])) {
            return acc;
        }
    }
    curr && acc.push(formatRule(parent, sel, curr, opts));
    return acc;
};
const makeSelector = (parent, curr) => parent.length ? [...transducers.permutations(parent, curr)] : curr;
const formatRule = (parent, sel, curr, opts) => {
    const f = opts.format;
    const space = indent(opts);
    const xf = opts.scope ? withScope(xfSel, opts.scope) : xfSel;
    return [
        space,
        transducers.transduce(transducers.map((sel) => transducers.transduce(xf, transducers.str(), checks.isArray(sel) ? sel : [sel]).trim()), transducers.str(f.ruleSep), makeSelector(parent, sel)),
        f.declStart,
        formatDecls(curr, opts),
        space,
        f.declEnd
    ].join("");
};
const formatDecls = (rules, opts) => {
    const f = opts.format;
    const prefixes = (opts.autoprefix || EMPTY);
    const space = indent(opts, opts.depth + 1);
    const acc = [];
    for (let r in rules) {
        if (rules.hasOwnProperty(r)) {
            let val = rules[r];
            if (checks.isFunction(val)) {
                val = val(rules);
            }
            if (checks.isArray(val)) {
                val = val
                    .map((v) => (checks.isArray(v) ? v.join(" ") : v))
                    .join(f.ruleSep);
            }
            if (prefixes.has(r)) {
                for (let v of opts.vendors) {
                    acc.push(`${space}${v}${r}:${f.valSep}${val};`);
                }
            }
            acc.push(`${space}${r}:${f.valSep}${val};`);
        }
    }
    return acc.join(f.decls) + f.decls;
};
const indent = (opts, d = opts.depth) => d > 1
    ? [...transducers.repeat(opts.format.indent, d)].join("")
    : d > 0
        ? opts.format.indent
        : "";

const em = (x) => `${x}em`;
const ex = (x) => `${x}ex`;
const rem = (x) => `${x}rem`;
const percent = (x) => `${x}%`;
const px = (x) => `${x >>> 0}px`;
const vh = (x) => `${x}vh`;
const vw = (x) => `${x}vw`;
const ms = (x) => `${x >>> 0}ms`;
const sec = (x) => `${x}s`;
const deg = (x) => `${x}deg`;
const rad = (x) => `${x}rad`;
const turn = (x) => `${x}turn`;

function at_keyframes(id, ...args) {
    const stops = args.length === 1 ? args[0] : { 0: args[0], 100: args[1] };
    return (acc, opts) => {
        const outer = indent(opts);
        opts.depth++;
        const inner = indent(opts);
        acc.push(`${outer}@keyframes ${id}${opts.format.declStart}`);
        for (let s in stops) {
            if (stops.hasOwnProperty(s)) {
                acc.push([
                    inner,
                    percent(s),
                    opts.format.declStart,
                    formatDecls(stops[s], opts),
                    inner,
                    opts.format.declEnd
                ].join(""));
            }
        }
        opts.depth--;
        acc.push(outer + opts.format.declEnd);
        return acc;
    };
}

const animation = (id, opts, ...keyframes) => {
    opts = Object.assign({ duration: "250ms", name: id }, opts);
    return [
        at_keyframes.apply(null, [id, ...keyframes]),
        [
            `.${id}`,
            Object.keys(opts).reduce((acc, k) => ((acc[`animation-${k}`] = opts[k]), acc), {})
        ]
    ];
};

const $ = (op) => (id, x, caseSensitve = false) => `[${id}${op}="${x}"${caseSensitve ? " i" : ""}]`;
const withAttrib = (id) => `[${id}]`;
const attribEq = $("");
const attribContains = $("~");
const attribPrefix = $("^");
const attribSuffix = $("$");
const attribMatches = $("*");

const comment = (body, force = false) => (acc, opts) => {
    const space = indent(opts);
    const inner = indent(opts, opts.depth + 1);
    if (opts.format.comments || force) {
        acc.push(space + "/*", body
            .split("\n")
            .map((l) => inner + l)
            .join("\n"), space + "*/");
    }
    return acc;
};

const conditional = (type, cond, rules) => (acc, opts) => {
    const space = indent(opts);
    acc.push(`${space}${type} ${formatCond(cond)}${opts.format.declStart}`);
    opts.depth++;
    expand(acc, [], rules, opts);
    opts.depth--;
    acc.push(space + opts.format.declEnd);
    return acc;
};
const formatCond = (cond) => {
    if (checks.isString(cond)) {
        return cond;
    }
    const acc = [];
    for (let c in cond) {
        if (cond.hasOwnProperty(c)) {
            let v = cond[c];
            if (v === true) {
                v = c;
            }
            else if (v === false) {
                v = "not " + c;
            }
            else if (v === "only") {
                v += " " + c;
            }
            else {
                v = `(${c}:${v})`;
            }
            acc.push(v);
        }
    }
    return acc.join(" and ");
};

const css = (rules, opts) => {
    opts = Object.assign({ format: COMPACT, vendors: DEFAULT_VENDORS, fns: {}, depth: 0 }, opts);
    if (checks.isPlainObject(rules)) {
        return formatDecls(rules, opts);
    }
    if (checks.isArray(opts.autoprefix)) {
        opts.autoprefix = new Set(opts.autoprefix);
    }
    if (checks.isIterable(rules) && !checks.isString(rules)) {
        rules = [...rules];
    }
    if (checks.isArray(rules)) {
        return expand([], [], rules, opts).join(opts.format.rules);
    }
    if (checks.isFunction(rules)) {
        return rules([], opts).join(opts.format.rules);
    }
};

const at_import = (url, ...queries) => (acc, opts) => (acc.push(queries.length
    ? `@import url(${url}) ${queries.join(opts.format.ruleSep)};`
    : `@import url(${url});`),
    acc);

const injectStyleSheet = (css, first = false) => {
    const head = document.getElementsByTagName("head")[0];
    const sheet = document.createElement("style");
    sheet.setAttribute("type", "text/css");
    if (sheet.styleSheet !== undefined) {
        sheet.styleSheet.cssText = css;
    }
    else {
        sheet.textContent = css;
    }
    if (first) {
        head.insertBefore(sheet, head.firstChild);
    }
    else {
        head.appendChild(sheet);
    }
    return sheet;
};

const at_media = (cond, rules) => conditional("@media", cond, rules);

function at_namespace(...args) {
    return (acc, _) => (acc.push(args.length > 1
        ? `@namespace ${args[0]} url(${args[1]});`
        : `@namespace url(${args[0]});`),
        acc);
}

const at_supports = (cond, rules) => conditional("@supports", cond, rules);

const QUOTED_FNS = {
    "@comment": comment,
    "@import": at_import,
    "@keyframes": at_keyframes,
    "@media": at_media,
    "@namespace": at_namespace,
    "@supports": at_supports
};

exports.COMPACT = COMPACT;
exports.DEFAULT_VENDORS = DEFAULT_VENDORS;
exports.PRETTY = PRETTY;
exports.QUOTED_FNS = QUOTED_FNS;
exports.animation = animation;
exports.at_import = at_import;
exports.at_keyframes = at_keyframes;
exports.at_media = at_media;
exports.at_namespace = at_namespace;
exports.at_supports = at_supports;
exports.attribContains = attribContains;
exports.attribEq = attribEq;
exports.attribMatches = attribMatches;
exports.attribPrefix = attribPrefix;
exports.attribSuffix = attribSuffix;
exports.comment = comment;
exports.conditional = conditional;
exports.css = css;
exports.deg = deg;
exports.em = em;
exports.ex = ex;
exports.injectStyleSheet = injectStyleSheet;
exports.ms = ms;
exports.percent = percent;
exports.px = px;
exports.rad = rad;
exports.rem = rem;
exports.sec = sec;
exports.turn = turn;
exports.vh = vh;
exports.vw = vw;
exports.withAttrib = withAttrib;
