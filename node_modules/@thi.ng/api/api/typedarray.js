/**
 * Type enums for Typedarray-backed buffers.
 *
 * {@link GLType}
 * {@link GL2TYPE}
 * {@link TYPE2GL}
 */
export var Type;
(function (Type) {
    Type[Type["U8"] = 0] = "U8";
    Type[Type["U8C"] = 1] = "U8C";
    Type[Type["I8"] = 2] = "I8";
    Type[Type["U16"] = 3] = "U16";
    Type[Type["I16"] = 4] = "I16";
    Type[Type["U32"] = 5] = "U32";
    Type[Type["I32"] = 6] = "I32";
    Type[Type["F32"] = 7] = "F32";
    Type[Type["F64"] = 8] = "F64";
})(Type || (Type = {}));
/**
 * WebGL numeric type constants. Use {@link GL2TYPE} to convert, if needed.
 *
 * {@link Type}
 * {@link GL2TYPE}
 * {@link TYPE2GL}
 */
export var GLType;
(function (GLType) {
    GLType[GLType["I8"] = 5120] = "I8";
    GLType[GLType["U8"] = 5121] = "U8";
    GLType[GLType["I16"] = 5122] = "I16";
    GLType[GLType["U16"] = 5123] = "U16";
    GLType[GLType["I32"] = 5124] = "I32";
    GLType[GLType["U32"] = 5125] = "U32";
    GLType[GLType["F32"] = 5126] = "F32";
})(GLType || (GLType = {}));
/**
 * Conversion from {@link GLType} to {@link Type} enums.
 */
export const GL2TYPE = {
    [5120 /* I8 */]: 2 /* I8 */,
    [5121 /* U8 */]: 0 /* U8 */,
    [5122 /* I16 */]: 4 /* I16 */,
    [5123 /* U16 */]: 3 /* U16 */,
    [5124 /* I32 */]: 6 /* I32 */,
    [5125 /* U32 */]: 5 /* U32 */,
    [5126 /* F32 */]: 7 /* F32 */
};
/**
 * Potentially lossy conversion from {@link Type} to {@link GLType} enums.
 *
 * Not all enums are mappable:
 *
 * - `F64` maps to `undefined`, since unsupported by WebGL
 * - `U8C` maps to U8
 */
export const TYPE2GL = {
    [2 /* I8 */]: 5120 /* I8 */,
    [0 /* U8 */]: 5121 /* U8 */,
    [1 /* U8C */]: 5121 /* U8 */,
    [4 /* I16 */]: 5122 /* I16 */,
    [3 /* U16 */]: 5123 /* U16 */,
    [6 /* I32 */]: 5124 /* I32 */,
    [6 /* I32 */]: 5124 /* I32 */,
    [5 /* U32 */]: 5125 /* U32 */,
    [7 /* F32 */]: 5126 /* F32 */,
    [8 /* F64 */]: undefined
};
/**
 * Size information (in bytes) for {@link Type} enums. For {@link GLType}, use this
 * form, e.g. `SIZEOF[GL2TYPE[GLType.F32]]`
 */
export const SIZEOF = {
    [0 /* U8 */]: 1,
    [1 /* U8C */]: 1,
    [2 /* I8 */]: 1,
    [3 /* U16 */]: 2,
    [4 /* I16 */]: 2,
    [5 /* U32 */]: 4,
    [6 /* I32 */]: 4,
    [7 /* F32 */]: 4,
    [8 /* F64 */]: 8
};
export const TYPEDARRAY_CTORS = {
    [0 /* U8 */]: Uint8Array,
    [1 /* U8C */]: Uint8ClampedArray,
    [2 /* I8 */]: Int8Array,
    [3 /* U16 */]: Uint16Array,
    [4 /* I16 */]: Int16Array,
    [5 /* U32 */]: Uint32Array,
    [6 /* I32 */]: Int32Array,
    [7 /* F32 */]: Float32Array,
    [8 /* F64 */]: Float64Array,
    [5121 /* U8 */]: Uint8Array,
    [5120 /* I8 */]: Int8Array,
    [5123 /* U16 */]: Uint16Array,
    [5122 /* I16 */]: Int16Array,
    [5125 /* U32 */]: Uint32Array,
    [5124 /* I32 */]: Int32Array,
    [5126 /* F32 */]: Float32Array
};
export function typedArray(type, ...xs) {
    return new TYPEDARRAY_CTORS[type](...xs);
}
/**
 * Returns the smallest possible *unsigned* int type enum for given `x`.
 * E.g. if `x <= 256`, the function returns `Type.U8`.
 *
 * @param x - value to classify
 */
export const uintType = (x) => x <= 0x100 ? 0 /* U8 */ : x <= 0x10000 ? 3 /* U16 */ : 5 /* U32 */;
/**
 * Returns the smallest possible *signed* int type enum for given `x`.
 * E.g. if `x >= -128 && x < 128`, the function returns `Type.I8`.
 *
 * @param x - value to classify
 */
export const intType = (x) => x >= -0x80 && x < 0x80
    ? 2 /* I8 */
    : x >= -0x8000 && x < 0x8000
        ? 4 /* I16 */
        : 6 /* I32 */;
