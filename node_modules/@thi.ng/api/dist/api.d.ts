
export declare type ArrayLikeIterable<T> = ArrayLike<T> & Iterable<T>;

/**
 * Takes a `test` result or predicate function without args and throws
 * error with given `msg` if test failed (i.e. is falsy). The function
 * is only enabled if `NODE_ENV != "production"` or if
 * `UMBRELLA_ASSERTS = 1`.
 */
export declare const assert: (test: boolean | Fn0<boolean>, msg?: string | Fn0<string>) => void;

/**
 * Generic 2-element comparator function type alias. Must follow this
 * contract and return:
 *
 * - negative if `a < b`
 * - zero if `a == b`
 * - positive if `a > b`
 */
export declare type Comparator<T> = Fn2<T, T, number>;

/**
 * Property decorator factory. Sets `configurable` flag of PropertyDescriptor
 * to given state.
 *
 * @param state
 */
export declare const configurable: (state: boolean) => MethodDecorator;

export declare class ConsoleLogger implements ILogger {
    id: string;
    level: LogLevel;
    constructor(id: string, level?: LogLevel);
    fine(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    severe(...args: any[]): void;
    protected log(level: string, args: any[]): void;
}

export declare const DEFAULT_EPS = 0.000001;

/**
 * Method property decorator factory. Augments original method with
 * deprecation message (via console), shown when method is invoked.
 * Accepts optional message arg. Throws error if assigned property
 * is not a function.
 *
 * @param msg deprecation message
 */
export declare const deprecated: (msg?: string | undefined, log?: {
    (message?: any, ...optionalParams: any[]): void;
    (message?: any, ...optionalParams: any[]): void;
}) => MethodDecorator;

export declare interface Event extends IID<PropertyKey> {
    target?: any;
    canceled?: boolean;
    value?: any;
}

export declare const EVENT_ALL = "*";

export declare const EVENT_DISABLE = "disable";

export declare const EVENT_ENABLE = "enable";

export declare type FloatArray = Float32Array | Float64Array;

export declare type FloatType = Type.F32 | Type.F64;

/**
 * A single arg function from A => B.
 */
export declare type Fn<A, B> = (a: A) => B;

/**
 * A no-arg function, returning T.
 */
export declare type Fn0<T> = () => T;

/**
 * A 10-arg function from A,B,C,D,E,F,G,H,I,J => K.
 */
export declare type Fn10<A, B, C, D, E, F, G, H, I, J, K> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J) => K;

/**
 * A 2-arg function from A,B => C.
 */
export declare type Fn2<A, B, C> = (a: A, b: B) => C;

/**
 * A 3-arg function from A,B,C => D.
 */
export declare type Fn3<A, B, C, D> = (a: A, b: B, c: C) => D;

/**
 * A 4-arg function from A,B,C,D => E.
 */
export declare type Fn4<A, B, C, D, E> = (a: A, b: B, c: C, d: D) => E;

/**
 * A 5-arg function from A,B,C,D,E => F.
 */
export declare type Fn5<A, B, C, D, E, F> = (a: A, b: B, c: C, d: D, e: E) => F;

/**
 * A 6-arg function from A,B,C,D,E,F => G.
 */
export declare type Fn6<A, B, C, D, E, F, G> = (a: A, b: B, c: C, d: D, e: E, f: F) => G;

/**
 * A 7-arg function from A,B,C,D,E,F,G => H.
 */
export declare type Fn7<A, B, C, D, E, F, G, H> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G) => H;

/**
 * A 8-arg function from A,B,C,D,E,F,G,H => I.
 */
export declare type Fn8<A, B, C, D, E, F, G, H, I> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H) => I;

/**
 * A 9-arg function from A,B,C,D,E,F,G,H,I => J.
 */
export declare type Fn9<A, B, C, D, E, F, G, H, I, J> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I) => J;

/**
 * An untyped vararg arg function to type T.
 */
export declare type FnAny<T> = (...xs: any[]) => T;

/**
 * A typed vararg arg function from A => B.
 */
export declare type FnAnyT<A, B> = (...xs: A[]) => B;

export declare type FnO<A, B> = (a: A, ...xs: any[]) => B;

export declare type FnO10<A, B, C, D, E, F, G, H, I, J, K> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, j: J, ...xs: any[]) => K;

export declare type FnO2<A, B, C> = (a: A, b: B, ...xs: any[]) => C;

export declare type FnO3<A, B, C, D> = (a: A, b: B, c: C, ...xs: any[]) => D;

export declare type FnO4<A, B, C, D, E> = (a: A, b: B, c: C, d: D, ...xs: any[]) => E;

export declare type FnO5<A, B, C, D, E, F> = (a: A, b: B, c: C, d: D, e: E, ...xs: any[]) => F;

export declare type FnO6<A, B, C, D, E, F, G> = (a: A, b: B, c: C, d: D, e: E, f: F, ...xs: any[]) => G;

export declare type FnO7<A, B, C, D, E, F, G, H> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G, ...xs: any[]) => H;

export declare type FnO8<A, B, C, D, E, F, G, H, I> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, ...xs: any[]) => I;

export declare type FnO9<A, B, C, D, E, F, G, H, I, J> = (a: A, b: B, c: C, d: D, e: E, f: F, g: G, h: H, i: I, ...xs: any[]) => J;

/**
 * Conversion from `GLType` to `Type` enums.
 */
export declare const GL2TYPE: Record<GLType, Type>;

/**
 * WebGL numeric type constants. Use `GL2TYPE` to convert, if needed.
 *
 * @see Type
 * @see GL2TYPE
 * @see TYPE2GL
 */
export declare const enum GLType {
    I8 = 5120,
    U8 = 5121,
    I16 = 5122,
    U16 = 5123,
    I32 = 5124,
    U32 = 5125,
    F32 = 5126
}

/**
 * @param K key type
 * @param V value type
 * @param T return type
 */
export declare interface IAssoc<K, V, T> {
    assoc(key: K, val: V): T;
    update(key: K, f: Fn<V, V>): T;
}

/**
 * @param K key type
 * @param V value type
 * @param T return type
 */
export declare interface IAssocIn<K, V, T> {
    assocIn(key: K[], val: V): T;
    updateIn(key: K[], f: Fn<V, V>): T;
}

/**
 * Generic resource binding methods.
 */
export declare interface IBind<T> {
    /**
     * @returns true, if successful
     */
    bind(opt: T): boolean;
    /**
     * @returns true, if successful
     */
    unbind(opt: T): boolean;
}

/**
 * Generic interface for types with binary backing buffers.
 */
export declare interface IBuffered<T> {
    /**
     * An implementation's publicly accessible backing array /
     * ArrayBuffer (usually a typed array instance).
     */
    buffer: T;
    /**
     * Returns an Uint8Array view of backing array.
     */
    bytes?(): Uint8Array;
}

/**
 * Generic interface to compare value types.
 */
export declare interface ICompare<T> {
    /**
     * Compares this value with given value `x`. MUST follow same
     * contract as `Comparator`. MUST return 0 if the type also
     * implements `IEquiv` and `equiv` returns true for same `x`.
     *
     * Also see `IHash`.
     *
     * @param x
     */
    compare(x: T): number;
}

/**
 * Generic interface for collection types to check if a given value is
 * part of the collection.
 */
export declare interface IContains<T> {
    /**
     * Returns `true` if `x` is part of collection.
     *
     * @param x
     */
    contains(x: T): boolean;
}

/**
 * Generic interface for clonable types.
 */
export declare interface ICopy<T> {
    /**
     * Returns a copy of this instance. Shallow or deep copies are
     * implementation specific.
     */
    copy(): T;
}

/**
 * Generic interface for reference types (value wrappers).
 */
export declare interface IDeref<T> {
    /**
     * Returns wrapped value.
     */
    deref(): T;
}

/**
 * Extension of `IAssoc` for types supporting key removals.
 *
 * @param K key type
 * @param V value type
 * @param T return type
 */
export declare interface IDissoc<K, V, T> extends IAssoc<K, V, T> {
    dissoc(key: K): T;
}

/**
 * Extension of `IAssocIn` for types supporting key removals.
 *
 * @param K key type
 * @param V value type
 * @param T return type
 */
export declare interface IDissocIn<K, V, T> extends IAssocIn<K, V, T> {
    dissocIn(key: K[]): T;
}

export declare interface IEmpty<T> {
    /**
     * Returns an empty/blank instance of same type (with possibly same
     * config, if any).
     */
    empty(): T;
}

/**
 * Interface to provide enabled/disabled functionality. Also see
 * `@IEnable` decorator mixin
 *
 * @param T type for enable/disable option arg
 */
export declare interface IEnable<T> {
    isEnabled(): boolean;
    /**
     * Disables this entity.
     * @param opts optional implementation specific arg
     */
    disable(opts?: T): any;
    /**
     * Enables this entity.
     * @param opts optional implementation specific arg
     */
    enable(opts?: T): any;
    toggle?(): boolean;
}

/**
 * Mixin class decorator, injects IEnable default implementation, incl.
 * a `_enabled` property. If the target also implements the `INotify`
 * interface, `enable()` and `disable()` will automatically emit the
 * respective events.
 */
export declare const IEnableMixin: (clazz: any) => any;

/**
 * @param T value type
 */
export declare interface IEqualsDelta<T> {
    /**
     * Returns `true` if this value equals `o` with optional allowance
     * for given tolerance `eps`.
     *
     * @param o 2nd value to test
     * @param eps tolerance (usually defaults to `DEFAULT_EPS`)
     */
    eqDelta(o: T, eps?: number): boolean;
}

export declare interface IEquiv {
    /**
     * Returns `true` if this *value* is equivalent to `o`. Also see
     * `ICompare.compare` and `IHash.hash`.
     *
     * @param  o
     */
    equiv(o: any): boolean;
}

/**
 * @param K key type
 * @param V value type
 */
export declare interface IGet<K, V> {
    get(key: K, notfound?: V): V | undefined;
}

/**
 * @param K key type
 * @param V value type
 */
export declare interface IGetIn<K, V> {
    getIn(key: K[], notfound?: V): V | undefined;
}

/**
 * Interface for hashable types.
 */
export declare interface IHash<T> {
    /**
     * Returns a value's hash code. The contract of this function is: If
     * `IEquiv.equiv` returns `true` for two values, their hash codes
     * MUST also be equal.
     */
    hash(): T;
}

/**
 * `id` property declaration.
 */
export declare interface IID<T> {
    readonly id: T;
}

/**
 * Interface for collection types which can be accessed via numeric
 * index.
 */
export declare interface IIndexed<T> {
    nth(i: number, notfound: T): T;
}

/**
 * Interface for collection types supporting addition of multiple
 * values.
 */
export declare interface IInto<V, T> {
    into(coll: Iterable<V>): T;
}

/**
 * `length` property declaration for collections to obtain their element
 * count.
 */
export declare interface ILength {
    readonly length: number;
}

export declare interface ILogger {
    /**
     * This logger's configured minimum log level
     */
    level: LogLevel;
    fine(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    severe(...args: any[]): void;
}

/**
 * Generic interface for types supporting metadata. Implementations MUST
 * exclude metadata from any comparisons, equality checks & hashing.
 */
export declare interface IMeta<T> {
    meta(): any;
    /**
     * Returns a copy of the original value with given metadata
     * attached.
     *
     * @param  meta
     */
    withMeta(meta: any): T;
}

/**
 * Interface to provide event emitter functionality. Also see `@INotify`
 * decorator mixin
 */
export declare interface INotify {
    addListener(id: string, fn: Listener, scope?: any): boolean;
    removeListener(id: string, fn: Listener, scope?: any): boolean;
    notify(event: Event): void;
}

export declare const inotify_dispatch: (listeners: any[][], e: Event) => void;

/**
 * Mixin class decorator, injects INotify default implementation, incl.
 * a lazily instantiated `_listeners` property object, storing
 * registered listeners.
 */
export declare const INotifyMixin: (clazz: any) => any;

export declare type IntArray = Int8Array | Int16Array | Int32Array;

export declare type IntType = Type.I8 | Type.I16 | Type.I32;

/**
 * Returns the smallest possible *signed* int type enum for given `x`.
 * E.g. if `x >= -128 && x < 128`, the function returns `Type.I8`.
 *
 * @param x
 */
export declare const intType: (x: number) => IntType;

/**
 * Generic plain object with all key values of given type.
 */
export declare interface IObjectOf<T> {
    [id: string]: T;
}

/**
 * Interface for types supported the release of internal resources.
 */
export declare interface IRelease {
    release(opt?: any): boolean;
}

/**
 * Generic interface for set collection types.
 *
 * @param V value type
 * @param T return type
 */
export declare interface ISet<V, T> extends IInto<V, T> {
    /**
     * Conjoins/adds value `x` to set.
     *
     * @param x
     */
    conj(x: V): T;
    /**
     * Disjoins/removes value `x` from set.
     *
     * @param x
     */
    disj(x: V): T;
}

/**
 * Generic interface for collections implementing
 * stack functionality.
 *
 * @param V value type
 * @param P return type for pop()
 * @param S return type for push()
 */
export declare interface IStack<V, P, S> {
    /**
     * Returns top-of-stack item.
     */
    peek(): V | undefined;
    /**
     * Removes top-of-stack item and returns type P.
     */
    pop(): P | undefined;
    push(x: V): S;
}

export declare const iterable: (prop: string | number | symbol) => (clazz: any) => any;

export declare type IterableTuple<T, N extends number> = Tuple<T, N> & Iterable<T>;

export declare interface IToHiccup {
    /**
     * Returns a thi.ng/hiccup compatible representation. The optional
     * `ctx` arg is an arbitrary user context object passed to all
     * hiccup components during serialization (or during DOM creation /
     * update if used with thi.ng/hdom)
     *
     * @param ctx user context object
     */
    toHiccup(ctx?: any): any;
}

/**
 * Interface for types offering observers of internal value changes.
 * Also see `@IWatch` decorator mixin.
 */
export declare interface IWatch<T> {
    addWatch(id: string, fn: Watch<T>): boolean;
    removeWatch(id: string): boolean;
    notifyWatches(oldState: T, newState: T): void;
}

export declare const IWatchMixin: (clazz: any) => any;

export declare type Keys<T> = keyof T;

export declare type Keys1<T, A extends Keys<T>> = Keys<T[A]>;

export declare type Keys2<T, A extends Keys<T>, B extends Keys1<T, A>> = Keys1<T[A], B>;

export declare type Keys3<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>> = Keys2<T[A], B, C>;

export declare type Keys4<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>> = Keys3<T[A], B, C, D>;

export declare type Keys5<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>, E extends Keys4<T, A, B, C, D>> = Keys4<T[A], B, C, D, E>;

/**
 * Event listener.
 */
export declare type Listener = Fn<Event, void>;

export declare enum LogLevel {
    FINE = 0,
    DEBUG = 1,
    INFO = 2,
    WARN = 3,
    SEVERE = 4,
    NONE = 5
}

/**
 * Class behavior mixin based on:
 * http://raganwald.com/2015/06/26/decorators-in-es7.html
 *
 * Additionally only injects/overwrites properties in target, which are
 * NOT marked with `@nomixin` (i.e. haven't set their `configurable`
 * property descriptor flag to `false`)
 *
 * @param behaviour to mixin
 * @param sharedBehaviour
 * @returns decorator function
 */
export declare const mixin: (behaviour: any, sharedBehaviour?: any) => (clazz: any) => any;

/**
 * No-effect placeholder function.
 */
export declare const NO_OP: () => void;

/**
 * Method property decorator. Sets `configurable` flag of
 * PropertyDescriptor to `false` (same as `@configurable(false)`).
 * Intended to be used in combination with mixin decorators to enable
 * partial implementations of mixed-in behaviors in target class and
 * avoid them being overidden by mixed-in behaviour.
 */
export declare const nomixin: (_: any, __: string, descriptor: PropertyDescriptor) => void;

export declare const NULL_LOGGER: ILogger;

export declare type Nullable<T> = T | null | undefined;

export declare type NumericArray = number[] | TypedArray;

/**
 * A key-value pair / tuple.
 */
export declare type Pair<K, V> = [K, V];

/**
 * Lookup path for nested data structures.
 */
export declare type Path = PropertyKey | PropertyKey[];

/**
 * Predicate function mapping given value to true/false.
 */
export declare type Predicate<T> = Fn<T, boolean>;

/**
 * Predicate function mapping given args to true/false.
 */
export declare type Predicate2<T> = Fn2<T, T, boolean>;

export declare type Primitive = number | string | boolean | symbol;

export declare type Range0_1 = 0 | 1;

export declare type Range0_15 = Range0_7 | Range8_15;

export declare type Range0_3 = Range0_1 | 2 | 3;

export declare type Range0_31 = Range0_15 | Range16_31;

export declare type Range0_63 = Range0_31 | Range32_63;

export declare type Range0_7 = Range0_3 | Range4_7;

export declare type Range16_31 = 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31;

export declare type Range1_16 = Range1_8 | Range8_15 | 16;

export declare type Range1_2 = 1 | 2;

export declare type Range1_32 = Range1_16 | Range16_31 | 32;

export declare type Range1_4 = Range1_2 | 3 | 4;

export declare type Range1_64 = Range1_32 | Range32_63 | 64;

export declare type Range1_8 = Range1_4 | Range4_7 | 8;

export declare type Range32_63 = 32 | 33 | 34 | 35 | 36 | 37 | 38 | 39 | 40 | 41 | 42 | 43 | 44 | 45 | 46 | 47 | 48 | 49 | 50 | 51 | 52 | 53 | 54 | 55 | 56 | 57 | 58 | 59 | 60 | 61 | 62 | 63;

export declare type Range4_7 = 4 | 5 | 6 | 7;

export declare type Range8_15 = 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15;

/**
 * Class decorator. Seals both constructor and prototype.
 *
 * @param constructor
 */
export declare const sealed: (constructor: Function) => void;

export declare type Select2<T, Q, A, B> = T extends Q ? A : B;

export declare type Select3<T, Q1, Q2, A, B, C> = T extends Q1 ? A : T extends Q2 ? B : C;

export declare type Select4<T, Q1, Q2, Q3, A, B, C, D> = T extends Q1 ? A : T extends Q2 ? B : T extends Q3 ? C : D;

/**
 * Internal use only. **Do NOT use in user land code!**
 */
export declare const SEMAPHORE: unique symbol;

/**
 * Size information (in bytes) for `Type` enums. For `GLType`, use this
 * form, e.g. `SIZEOF[GL2TYPE[GLType.F32]]`
 */
export declare const SIZEOF: {
    [Type.U8]: number;
    [Type.U8C]: number;
    [Type.I8]: number;
    [Type.U16]: number;
    [Type.I16]: number;
    [Type.U32]: number;
    [Type.I32]: number;
    [Type.F32]: number;
    [Type.F64]: number;
};

/**
 * Higher order `Predicate` builder. Possibly stateful.
 */
export declare type StatefulPredicate<T> = Fn0<Predicate<T>>;

/**
 * Higher order `Predicate2` builder. Possibly stateful.
 */
export declare type StatefulPredicate2<T> = Fn0<Predicate2<T>>;

export declare type Tuple<T, N extends number> = [T, ...T[]] & {
    length: N;
};

/**
 * Type enums for Typedarray-backed buffers.
 *
 * @see GLType
 * @see GL2TYPE
 * @see TYPE2GL
 */
export declare const enum Type {
    U8 = 0,
    U8C = 1,
    I8 = 2,
    U16 = 3,
    I16 = 4,
    U32 = 5,
    I32 = 6,
    F32 = 7,
    F64 = 8
}

/**
 * Potentially lossy conversion from `Type` to `GLType` enums.
 *
 * Not all enums are mappable:
 *
 * - `F64` maps to `undefined`, since unsupported by WebGL
 * - `U8C` maps to U8
 */
export declare const TYPE2GL: Record<Type, GLType | undefined>;

export declare type TypedArray = Float32Array | Float64Array | Int8Array | Int16Array | Int32Array | Uint8Array | Uint8ClampedArray | Uint16Array | Uint32Array;

/**
 * Constructs new typed array of given `Type`/`GLType`. Supports all
 * arities of standard typed array ctors.
 *
 * @param type
 */
export declare function typedArray<T extends Type | GLType>(type: T, length: number): TypedArrayTypeMap[T];

export declare function typedArray<T extends Type | GLType>(type: T, src: ArrayLike<number> | ArrayBufferLike): TypedArrayTypeMap[T];

export declare function typedArray<T extends Type | GLType>(type: T, buf: ArrayBufferLike, byteOffset: number, length?: number): TypedArrayTypeMap[T];

export declare const TYPEDARRAY_CTORS: Record<Type | GLType, TypedArrayConstructor>;

export declare type TypedArrayConstructor = Uint8ArrayConstructor | Uint8ClampedArrayConstructor | Int8ArrayConstructor | Uint16ArrayConstructor | Int16ArrayConstructor | Uint32ArrayConstructor | Int32ArrayConstructor | Float32ArrayConstructor | Float64ArrayConstructor;

export declare interface TypedArrayTypeMap extends Record<Type | GLType, TypedArray> {
    [Type.U8]: Uint8Array;
    [Type.U8C]: Uint8ClampedArray;
    [Type.I8]: Int8Array;
    [Type.U16]: Uint16Array;
    [Type.I16]: Int16Array;
    [Type.U32]: Uint32Array;
    [Type.I32]: Int32Array;
    [Type.F32]: Float32Array;
    [Type.F64]: Float64Array;
    [GLType.U8]: Uint8Array;
    [GLType.I8]: Int8Array;
    [GLType.U16]: Uint16Array;
    [GLType.I16]: Int16Array;
    [GLType.U32]: Uint32Array;
    [GLType.I32]: Int32Array;
    [GLType.F32]: Float32Array;
}

export declare type UIntArray = Uint8Array | Uint16Array | Uint32Array;

export declare type UintType = Type.U8 | Type.U16 | Type.U32;

/**
 * Returns the smallest possible *unsigned* int type enum for given `x`.
 * E.g. if `x <= 256`, the function returns `Type.U8`.
 *
 * @param x
 */
export declare const uintType: (x: number) => UintType;

export declare type Val1<T, A extends Keys<T>> = T[A];

export declare type Val2<T, A extends Keys<T>, B extends Keys1<T, A>> = Val1<T, A>[B];

export declare type Val3<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>> = Val2<T, A, B>[C];

export declare type Val4<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>> = Val3<T, A, B, C>[D];

export declare type Val5<T, A extends Keys<T>, B extends Keys1<T, A>, C extends Keys2<T, A, B>, D extends Keys3<T, A, B, C>, E extends Keys4<T, A, B, C, D>> = Val4<T, A, B, C, D>[E];

/**
 * Observer function for `IWatch` implementations.
 */
export declare type Watch<T> = (id: string, oldState: T, newState: T) => void;

export { }
