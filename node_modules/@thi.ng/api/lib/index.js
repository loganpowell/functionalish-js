'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

(function (LogLevel) {
    LogLevel[LogLevel["FINE"] = 0] = "FINE";
    LogLevel[LogLevel["DEBUG"] = 1] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 2] = "INFO";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["SEVERE"] = 4] = "SEVERE";
    LogLevel[LogLevel["NONE"] = 5] = "NONE";
})(exports.LogLevel || (exports.LogLevel = {}));

(function (Type) {
    Type[Type["U8"] = 0] = "U8";
    Type[Type["U8C"] = 1] = "U8C";
    Type[Type["I8"] = 2] = "I8";
    Type[Type["U16"] = 3] = "U16";
    Type[Type["I16"] = 4] = "I16";
    Type[Type["U32"] = 5] = "U32";
    Type[Type["I32"] = 6] = "I32";
    Type[Type["F32"] = 7] = "F32";
    Type[Type["F64"] = 8] = "F64";
})(exports.Type || (exports.Type = {}));
(function (GLType) {
    GLType[GLType["I8"] = 5120] = "I8";
    GLType[GLType["U8"] = 5121] = "U8";
    GLType[GLType["I16"] = 5122] = "I16";
    GLType[GLType["U16"] = 5123] = "U16";
    GLType[GLType["I32"] = 5124] = "I32";
    GLType[GLType["U32"] = 5125] = "U32";
    GLType[GLType["F32"] = 5126] = "F32";
})(exports.GLType || (exports.GLType = {}));
const GL2TYPE = {
    [5120 ]: 2 ,
    [5121 ]: 0 ,
    [5122 ]: 4 ,
    [5123 ]: 3 ,
    [5124 ]: 6 ,
    [5125 ]: 5 ,
    [5126 ]: 7
};
const TYPE2GL = {
    [2 ]: 5120 ,
    [0 ]: 5121 ,
    [1 ]: 5121 ,
    [4 ]: 5122 ,
    [3 ]: 5123 ,
    [6 ]: 5124 ,
    [6 ]: 5124 ,
    [5 ]: 5125 ,
    [7 ]: 5126 ,
    [8 ]: undefined
};
const SIZEOF = {
    [0 ]: 1,
    [1 ]: 1,
    [2 ]: 1,
    [3 ]: 2,
    [4 ]: 2,
    [5 ]: 4,
    [6 ]: 4,
    [7 ]: 4,
    [8 ]: 8
};
const TYPEDARRAY_CTORS = {
    [0 ]: Uint8Array,
    [1 ]: Uint8ClampedArray,
    [2 ]: Int8Array,
    [3 ]: Uint16Array,
    [4 ]: Int16Array,
    [5 ]: Uint32Array,
    [6 ]: Int32Array,
    [7 ]: Float32Array,
    [8 ]: Float64Array,
    [5121 ]: Uint8Array,
    [5120 ]: Int8Array,
    [5123 ]: Uint16Array,
    [5122 ]: Int16Array,
    [5125 ]: Uint32Array,
    [5124 ]: Int32Array,
    [5126 ]: Float32Array
};
function typedArray(type, ...xs) {
    return new TYPEDARRAY_CTORS[type](...xs);
}
const uintType = (x) => x <= 0x100 ? 0  : x <= 0x10000 ? 3  : 5 ;
const intType = (x) => x >= -0x80 && x < 0x80
    ? 2
    : x >= -0x8000 && x < 0x8000
        ? 4
        : 6 ;

const DEFAULT_EPS = 1e-6;
const SEMAPHORE = Symbol();
const NO_OP = () => { };
const EVENT_ALL = "*";
const EVENT_ENABLE = "enable";
const EVENT_DISABLE = "disable";

const assert = typeof process === "undefined" ||
    process.env.NODE_ENV !== "production" ||
    process.env.UMBRELLA_ASSERTS === "1"
    ? (test, msg = "assertion failed") => {
        if ((typeof test === "function" && !test()) || !test) {
            throw new Error(typeof msg === "function" ? msg() : msg);
        }
    }
    : NO_OP;

const exposeGlobal = (id, value, always = false) => {
    const glob = typeof global !== "undefined"
        ? global
        : typeof window !== "undefined"
            ? window
            : undefined;
    if (glob &&
        (always ||
            typeof process === "undefined" ||
            process.env.NODE_ENV !== "production" ||
            process.env.UMBRELLA_ASSERTS === "1")) {
        glob[id] = value;
    }
};

const NULL_LOGGER = Object.freeze({
    level: exports.LogLevel.NONE,
    fine() { },
    debug() { },
    info() { },
    warn() { },
    severe() { }
});
class ConsoleLogger {
    constructor(id, level = exports.LogLevel.FINE) {
        this.id = id;
        this.level = level;
    }
    fine(...args) {
        this.level <= exports.LogLevel.FINE && this.log("FINE", args);
    }
    debug(...args) {
        this.level <= exports.LogLevel.DEBUG && this.log("DEBUG", args);
    }
    info(...args) {
        this.level <= exports.LogLevel.INFO && this.log("INFO", args);
    }
    warn(...args) {
        this.level <= exports.LogLevel.WARN && this.log("WARN", args);
    }
    severe(...args) {
        this.level <= exports.LogLevel.SEVERE && this.log("SEVERE", args);
    }
    log(level, args) {
        console.log(`[${level}] ${this.id}:`, ...args);
    }
}

const mixin = (behaviour, sharedBehaviour = {}) => {
    const instanceKeys = Reflect.ownKeys(behaviour);
    const sharedKeys = Reflect.ownKeys(sharedBehaviour);
    const typeTag = Symbol("isa");
    function _mixin(clazz) {
        for (let key of instanceKeys) {
            const existing = Object.getOwnPropertyDescriptor(clazz.prototype, key);
            if (!existing || existing.configurable) {
                Object.defineProperty(clazz.prototype, key, {
                    value: behaviour[key],
                    writable: true
                });
            }
            else {
                console.log(`not patching: ${clazz.name}.${key.toString()}`);
            }
        }
        Object.defineProperty(clazz.prototype, typeTag, { value: true });
        return clazz;
    }
    for (let key of sharedKeys) {
        Object.defineProperty(_mixin, key, {
            value: sharedBehaviour[key],
            enumerable: sharedBehaviour.propertyIsEnumerable(key)
        });
    }
    Object.defineProperty(_mixin, Symbol.hasInstance, {
        value: (x) => !!x[typeTag]
    });
    return _mixin;
};

const configurable = (state) => function (_, __, descriptor) {
    descriptor.configurable = state;
};

const deprecated = (msg, log = console.log) => function (target, prop, descriptor) {
    const signature = `${target.constructor.name}#${prop.toString()}`;
    const fn = descriptor.value;
    assert(typeof fn === "function", `${signature} is not a function`);
    descriptor.value = function () {
        log(`DEPRECATED ${signature}: ${msg || "will be removed soon"}`);
        return fn.apply(this, arguments);
    };
    return descriptor;
};

const nomixin = (_, __, descriptor) => {
    descriptor.configurable = false;
};

const sealed = (constructor) => {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
};

const IEnableMixin = mixin({
    _enabled: true,
    isEnabled() {
        return this._enabled;
    },
    enable() {
        this._enabled = true;
        if (this.notify) {
            this.notify({ id: EVENT_ENABLE, target: this });
        }
    },
    disable() {
        this._enabled = false;
        if (this.notify) {
            this.notify({ id: EVENT_DISABLE, target: this });
        }
    },
    toggle() {
        this._enabled ? this.disable() : this.enable();
        return this._enabled;
    }
});

const inotify_dispatch = (listeners, e) => {
    if (!listeners)
        return;
    for (let i = 0, n = listeners.length, l; i < n; i++) {
        l = listeners[i];
        l[0].call(l[1], e);
        if (e.canceled) {
            return;
        }
    }
};
const INotifyMixin = mixin({
    addListener(id, fn, scope) {
        let l = (this._listeners = this._listeners || {})[id];
        !l && (l = this._listeners[id] = []);
        if (this.__listener(l, fn, scope) === -1) {
            l.push([fn, scope]);
            return true;
        }
        return false;
    },
    removeListener(id, fn, scope) {
        let listeners;
        if (!(listeners = this._listeners))
            return false;
        const l = listeners[id];
        if (l) {
            const idx = this.__listener(l, fn, scope);
            if (idx !== -1) {
                l.splice(idx, 1);
                !l.length && delete listeners[id];
                return true;
            }
        }
        return false;
    },
    notify(e) {
        let listeners;
        if (!(listeners = this._listeners))
            return false;
        e.target === undefined && (e.target = this);
        inotify_dispatch(listeners[e.id], e);
        inotify_dispatch(listeners[EVENT_ALL], e);
    },
    __listener(listeners, f, scope) {
        let i = listeners.length;
        while (--i >= 0) {
            const l = listeners[i];
            if (l[0] === f && l[1] === scope) {
                break;
            }
        }
        return i;
    }
});

const iterable = (prop) => mixin({
    *[Symbol.iterator]() {
        yield* this[prop];
    }
});

const IWatchMixin = mixin({
    addWatch(id, fn) {
        this._watches = this._watches || {};
        if (this._watches[id]) {
            return false;
        }
        this._watches[id] = fn;
        return true;
    },
    removeWatch(id) {
        if (!this._watches)
            return;
        if (this._watches[id]) {
            delete this._watches[id];
            return true;
        }
        return false;
    },
    notifyWatches(oldState, newState) {
        if (!this._watches)
            return;
        const w = this._watches;
        for (let id in w) {
            w[id](id, oldState, newState);
        }
    }
});

exports.ConsoleLogger = ConsoleLogger;
exports.DEFAULT_EPS = DEFAULT_EPS;
exports.EVENT_ALL = EVENT_ALL;
exports.EVENT_DISABLE = EVENT_DISABLE;
exports.EVENT_ENABLE = EVENT_ENABLE;
exports.GL2TYPE = GL2TYPE;
exports.IEnableMixin = IEnableMixin;
exports.INotifyMixin = INotifyMixin;
exports.IWatchMixin = IWatchMixin;
exports.NO_OP = NO_OP;
exports.NULL_LOGGER = NULL_LOGGER;
exports.SEMAPHORE = SEMAPHORE;
exports.SIZEOF = SIZEOF;
exports.TYPE2GL = TYPE2GL;
exports.TYPEDARRAY_CTORS = TYPEDARRAY_CTORS;
exports.assert = assert;
exports.configurable = configurable;
exports.deprecated = deprecated;
exports.exposeGlobal = exposeGlobal;
exports.inotify_dispatch = inotify_dispatch;
exports.intType = intType;
exports.iterable = iterable;
exports.mixin = mixin;
exports.nomixin = nomixin;
exports.sealed = sealed;
exports.typedArray = typedArray;
exports.uintType = uintType;
