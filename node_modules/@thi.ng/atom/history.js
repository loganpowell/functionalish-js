var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var History_1;
import { INotifyMixin } from "@thi.ng/api";
import { equiv } from "@thi.ng/equiv";
import { getIn, setIn, updateIn } from "@thi.ng/paths";
import { View } from "./view";
/**
 * Undo/redo history stack wrapper for atoms and cursors. Implements
 * {@link IAtom} interface and so can be used directly in place and
 * delegates to wrapped atom/cursor.
 *
 * @remarks
 * Value changes are only recorded in history if `changed` predicate
 * returns truthy value, or else by calling {@link History.record}
 * directly. This class too implements the {@link @thi.ng/api#INotify}
 * interface to support event listeners for {@link History.undo},
 * {@link History.redo} and {@link History.record}.
 */
let History = History_1 = class History {
    /**
     * @param state - parent state
     * @param maxLen - max size of undo stack
     * @param changed - predicate to determine changed values (default `!equiv(a,b)`)
     */
    constructor(state, maxLen = 100, changed) {
        this.state = state;
        this.maxLen = maxLen;
        this.changed = changed || ((a, b) => !equiv(a, b));
        this.clear();
    }
    get value() {
        return this.deref();
    }
    set value(val) {
        this.reset(val);
    }
    canUndo() {
        return this.history.length > 0;
    }
    canRedo() {
        return this.future.length > 0;
    }
    /**
     * Clears history & future stacks
     */
    clear() {
        this.history = [];
        this.future = [];
    }
    /**
     * Attempts to re-apply most recent historical value to atom and
     * returns it if successful (i.e. there's a history).
     *
     * @remarks
     * Before the switch, first records the atom's current value into
     * the future stack (to enable {@link History.redo} feature).
     * Returns `undefined` if there's no history.
     *
     * If undo was possible, the `History.EVENT_UNDO` event is emitted
     * after the restoration with both the `prev` and `curr` (restored)
     * states provided as event value (and object with these two keys).
     * This allows for additional state handling to be executed, e.g.
     * application of the "Command pattern". See
     * {@link History.addListener} for registering event listeners.
     */
    undo() {
        if (this.history.length) {
            const prev = this.state.deref();
            this.future.push(prev);
            const curr = this.state.reset(this.history.pop());
            this.notify({ id: History_1.EVENT_UNDO, value: { prev, curr } });
            return curr;
        }
    }
    /**
     * Attempts to re-apply most recent value from future stack to atom
     * and returns it if successful (i.e. there's a future).
     *
     * @remarks
     * Before the switch, first records the atom's current value into
     * the history stack (to enable {@link History.undo} feature).
     * Returns `undefined` if there's no future (so sad!).
     *
     * If redo was possible, the `History.EVENT_REDO` event is emitted
     * after the restoration with both the `prev` and `curr` (restored)
     * states provided as event value (and object with these two keys).
     * This allows for additional state handling to be executed, e.g.
     * application of the "Command pattern". See
     * {@link History.addListener} for registering event listeners.
     */
    redo() {
        if (this.future.length) {
            const prev = this.state.deref();
            this.history.push(prev);
            const curr = this.state.reset(this.future.pop());
            this.notify({ id: History_1.EVENT_REDO, value: { prev, curr } });
            return curr;
        }
    }
    /**
     * `IReset.reset()` implementation. Delegates to wrapped
     * atom/cursor, but too applies `changed` predicate to determine if
     * there was a change and if the previous value should be recorded.
     *
     * @param val - replacement value
     */
    reset(val) {
        const prev = this.state.deref();
        this.state.reset(val);
        const changed = this.changed(prev, this.state.deref());
        if (changed) {
            this.record(prev);
        }
        return val;
    }
    resetIn(path, val) {
        const prev = this.state.deref();
        const prevV = getIn(prev, path);
        const curr = setIn(prev, path, val);
        this.state.reset(curr);
        this.changed(prevV, getIn(curr, path)) && this.record(prev);
        return curr;
    }
    /**
     * `ISwap.swap()` implementation. Delegates to wrapped atom/cursor,
     * but too applies `changed` predicate to determine if there was a
     * change and if the previous value should be recorded.
     *
     * @param fn - update function
     * @param args - additional args passed to `fn`
     */
    swap(fn, ...args) {
        return this.reset(fn(this.state.deref(), ...args));
    }
    swapIn(path, fn, ...args) {
        const prev = this.state.deref();
        const prevV = getIn(prev, path);
        const curr = updateIn(this.state.deref(), path, fn, ...args);
        this.state.reset(curr);
        this.changed(prevV, getIn(curr, path)) && this.record(prev);
        return curr;
    }
    /**
     * Records given state in history. This method is only needed when
     * manually managing snapshots, i.e. when applying multiple swaps on
     * the wrapped atom directly, but not wanting to create an history
     * entry for each change.
     *
     * @remarks
     * **DO NOT call this explicitly if using {@link History.reset} /
     * {@link History.swap} etc.**
     *
     * If no `state` is given, uses the wrapped atom's current state
     * value (user code SHOULD always call without arg).
     *
     * If recording succeeded, the `History.EVENT_RECORD` event is
     * emitted with the recorded state provided as event value.
     *
     * @param state - state to record
     */
    record(state) {
        const history = this.history;
        const n = history.length;
        let ok = true;
        // check for arg given and not if `state == null` we want to
        // allow null/undefined as possible values
        if (!arguments.length) {
            state = this.state.deref();
            ok = !n || this.changed(history[n - 1], state);
        }
        if (ok) {
            if (n >= this.maxLen) {
                history.shift();
            }
            history.push(state);
            this.notify({ id: History_1.EVENT_RECORD, value: state });
            this.future.length = 0;
        }
    }
    /**
     * Returns wrapped atom's **current** value.
     */
    deref() {
        return this.state.deref();
    }
    /**
     * `IWatch.addWatch()` implementation. Delegates to wrapped
     * atom/cursor.
     *
     * @param id - watch ID
     * @param fn - watch function
     */
    addWatch(id, fn) {
        return this.state.addWatch(id, fn);
    }
    /**
     * `IWatch.removeWatch()` implementation. Delegates to wrapped
     * atom/cursor.
     *
     * @param id - watch iD
     */
    removeWatch(id) {
        return this.state.removeWatch(id);
    }
    /**
     * `IWatch.notifyWatches()` implementation. Delegates to wrapped
     * atom/cursor.
     *
     * @param oldState -
     * @param newState -
     */
    notifyWatches(oldState, newState) {
        return this.state.notifyWatches(oldState, newState);
    }
    addView(path, tx, lazy = true) {
        return new View(this, path, tx, lazy);
    }
    release() {
        this.state.release();
        delete this.state;
        return true;
    }
    /** {@inheritDoc @thi.ng/api#INotify.addListener} */
    // @ts-ignore: mixin
    addListener(id, fn, scope) { }
    /** {@inheritDoc @thi.ng/api#INotify.removeListener} */
    // @ts-ignore: mixin
    removeListener(id, fn, scope) { }
    /** {@inheritDoc @thi.ng/api#INotify.notify} */
    // @ts-ignore: mixin
    notify(e) { }
};
History.EVENT_UNDO = "undo";
History.EVENT_REDO = "redo";
History.EVENT_RECORD = "record";
History = History_1 = __decorate([
    INotifyMixin
], History);
export { History };
