'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var checks = require('@thi.ng/checks');
var errors = require('@thi.ng/errors');

const toPath = (path) => checks.isArray(path)
    ? path
    : checks.isString(path)
        ? path.length > 0
            ? path.split(".")
            : []
        : path != null
            ? [path]
            : [];
const exists = (obj, path) => {
    if (obj == null) {
        return false;
    }
    path = toPath(path);
    for (let n = path.length - 1, i = 0; i <= n; i++) {
        const k = path[i];
        if (!obj.hasOwnProperty(k)) {
            return false;
        }
        obj = obj[k];
        if (obj == null && i < n) {
            return false;
        }
    }
    return true;
};

const getter = (path) => getterT(path);
function getterT(path) {
    const ks = toPath(path);
    let [a, b, c, d] = ks;
    switch (ks.length) {
        case 0:
            return (s) => s;
        case 1:
            return (s) => (s != null ? s[a] : undefined);
        case 2:
            return (s) => s != null ? ((s = s[a]) != null ? s[b] : undefined) : undefined;
        case 3:
            return (s) => s != null
                ? (s = s[a]) != null
                    ? (s = s[b]) != null
                        ? s[c]
                        : undefined
                    : undefined
                : undefined;
        case 4:
            return (s) => s != null
                ? (s = s[a]) != null
                    ? (s = s[b]) != null
                        ? (s = s[c]) != null
                            ? s[d]
                            : undefined
                        : undefined
                    : undefined
                : undefined;
        default:
            return (s) => {
                const n = ks.length - 1;
                let res = s;
                for (let i = 0; res != null && i <= n; i++) {
                    res = res[ks[i]];
                }
                return res;
            };
    }
}

const setter = (path) => setterT(path);
function setterT(path) {
    const ks = toPath(path);
    let [a, b, c, d] = ks;
    switch (ks.length) {
        case 0:
            return (_, v) => v;
        case 1:
            return (s, v) => ((s = _copy(s)), (s[a] = v), s);
        case 2:
            return (s, v) => {
                let x;
                s = _copy(s);
                s[a] = x = _copy(s[a]);
                x[b] = v;
                return s;
            };
        case 3:
            return (s, v) => {
                let x, y;
                s = _copy(s);
                s[a] = x = _copy(s[a]);
                x[b] = y = _copy(x[b]);
                y[c] = v;
                return s;
            };
        case 4:
            return (s, v) => {
                let x, y, z;
                s = _copy(s);
                s[a] = x = _copy(s[a]);
                x[b] = y = _copy(x[b]);
                y[c] = z = _copy(y[c]);
                z[d] = v;
                return s;
            };
        default:
            let f;
            for (let i = ks.length; --i >= 0;) {
                f = compS(ks[i], f);
            }
            return f;
    }
}
const _copy = (s) => (checks.isArray(s) ? s.slice() : Object.assign({}, s));
const compS = (k, f) => (s, v) => ((s = _copy(s)), (s[k] = f ? f(s[k], v) : v), s);

const updateIn = (state, path, fn, ...args) => updateInT(state, path, fn, ...args);
function updateInT(state, path, fn, ...args) {
    return setterT(path)(state, fn.apply(null, (args.unshift(getterT(path)(state)), args)));
}

const deleteIn = (state, path) => deleteInT(state, path);
function deleteInT(state, path) {
    const ks = [...toPath(path)];
    if (ks.length > 0) {
        const k = ks.pop();
        return updateInT(state, ks, (x) => ((x = Object.assign({}, x)), delete x[k], x));
    }
}

const getIn = (state, path) => getterT(path)(state);
function getInT(state, path) {
    return getterT(path)(state);
}

const mutator = (path) => mutatorT(path);
function mutatorT(path) {
    const ks = toPath(path);
    let [a, b, c, d] = ks;
    switch (ks.length) {
        case 0:
            return (_, x) => x;
        case 1:
            return (s, x) => (s ? ((s[a] = x), s) : undefined);
        case 2:
            return (s, x) => {
                let t;
                return s
                    ? (t = s[a])
                        ? ((t[b] = x), s)
                        : undefined
                    : undefined;
            };
        case 3:
            return (s, x) => {
                let t;
                return s
                    ? (t = s[a])
                        ? (t = t[b])
                            ? ((t[c] = x), s)
                            : undefined
                        : undefined
                    : undefined;
            };
        case 4:
            return (s, x) => {
                let t;
                return s
                    ? (t = s[a])
                        ? (t = t[b])
                            ? (t = t[c])
                                ? ((t[d] = x), s)
                                : undefined
                            : undefined
                        : undefined
                    : undefined;
            };
        default:
            return (s, x) => {
                let t = s;
                const n = ks.length - 1;
                for (let k = 0; k < n; k++) {
                    if (!(t = t[ks[k]]))
                        return;
                }
                t[ks[n]] = x;
                return s;
            };
    }
}

const mutIn = (state, path, val) => mutInT(state, path, val);
function mutInT(state, path, val) {
    return mutatorT(path)(state, val);
}

const mutInMany = (state, ...pairs) => {
    const n = pairs.length;
    n & 1 && errors.illegalArgs(`require even number of args (got ${pairs.length})`);
    for (let i = 0; i < n && state; i += 2) {
        state = mutInT(state, pairs[i], pairs[i + 1]);
    }
    return state;
};

const setIn = (state, path, val) => setterT(path)(state, val);
function setInT(state, path, val) {
    return setterT(path)(state, val);
}

const setInMany = (state, ...pairs) => {
    const n = pairs.length;
    n & 1 &&
        errors.illegalArgs(`require even number of KV args (got ${pairs.length})`);
    for (let i = 0; i < n; i += 2) {
        state = setInT(state, pairs[i], pairs[i + 1]);
    }
    return state;
};

const updater = (path, fn) => updaterT(path, fn);
function updaterT(path, fn) {
    const g = getterT(path);
    const s = setterT(path);
    return (state, ...args) => s(state, fn.apply(null, (args.unshift(g(state)), args)));
}

exports.deleteIn = deleteIn;
exports.deleteInT = deleteInT;
exports.exists = exists;
exports.getIn = getIn;
exports.getInT = getInT;
exports.getter = getter;
exports.getterT = getterT;
exports.mutIn = mutIn;
exports.mutInMany = mutInMany;
exports.mutInT = mutInT;
exports.mutator = mutator;
exports.mutatorT = mutatorT;
exports.setIn = setIn;
exports.setInMany = setInMany;
exports.setInT = setInT;
exports.setter = setter;
exports.setterT = setterT;
exports.toPath = toPath;
exports.updateIn = updateIn;
exports.updateInT = updateInT;
exports.updater = updater;
exports.updaterT = updaterT;
