'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var api = require('@thi.ng/api');
var errors = require('@thi.ng/errors');
var paths = require('@thi.ng/paths');
var equiv = require('@thi.ng/equiv');
var checks = require('@thi.ng/checks');

let NEXT_ID = 0;
const nextID = () => NEXT_ID++;

class View {
    constructor(parent, path, tx, lazy = true, equiv$1 = equiv.equiv) {
        this.parent = parent;
        this.id = `view-${nextID()}`;
        this.tx = tx || ((x) => x);
        this.path = paths.toPath(path);
        this.isDirty = true;
        this.isLazy = lazy;
        const lookup = paths.getter(this.path);
        const state = this.parent.deref();
        this.unprocessed = state ? lookup(state) : undefined;
        if (!lazy) {
            this.state = this.tx(this.unprocessed);
            this.unprocessed = undefined;
        }
        parent.addWatch(this.id, (_, prev, curr) => {
            const pval = prev ? lookup(prev) : prev;
            const val = curr ? lookup(curr) : curr;
            if (!equiv$1(val, pval)) {
                if (lazy) {
                    this.unprocessed = val;
                }
                else {
                    this.state = this.tx(val);
                }
                this.isDirty = true;
            }
        });
    }
    get value() {
        return this.deref();
    }
    deref() {
        if (this.isDirty) {
            if (this.isLazy) {
                this.state = this.tx(this.unprocessed);
                this.unprocessed = undefined;
            }
            this.isDirty = false;
        }
        return this.state;
    }
    changed() {
        return this.isDirty;
    }
    view() {
        return this.isDirty && this.isLazy
            ? this.tx(this.unprocessed)
            : this.state;
    }
    release() {
        this.unprocessed = undefined;
        if (!this.isLazy) {
            this.state = this.tx(undefined);
        }
        this.isDirty = true;
        return this.parent.removeWatch(this.id);
    }
}

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
exports.Atom = class Atom {
    constructor(val, valid) {
        if (valid && !valid(val)) {
            errors.illegalState("initial state value did not validate");
        }
        this._value = val;
        this.valid = valid;
    }
    get value() {
        return this._value;
    }
    set value(val) {
        this.reset(val);
    }
    deref() {
        return this._value;
    }
    equiv(o) {
        return this === o;
    }
    reset(val) {
        const old = this._value;
        if (this.valid && !this.valid(val)) {
            return old;
        }
        this._value = val;
        this.notifyWatches(old, val);
        return val;
    }
    resetIn(path, val) {
        return this.reset(paths.setIn(this._value, path, val));
    }
    swap(fn, ...args) {
        return this.reset(fn.apply(null, [this._value, ...args]));
    }
    swapIn(path, fn, ...args) {
        return this.reset(paths.updateIn(this._value, path, fn, ...args));
    }
    addWatch(id, fn) { }
    removeWatch(id) { }
    notifyWatches(old, prev) { }
    addView(path, tx, lazy = true) {
        return new View(this, path, tx, lazy);
    }
    release() {
        delete this._watches;
        delete this._value;
        return true;
    }
};
exports.Atom = __decorate([
    api.IWatchMixin
], exports.Atom);

class Cursor {
    constructor(...args) {
        let parent;
        let lookup;
        let update;
        let validate;
        let opts;
        let id;
        switch (args.length) {
            case 1:
                opts = args[0];
                id = opts.id;
                parent = opts.parent;
                validate = opts.validate;
                if (opts.path) {
                    if (checks.isArray(opts.path) && checks.isFunction(opts.path[0])) {
                        [lookup, update] = opts.path;
                    }
                    else {
                        lookup = paths.getter(opts.path);
                        update = paths.setter(opts.path);
                    }
                }
                else {
                    errors.illegalArgs("missing path config");
                }
                break;
            case 2:
                parent = args[0];
                lookup = paths.getter(args[1]);
                update = paths.setter(args[1]);
                break;
            case 3:
                [parent, lookup, update] = args;
                break;
            default:
                errors.illegalArity(args.length);
        }
        this.parent = parent;
        this.id = id || `cursor-${nextID()}`;
        this.selfUpdate = false;
        if (!lookup || !update) {
            errors.illegalArgs();
        }
        this.local = new exports.Atom(lookup(parent.deref()), validate);
        this.local.addWatch(this.id, (_, prev, curr) => {
            if (prev !== curr) {
                this.selfUpdate = true;
                parent.swap((state) => update(state, curr));
                this.selfUpdate = false;
            }
        });
        parent.addWatch(this.id, (_, prev, curr) => {
            if (!this.selfUpdate) {
                const cval = lookup(curr);
                if (cval !== lookup(prev)) {
                    this.local.reset(cval);
                }
            }
        });
    }
    get value() {
        return this.deref();
    }
    set value(val) {
        this.reset(val);
    }
    deref() {
        return this.local.deref();
    }
    release() {
        this.local.release();
        this.parent.removeWatch(this.id);
        delete this.local;
        delete this.parent;
        return true;
    }
    reset(val) {
        return this.local.reset(val);
    }
    resetIn(path, val) {
        return this.local.resetIn(path, val);
    }
    swap(fn, ...args) {
        return this.local.swap(fn, ...args);
    }
    swapIn(path, fn, ...args) {
        return this.local.swapIn(path, fn, ...args);
    }
    addWatch(id, fn) {
        return this.local.addWatch(id, fn);
    }
    removeWatch(id) {
        return this.local.removeWatch(id);
    }
    notifyWatches(oldState, newState) {
        return this.local.notifyWatches(oldState, newState);
    }
    addView(path, tx, lazy = true) {
        return new View(this, path, tx, lazy);
    }
}

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var History_1;
exports.History = History_1 = class History {
    constructor(state, maxLen = 100, changed) {
        this.state = state;
        this.maxLen = maxLen;
        this.changed = changed || ((a, b) => !equiv.equiv(a, b));
        this.clear();
    }
    get value() {
        return this.deref();
    }
    set value(val) {
        this.reset(val);
    }
    canUndo() {
        return this.history.length > 0;
    }
    canRedo() {
        return this.future.length > 0;
    }
    clear() {
        this.history = [];
        this.future = [];
    }
    undo() {
        if (this.history.length) {
            const prev = this.state.deref();
            this.future.push(prev);
            const curr = this.state.reset(this.history.pop());
            this.notify({ id: History_1.EVENT_UNDO, value: { prev, curr } });
            return curr;
        }
    }
    redo() {
        if (this.future.length) {
            const prev = this.state.deref();
            this.history.push(prev);
            const curr = this.state.reset(this.future.pop());
            this.notify({ id: History_1.EVENT_REDO, value: { prev, curr } });
            return curr;
        }
    }
    reset(val) {
        const prev = this.state.deref();
        this.state.reset(val);
        const changed = this.changed(prev, this.state.deref());
        if (changed) {
            this.record(prev);
        }
        return val;
    }
    resetIn(path, val) {
        const prev = this.state.deref();
        const prevV = paths.getIn(prev, path);
        const curr = paths.setIn(prev, path, val);
        this.state.reset(curr);
        this.changed(prevV, paths.getIn(curr, path)) && this.record(prev);
        return curr;
    }
    swap(fn, ...args) {
        return this.reset(fn(this.state.deref(), ...args));
    }
    swapIn(path, fn, ...args) {
        const prev = this.state.deref();
        const prevV = paths.getIn(prev, path);
        const curr = paths.updateIn(this.state.deref(), path, fn, ...args);
        this.state.reset(curr);
        this.changed(prevV, paths.getIn(curr, path)) && this.record(prev);
        return curr;
    }
    record(state) {
        const history = this.history;
        const n = history.length;
        let ok = true;
        if (!arguments.length) {
            state = this.state.deref();
            ok = !n || this.changed(history[n - 1], state);
        }
        if (ok) {
            if (n >= this.maxLen) {
                history.shift();
            }
            history.push(state);
            this.notify({ id: History_1.EVENT_RECORD, value: state });
            this.future.length = 0;
        }
    }
    deref() {
        return this.state.deref();
    }
    addWatch(id, fn) {
        return this.state.addWatch(id, fn);
    }
    removeWatch(id) {
        return this.state.removeWatch(id);
    }
    notifyWatches(oldState, newState) {
        return this.state.notifyWatches(oldState, newState);
    }
    addView(path, tx, lazy = true) {
        return new View(this, path, tx, lazy);
    }
    release() {
        this.state.release();
        delete this.state;
        return true;
    }
    addListener(id, fn, scope) { }
    removeListener(id, fn, scope) { }
    notify(e) { }
};
exports.History.EVENT_UNDO = "undo";
exports.History.EVENT_REDO = "redo";
exports.History.EVENT_RECORD = "record";
exports.History = History_1 = __decorate$1([
    api.INotifyMixin
], exports.History);

class Transacted {
    constructor(parent) {
        this.parent = parent;
        this.current = undefined;
        this.isActive = false;
        this.id = `tx${nextID()}-`;
    }
    get value() {
        return this.deref();
    }
    set value(val) {
        this.reset(val);
    }
    get isTransaction() {
        return this.isActive;
    }
    deref() {
        return this.isActive ? this.current : this.parent.deref();
    }
    equiv(o) {
        return this === o;
    }
    reset(val) {
        this.ensureTx();
        this.current = val;
        return val;
    }
    resetIn(path, val) {
        this.ensureTx();
        return this.reset(paths.setIn(this.current, path, val));
    }
    swap(fn, ...args) {
        this.ensureTx();
        return this.reset(fn.apply(null, [this.current, ...args]));
    }
    swapIn(path, fn, ...args) {
        this.ensureTx();
        return this.reset(paths.updateIn(this.current, path, fn, ...args));
    }
    begin() {
        api.assert(!this.isActive, "transaction already started");
        this.current = this.parent.deref();
        this.isActive = true;
    }
    commit() {
        this.ensureTx();
        const val = this.current;
        this.parent.reset(this.current);
        this.isActive = false;
        this.current = undefined;
        return val;
    }
    cancel() {
        this.ensureTx();
        this.isActive = false;
        this.current = undefined;
    }
    addWatch(id, watch) {
        return this.parent.addWatch(this.id + id, (_, prev, curr) => watch(id, prev, curr));
    }
    removeWatch(id) {
        return this.parent.removeWatch(this.id + id);
    }
    notifyWatches(old, curr) {
        this.parent.notifyWatches(old, curr);
    }
    addView(path, tx, lazy = true) {
        return new View(this, path, tx, lazy);
    }
    release() {
        delete this.parent;
        delete this.current;
        delete this.isActive;
        delete this._watches;
        return true;
    }
    ensureTx() {
        api.assert(this.isActive, "no active transaction");
    }
}

exports.Cursor = Cursor;
exports.Transacted = Transacted;
exports.View = View;
