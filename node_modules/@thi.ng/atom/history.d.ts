import type { Event, Listener, Path, Predicate2, Watch } from "@thi.ng/api";
import type { IAtom, IHistory, IView, SwapFn, ViewTransform } from "./api";
/**
 * Undo/redo history stack wrapper for atoms and cursors. Implements
 * {@link IAtom} interface and so can be used directly in place and
 * delegates to wrapped atom/cursor.
 *
 * @remarks
 * Value changes are only recorded in history if `changed` predicate
 * returns truthy value, or else by calling {@link History.record}
 * directly. This class too implements the {@link @thi.ng/api#INotify}
 * interface to support event listeners for {@link History.undo},
 * {@link History.redo} and {@link History.record}.
 */
export declare class History<T> implements IHistory<T> {
    static readonly EVENT_UNDO = "undo";
    static readonly EVENT_REDO = "redo";
    static readonly EVENT_RECORD = "record";
    state: IAtom<T>;
    maxLen: number;
    changed: Predicate2<T>;
    history: T[];
    future: T[];
    /**
     * @param state - parent state
     * @param maxLen - max size of undo stack
     * @param changed - predicate to determine changed values (default `!equiv(a,b)`)
     */
    constructor(state: IAtom<T>, maxLen?: number, changed?: Predicate2<T>);
    get value(): T;
    set value(val: T);
    canUndo(): boolean;
    canRedo(): boolean;
    /**
     * Clears history & future stacks
     */
    clear(): void;
    /**
     * Attempts to re-apply most recent historical value to atom and
     * returns it if successful (i.e. there's a history).
     *
     * @remarks
     * Before the switch, first records the atom's current value into
     * the future stack (to enable {@link History.redo} feature).
     * Returns `undefined` if there's no history.
     *
     * If undo was possible, the `History.EVENT_UNDO` event is emitted
     * after the restoration with both the `prev` and `curr` (restored)
     * states provided as event value (and object with these two keys).
     * This allows for additional state handling to be executed, e.g.
     * application of the "Command pattern". See
     * {@link History.addListener} for registering event listeners.
     */
    undo(): T | undefined;
    /**
     * Attempts to re-apply most recent value from future stack to atom
     * and returns it if successful (i.e. there's a future).
     *
     * @remarks
     * Before the switch, first records the atom's current value into
     * the history stack (to enable {@link History.undo} feature).
     * Returns `undefined` if there's no future (so sad!).
     *
     * If redo was possible, the `History.EVENT_REDO` event is emitted
     * after the restoration with both the `prev` and `curr` (restored)
     * states provided as event value (and object with these two keys).
     * This allows for additional state handling to be executed, e.g.
     * application of the "Command pattern". See
     * {@link History.addListener} for registering event listeners.
     */
    redo(): T | undefined;
    /**
     * `IReset.reset()` implementation. Delegates to wrapped
     * atom/cursor, but too applies `changed` predicate to determine if
     * there was a change and if the previous value should be recorded.
     *
     * @param val - replacement value
     */
    reset(val: T): T;
    resetIn<V>(path: Path, val: V): T;
    /**
     * `ISwap.swap()` implementation. Delegates to wrapped atom/cursor,
     * but too applies `changed` predicate to determine if there was a
     * change and if the previous value should be recorded.
     *
     * @param fn - update function
     * @param args - additional args passed to `fn`
     */
    swap(fn: SwapFn<T>, ...args: any[]): T;
    swapIn<V>(path: Path, fn: SwapFn<V>, ...args: any[]): any;
    /**
     * Records given state in history. This method is only needed when
     * manually managing snapshots, i.e. when applying multiple swaps on
     * the wrapped atom directly, but not wanting to create an history
     * entry for each change.
     *
     * @remarks
     * **DO NOT call this explicitly if using {@link History.reset} /
     * {@link History.swap} etc.**
     *
     * If no `state` is given, uses the wrapped atom's current state
     * value (user code SHOULD always call without arg).
     *
     * If recording succeeded, the `History.EVENT_RECORD` event is
     * emitted with the recorded state provided as event value.
     *
     * @param state - state to record
     */
    record(state?: T): void;
    /**
     * Returns wrapped atom's **current** value.
     */
    deref(): T;
    /**
     * `IWatch.addWatch()` implementation. Delegates to wrapped
     * atom/cursor.
     *
     * @param id - watch ID
     * @param fn - watch function
     */
    addWatch(id: string, fn: Watch<T>): boolean;
    /**
     * `IWatch.removeWatch()` implementation. Delegates to wrapped
     * atom/cursor.
     *
     * @param id - watch iD
     */
    removeWatch(id: string): boolean;
    /**
     * `IWatch.notifyWatches()` implementation. Delegates to wrapped
     * atom/cursor.
     *
     * @param oldState -
     * @param newState -
     */
    notifyWatches(oldState: T, newState: T): void;
    addView<V>(path: Path, tx?: ViewTransform<V>, lazy?: boolean): IView<V>;
    release(): boolean;
    /** {@inheritDoc @thi.ng/api#INotify.addListener} */
    addListener(id: string, fn: Listener, scope?: any): boolean;
    /** {@inheritDoc @thi.ng/api#INotify.removeListener} */
    removeListener(id: string, fn: Listener, scope?: any): boolean;
    /** {@inheritDoc @thi.ng/api#INotify.notify} */
    notify(e: Event): void;
}
//# sourceMappingURL=history.d.ts.map